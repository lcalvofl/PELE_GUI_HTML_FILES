window.Modernizr = function (a, b, c) {
        function D(a) {
            j.cssText = a
        }

        function E(a, b) {
            return D(n.join(a + ";") + (b || ""))
        }

        function F(a, b) {
            return typeof a === b
        }

        function G(a, b) {
            return !!~("" + a).indexOf(b)
        }

        function H(a, b) {
            for (var d in a) {
                var e = a[d];
                if (!G(e, "-") && j[e] !== c) return "pfx" == b ? e : !0
            }
            return !1
        }

        function I(a, b, d) {
            for (var e in a) {
                var f = b[a[e]];
                if (f !== c) return d === !1 ? a[e] : F(f, "function") ? f.bind(d || b) : f
            }
            return !1
        }

        function J(a, b, c) {
            var d = a.charAt(0).toUpperCase() + a.slice(1),
                e = (a + " " + p.join(d + " ") + d).split(" ");
            return F(b, "string") || F(b, "undefined") ? H(e, b) : (e = (a + " " + q.join(d + " ") + d).split(" "), I(e, b, c))
        }

        function K() {
            e.input = function (c) {
                for (var d = 0, e = c.length; e > d; d++) u[c[d]] = c[d] in k;
                return u.list && (u.list = !!b.createElement("datalist") && !!a.HTMLDataListElement), u
            }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")), e.inputtypes = function (a) {
                for (var e, f, h, d = 0, i = a.length; i > d; d++) k.setAttribute("type", f = a[d]), e = "text" !== k.type, e && (k.value = l, k.style.cssText = "position:absolute;visibility:hidden;", /^range$/.test(f) && k.style.WebkitAppearance !== c ? (g.appendChild(k), h = b.defaultView, e = h.getComputedStyle && "textfield" !== h.getComputedStyle(k, null).WebkitAppearance && 0 !== k.offsetHeight, g.removeChild(k)) : /^(search|tel)$/.test(f) || (e = /^(url|email)$/.test(f) ? k.checkValidity && k.checkValidity() === !1 : k.value != l)), t[a[d]] = !!e;
                return t
            }("search tel url email datetime date month week time datetime-local number range color".split(" "))
        }
        var x, C, d = "2.8.1",
            e = {},
            f = !0,
            g = b.documentElement,
            h = "modernizr",
            i = b.createElement(h),
            j = i.style,
            k = b.createElement("input"),
            l = ":)",
            m = {}.toString,
            n = " -webkit- -moz- -o- -ms- ".split(" "),
            o = "Webkit Moz O ms",
            p = o.split(" "),
            q = o.toLowerCase().split(" "),
            r = {
                svg: "http://www.w3.org/2000/svg"
            },
            s = {},
            t = {},
            u = {},
            v = [],
            w = v.slice,
            y = function (a, c, d, e) {
                var f, i, j, k, l = b.createElement("div"),
                    m = b.body,
                    n = m || b.createElement("body");
                if (parseInt(d, 10))
                    for (; d--;) j = b.createElement("div"), j.id = e ? e[d] : h + (d + 1), l.appendChild(j);
                return f = ["&#173;", '<style id="s', h, '">', a, "</style>"].join(""), l.id = h, (m ? l : n).innerHTML += f, n.appendChild(l), m || (n.style.background = "", n.style.overflow = "hidden", k = g.style.overflow, g.style.overflow = "hidden", g.appendChild(n)), i = c(l, a), m ? l.parentNode.removeChild(l) : (n.parentNode.removeChild(n), g.style.overflow = k), !!i
            },
            z = function (b) {
                var c = a.matchMedia || a.msMatchMedia;
                if (c) return c(b) && c(b).matches || !1;
                var d;
                return y("@media " + b + " { #" + h + " { position: absolute; } }", function (b) {
                    d = "absolute" == (a.getComputedStyle ? getComputedStyle(b, null) : b.currentStyle).position
                }), d
            },
            A = function () {
                function d(d, e) {
                    e = e || b.createElement(a[d] || "div"), d = "on" + d;
                    var f = d in e;
                    return f || (e.setAttribute || (e = b.createElement("div")), e.setAttribute && e.removeAttribute && (e.setAttribute(d, ""), f = F(e[d], "function"), F(e[d], "undefined") || (e[d] = c), e.removeAttribute(d))), e = null, f
                }
                var a = {
                    select: "input",
                    change: "input",
                    submit: "form",
                    reset: "form",
                    error: "img",
                    load: "img",
                    abort: "img"
                };
                return d
            }(),
            B = {}.hasOwnProperty;
        C = F(B, "undefined") || F(B.call, "undefined") ? function (a, b) {
            return b in a && F(a.constructor.prototype[b], "undefined")
        } : function (a, b) {
            return B.call(a, b)
        }, Function.prototype.bind || (Function.prototype.bind = function (b) {
            var c = this;
            if ("function" != typeof c) throw new TypeError;
            var d = w.call(arguments, 1),
                e = function () {
                    if (this instanceof e) {
                        var a = function () {};
                        a.prototype = c.prototype;
                        var f = new a,
                            g = c.apply(f, d.concat(w.call(arguments)));
                        return Object(g) === g ? g : f
                    }
                    return c.apply(b, d.concat(w.call(arguments)))
                };
            return e
        }), s.flexbox = function () {
            return J("flexWrap")
        }, s.flexboxlegacy = function () {
            return J("boxDirection")
        }, s.canvas = function () {
            var a = b.createElement("canvas");
            return !!a.getContext && !!a.getContext("2d")
        }, s.canvastext = function () {
            return !!e.canvas && !!F(b.createElement("canvas").getContext("2d").fillText, "function")
        }, s.webgl = function () {
            return !!a.WebGLRenderingContext
        }, s.touch = function () {
            var c;
            return "ontouchstart" in a || a.DocumentTouch && b instanceof DocumentTouch ? c = !0 : y(["@media (", n.join("touch-enabled),("), h, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function (a) {
                c = 9 === a.offsetTop
            }), c
        }, s.geolocation = function () {
            return "geolocation" in navigator
        }, s.postmessage = function () {
            return !!a.postMessage
        }, s.websqldatabase = function () {
            return !!a.openDatabase
        }, s.indexedDB = function () {
            return !!J("indexedDB", a)
        }, s.hashchange = function () {
            return A("hashchange", a) && (b.documentMode === c || b.documentMode > 7)
        }, s.history = function () {
            return !!a.history && !!history.pushState
        }, s.draganddrop = function () {
            var a = b.createElement("div");
            return "draggable" in a || "ondragstart" in a && "ondrop" in a
        }, s.websockets = function () {
            return "WebSocket" in a || "MozWebSocket" in a
        }, s.rgba = function () {
            return D("background-color:rgba(150,255,150,.5)"), G(j.backgroundColor, "rgba")
        }, s.hsla = function () {
            return D("background-color:hsla(120,40%,100%,.5)"), G(j.backgroundColor, "rgba") || G(j.backgroundColor, "hsla")
        }, s.multiplebgs = function () {
            return D("background:url(https://),url(https://),red url(https://)"), /(url\s*\(.*?){3}/.test(j.background)
        }, s.backgroundsize = function () {
            return J("backgroundSize")
        }, s.borderimage = function () {
            return J("borderImage")
        }, s.borderradius = function () {
            return J("borderRadius")
        }, s.boxshadow = function () {
            return J("boxShadow")
        }, s.textshadow = function () {
            return "" === b.createElement("div").style.textShadow
        }, s.opacity = function () {
            return E("opacity:.55"), /^0.55$/.test(j.opacity)
        }, s.cssanimations = function () {
            return J("animationName")
        }, s.csscolumns = function () {
            return J("columnCount")
        }, s.cssgradients = function () {
            var a = "background-image:",
                b = "gradient(linear,left top,right bottom,from(#9f9),to(white));",
                c = "linear-gradient(left top,#9f9, white);";
            return D((a + "-webkit- ".split(" ").join(b + a) + n.join(c + a)).slice(0, -a.length)), G(j.backgroundImage, "gradient")
        }, s.cssreflections = function () {
            return J("boxReflect")
        }, s.csstransforms = function () {
            return !!J("transform")
        }, s.csstransforms3d = function () {
            var a = !!J("perspective");
            return a && "webkitPerspective" in g.style && y("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}", function (b) {
                a = 9 === b.offsetLeft && 3 === b.offsetHeight
            }), a
        }, s.csstransitions = function () {
            return J("transition")
        }, s.fontface = function () {
            var a;
            return y('@font-face {font-family:"font";src:url("https://")}', function (c, d) {
                var e = b.getElementById("smodernizr"),
                    f = e.sheet || e.styleSheet,
                    g = f ? f.cssRules && f.cssRules[0] ? f.cssRules[0].cssText : f.cssText || "" : "";
                a = /src/i.test(g) && 0 === g.indexOf(d.split(" ")[0])
            }), a
        }, s.generatedcontent = function () {
            var a;
            return y(["#", h, "{font:0/0 a}#", h, ':after{content:"', l, '";visibility:hidden;font:3px/1 a}'].join(""), function (b) {
                a = b.offsetHeight >= 3
            }), a
        }, s.video = function () {
            var a = b.createElement("video"),
                c = !1;
            try {
                (c = !!a.canPlayType) && (c = new Boolean(c), c.ogg = a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""), c.h264 = a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""), c.webm = a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, ""))
            } catch (d) {}
            return c
        }, s.audio = function () {
            var a = b.createElement("audio"),
                c = !1;
            try {
                (c = !!a.canPlayType) && (c = new Boolean(c), c.ogg = a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), c.mp3 = a.canPlayType("audio/mpeg;").replace(/^no$/, ""), c.wav = a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), c.m4a = (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;")).replace(/^no$/, ""))
            } catch (d) {}
            return c
        }, s.localstorage = function () {
            try {
                return localStorage.setItem(h, h), localStorage.removeItem(h), !0
            } catch (a) {
                return !1
            }
        }, s.sessionstorage = function () {
            try {
                return sessionStorage.setItem(h, h), sessionStorage.removeItem(h), !0
            } catch (a) {
                return !1
            }
        }, s.webworkers = function () {
            return !!a.Worker
        }, s.applicationcache = function () {
            return !!a.applicationCache
        }, s.svg = function () {
            return !!b.createElementNS && !!b.createElementNS(r.svg, "svg").createSVGRect
        }, s.inlinesvg = function () {
            var a = b.createElement("div");
            return a.innerHTML = "<svg/>", (a.firstChild && a.firstChild.namespaceURI) == r.svg
        }, s.smil = function () {
            return !!b.createElementNS && /SVGAnimate/.test(m.call(b.createElementNS(r.svg, "animate")))
        }, s.svgclippaths = function () {
            return !!b.createElementNS && /SVGClipPath/.test(m.call(b.createElementNS(r.svg, "clipPath")))
        };
        for (var L in s) C(s, L) && (x = L.toLowerCase(), e[x] = s[L](), v.push((e[x] ? "" : "no-") + x));
        return e.input || K(), e.addTest = function (a, b) {
                if ("object" == typeof a)
                    for (var d in a) C(a, d) && e.addTest(d, a[d]);
                else {
                    if (a = a.toLowerCase(), e[a] !== c) return e;
                    b = "function" == typeof b ? b() : b, "undefined" != typeof f && f && (g.className += " " + (b ? "" : "no-") + a), e[a] = b
                }
                return e
            }, D(""), i = k = null,
            function (a, b) {
                function l(a, b) {
                    var c = a.createElement("p"),
                        d = a.getElementsByTagName("head")[0] || a.documentElement;
                    return c.innerHTML = "x<style>" + b + "</style>", d.insertBefore(c.lastChild, d.firstChild)
                }

                function m() {
                    var a = s.elements;
                    return "string" == typeof a ? a.split(" ") : a
                }

                function n(a) {
                    var b = j[a[h]];
                    return b || (b = {}, i++, a[h] = i, j[i] = b), b
                }

                function o(a, c, d) {
                    if (c || (c = b), k) return c.createElement(a);
                    d || (d = n(c));
                    var g;
                    return g = d.cache[a] ? d.cache[a].cloneNode() : f.test(a) ? (d.cache[a] = d.createElem(a)).cloneNode() : d.createElem(a), !g.canHaveChildren || e.test(a) || g.tagUrn ? g : d.frag.appendChild(g)
                }

                function p(a, c) {
                    if (a || (a = b), k) return a.createDocumentFragment();
                    c = c || n(a);
                    for (var d = c.frag.cloneNode(), e = 0, f = m(), g = f.length; g > e; e++) d.createElement(f[e]);
                    return d
                }

                function q(a, b) {
                    b.cache || (b.cache = {}, b.createElem = a.createElement, b.createFrag = a.createDocumentFragment, b.frag = b.createFrag()), a.createElement = function (c) {
                        return s.shivMethods ? o(c, a, b) : b.createElem(c)
                    }, a.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + m().join().replace(/[\w\-]+/g, function (a) {
                        return b.createElem(a), b.frag.createElement(a), 'c("' + a + '")'
                    }) + ");return n}")(s, b.frag)
                }

                function r(a) {
                    a || (a = b);
                    var c = n(a);
                    return s.shivCSS && !g && !c.hasCSS && (c.hasCSS = !!l(a, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")), k || q(a, c), a
                }
                var g, k, c = "3.7.0",
                    d = a.html5 || {},
                    e = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,
                    f = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,
                    h = "_html5shiv",
                    i = 0,
                    j = {};
                ! function () {
                    try {
                        var a = b.createElement("a");
                        a.innerHTML = "<xyz></xyz>", g = "hidden" in a, k = 1 == a.childNodes.length || function () {
                            b.createElement("a");
                            var a = b.createDocumentFragment();
                            return "undefined" == typeof a.cloneNode || "undefined" == typeof a.createDocumentFragment || "undefined" == typeof a.createElement
                        }()
                    } catch (c) {
                        g = !0, k = !0
                    }
                }();
                var s = {
                    elements: d.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
                    version: c,
                    shivCSS: d.shivCSS !== !1,
                    supportsUnknownElements: k,
                    shivMethods: d.shivMethods !== !1,
                    type: "default",
                    shivDocument: r,
                    createElement: o,
                    createDocumentFragment: p
                };
                a.html5 = s, r(b)
            }(this, b), e._version = d, e._prefixes = n, e._domPrefixes = q, e._cssomPrefixes = p, e.mq = z, e.hasEvent = A, e.testProp = function (a) {
                return H([a])
            }, e.testAllProps = J, e.testStyles = y, g.className = g.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (f ? " js " + v.join(" ") : ""), e
    }(this, this.document),
    function (a, b, c) {
        function d(a) {
            return "[object Function]" == o.call(a)
        }

        function e(a) {
            return "string" == typeof a
        }

        function f() {}

        function g(a) {
            return !a || "loaded" == a || "complete" == a || "uninitialized" == a
        }

        function h() {
            var a = p.shift();
            q = 1, a ? a.t ? m(function () {
                ("c" == a.t ? B.injectCss : B.injectJs)(a.s, 0, a.a, a.x, a.e, 1)
            }, 0) : (a(), h()) : q = 0
        }

        function i(a, c, d, e, f, i, j) {
            function k(b) {
                if (!o && g(l.readyState) && (u.r = o = 1, !q && h(), l.onload = l.onreadystatechange = null, b)) {
                    "img" != a && m(function () {
                        t.removeChild(l)
                    }, 50);
                    for (var d in y[c]) y[c].hasOwnProperty(d) && y[c][d].onload()
                }
            }
            var j = j || B.errorTimeout,
                l = b.createElement(a),
                o = 0,
                r = 0,
                u = {
                    t: d,
                    s: c,
                    e: f,
                    a: i,
                    x: j
                };
            1 === y[c] && (r = 1, y[c] = []), "object" == a ? l.data = c : (l.src = c, l.type = a), l.width = l.height = "0", l.onerror = l.onload = l.onreadystatechange = function () {
                k.call(this, r)
            }, p.splice(e, 0, u), "img" != a && (r || 2 === y[c] ? (t.insertBefore(l, s ? null : n), m(k, j)) : y[c].push(l))
        }

        function j(a, b, c, d, f) {
            return q = 0, b = b || "j", e(a) ? i("c" == b ? v : u, a, b, this.i++, c, d, f) : (p.splice(this.i++, 0, a), 1 == p.length && h()), this
        }

        function k() {
            var a = B;
            return a.loader = {
                load: j,
                i: 0
            }, a
        }
        var A, B, l = b.documentElement,
            m = a.setTimeout,
            n = b.getElementsByTagName("script")[0],
            o = {}.toString,
            p = [],
            q = 0,
            r = "MozAppearance" in l.style,
            s = r && !!b.createRange().compareNode,
            t = s ? l : n.parentNode,
            l = a.opera && "[object Opera]" == o.call(a.opera),
            l = !!b.attachEvent && !l,
            u = r ? "object" : l ? "script" : "img",
            v = l ? "script" : u,
            w = Array.isArray || function (a) {
                return "[object Array]" == o.call(a)
            },
            x = [],
            y = {},
            z = {
                timeout: function (a, b) {
                    return b.length && (a.timeout = b[0]), a
                }
            };
        B = function (a) {
            function b(a) {
                var e, f, g, a = a.split("!"),
                    b = x.length,
                    c = a.pop(),
                    d = a.length,
                    c = {
                        url: c,
                        origUrl: c,
                        prefixes: a
                    };
                for (f = 0; d > f; f++) g = a[f].split("="), (e = z[g.shift()]) && (c = e(c, g));
                for (f = 0; b > f; f++) c = x[f](c);
                return c
            }

            function g(a, e, f, g, h) {
                var i = b(a),
                    j = i.autoCallback;
                i.url.split(".").pop().split("?").shift(), i.bypass || (e && (e = d(e) ? e : e[a] || e[g] || e[a.split("/").pop().split("?")[0]]), i.instead ? i.instead(a, e, f, g, h) : (y[i.url] ? i.noexec = !0 : y[i.url] = 1, f.load(i.url, i.forceCSS || !i.forceJS && "css" == i.url.split(".").pop().split("?").shift() ? "c" : c, i.noexec, i.attrs, i.timeout), (d(e) || d(j)) && f.load(function () {
                    k(), e && e(i.origUrl, h, g), j && j(i.origUrl, h, g), y[i.url] = 2
                })))
            }

            function h(a, b) {
                function c(a, c) {
                    if (a) {
                        if (e(a)) c || (j = function () {
                            var a = [].slice.call(arguments);
                            k.apply(this, a), l()
                        }), g(a, j, b, 0, h);
                        else if (Object(a) === a)
                            for (n in m = function () {
                                var c, b = 0;
                                for (c in a) a.hasOwnProperty(c) && b++;
                                return b
                            }(), a) a.hasOwnProperty(n) && (!c && !--m && (d(j) ? j = function () {
                                var a = [].slice.call(arguments);
                                k.apply(this, a), l()
                            } : j[n] = function (a) {
                                return function () {
                                    var b = [].slice.call(arguments);
                                    a && a.apply(this, b), l()
                                }
                            }(k[n])), g(a[n], j, b, n, h))
                    } else !c && l()
                }
                var m, n, h = !!a.test,
                    i = a.load || a.both,
                    j = a.callback || f,
                    k = j,
                    l = a.complete || f;
                c(h ? a.yep : a.nope, !!i), i && c(i)
            }
            var i, j, l = this.yepnope.loader;
            if (e(a)) g(a, 0, l, 0);
            else if (w(a))
                for (i = 0; i < a.length; i++) j = a[i], e(j) ? g(j, 0, l, 0) : w(j) ? B(j) : Object(j) === j && h(j, l);
            else Object(a) === a && h(a, l)
        }, B.addPrefix = function (a, b) {
            z[a] = b
        }, B.addFilter = function (a) {
            x.push(a)
        }, B.errorTimeout = 1e4, null == b.readyState && b.addEventListener && (b.readyState = "loading", b.addEventListener("DOMContentLoaded", A = function () {
            b.removeEventListener("DOMContentLoaded", A, 0), b.readyState = "complete"
        }, 0)), a.yepnope = k(), a.yepnope.executeStack = h, a.yepnope.injectJs = function (a, c, d, e, i, j) {
            var l, o, k = b.createElement("script"),
                e = e || B.errorTimeout;
            k.src = a;
            for (o in d) k.setAttribute(o, d[o]);
            c = j ? h : c || f, k.onreadystatechange = k.onload = function () {
                !l && g(k.readyState) && (l = 1, c(), k.onload = k.onreadystatechange = null)
            }, m(function () {
                l || (l = 1, c(1))
            }, e), i ? k.onload() : n.parentNode.insertBefore(k, n)
        }, a.yepnope.injectCss = function (a, c, d, e, g, i) {
            var j, e = b.createElement("link"),
                c = i ? h : c || f;
            e.href = a, e.rel = "stylesheet", e.type = "text/css";
            for (j in d) e.setAttribute(j, d[j]);
            g || (n.parentNode.insertBefore(e, n), m(c, 0))
        }
    }(this, document), Modernizr.load = function () {
        yepnope.apply(window, [].slice.call(arguments, 0))
    },
    /*!
     * jQuery JavaScript Library v2.1.1
     * http://jquery.com/
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     *
     * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2014-05-01T17:11Z
     */
    function (global, factory) {
        "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function (w) {
            if (!w.document) throw new Error("jQuery requires a window with a document");
            return factory(w)
        } : factory(global)
    }("undefined" != typeof window ? window : this, function (window, noGlobal) {
        function isArraylike(obj) {
            var length = obj.length,
                type = jQuery.type(obj);
            return "function" === type || jQuery.isWindow(obj) ? !1 : 1 === obj.nodeType && length ? !0 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
        }

        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            });
            if (qualifier.nodeType) return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not
            });
            if ("string" == typeof qualifier) {
                if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
                qualifier = jQuery.filter(qualifier, elements)
            }
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) >= 0 !== not
            })
        }

        function sibling(cur, dir) {
            for (;
                (cur = cur[dir]) && 1 !== cur.nodeType;);
            return cur
        }

        function createOptions(options) {
            var object = optionsCache[options] = {};
            return jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                object[flag] = !0
            }), object
        }

        function completed() {
            document.removeEventListener("DOMContentLoaded", completed, !1), window.removeEventListener("load", completed, !1), jQuery.ready()
        }

        function Data() {
            Object.defineProperty(this.cache = {}, 0, {
                get: function () {
                    return {}
                }
            }), this.expando = jQuery.expando + Math.random()
        }

        function dataAttr(elem, key, data) {
            var name;
            if (void 0 === data && 1 === elem.nodeType)
                if (name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase(), data = elem.getAttribute(name), "string" == typeof data) {
                    try {
                        data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data
                    } catch (e) {}
                    data_user.set(elem, key, data)
                } else data = void 0;
            return data
        }

        function returnTrue() {
            return !0
        }

        function returnFalse() {
            return !1
        }

        function safeActiveElement() {
            try {
                return document.activeElement
            } catch (err) {}
        }

        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
        }

        function disableScript(elem) {
            return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem
        }

        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            return match ? elem.type = match[1] : elem.removeAttribute("type"), elem
        }

        function setGlobalEval(elems, refElements) {
            for (var i = 0, l = elems.length; l > i; i++) data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
        }

        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (1 === dest.nodeType) {
                if (data_priv.hasData(src) && (pdataOld = data_priv.access(src), pdataCur = data_priv.set(dest, pdataOld), events = pdataOld.events)) {
                    delete pdataCur.handle, pdataCur.events = {};
                    for (type in events)
                        for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i])
                }
                data_user.hasData(src) && (udataOld = data_user.access(src), udataCur = jQuery.extend({}, udataOld), data_user.set(dest, udataCur))
            }
        }

        function getAll(context, tag) {
            var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
            return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
        }

        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue)
        }

        function actualDisplay(name, doc) {
            var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body),
                display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
            return elem.detach(), display
        }

        function defaultDisplay(nodeName) {
            var doc = document,
                display = elemdisplay[nodeName];
            return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement), doc = iframe[0].contentDocument, doc.write(), doc.close(), display = actualDisplay(nodeName, doc), iframe.detach()), elemdisplay[nodeName] = display), display
        }

        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name]), computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
        }

        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function () {
                    return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments)
                }
            }
        }

        function vendorPropName(style, name) {
            if (name in style) return name;
            for (var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--;)
                if (name = cssPrefixes[i] + capName, name in style) return name;
            return origName
        }

        function setPositiveNumber(elem, value, subtract) {
            var matches = rnumsplit.exec(value);
            return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
        }

        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
            return val
        }

        function getWidthOrHeight(elem, name, extra) {
            var valueIsBorderBox = !0,
                val = "width" === name ? elem.offsetWidth : elem.offsetHeight,
                styles = getStyles(elem),
                isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
            if (0 >= val || null == val) {
                if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), rnumnonpx.test(val)) return val;
                valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), val = parseFloat(val) || 0
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
        }

        function showHide(elements, show) {
            for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index], elem.style && (values[index] = data_priv.get(elem, "olddisplay"), display = elem.style.display, show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName)))) : (hidden = isHidden(elem), "none" === display && hidden || data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
            for (index = 0; length > index; index++) elem = elements[index], elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
            return elements
        }

        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
        }

        function createFxNow() {
            return setTimeout(function () {
                fxNow = void 0
            }), fxNow = jQuery.now()
        }

        function genFx(type, includeWidth) {
            var which, i = 0,
                attrs = {
                    height: type
                };
            for (includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth) which = cssExpand[i], attrs["margin" + which] = attrs["padding" + which] = type;
            return includeWidth && (attrs.opacity = attrs.width = type), attrs
        }

        function createTween(value, prop, animation) {
            for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++)
                if (tween = collection[index].call(animation, prop, value)) return tween
        }

        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this,
                orig = {},
                style = elem.style,
                hidden = elem.nodeType && isHidden(elem),
                dataShow = data_priv.get(elem, "fxshow");
            opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function () {
                hooks.unqueued || oldfire()
            }), hooks.unqueued++, anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
                })
            })), 1 === elem.nodeType && ("height" in props || "width" in props) && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], display = jQuery.css(elem, "display"), checkDisplay = "none" === display ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display, "inline" === checkDisplay && "none" === jQuery.css(elem, "float") && (style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function () {
                style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
            }));
            for (prop in props)
                if (value = props[prop], rfxtypes.exec(value)) {
                    if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                        if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                        hidden = !0
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
                } else display = void 0;
            if (jQuery.isEmptyObject(orig)) "inline" === ("none" === display ? defaultDisplay(elem.nodeName) : display) && (style.display = display);
            else {
                dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = data_priv.access(elem, "fxshow", {}), toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() : anim.done(function () {
                    jQuery(elem).hide()
                }), anim.done(function () {
                    var prop;
                    data_priv.remove(elem, "fxshow");
                    for (prop in orig) jQuery.style(elem, prop, orig[prop])
                });
                for (prop in orig) tween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, tween.start = "width" === prop || "height" === prop ? 1 : 0))
            }
        }

        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props)
                if (name = jQuery.camelCase(index), easing = specialEasing[name], value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], hooks && "expand" in hooks) {
                    value = hooks.expand(value), delete props[name];
                    for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing)
                } else specialEasing[name] = easing
        }

        function Animation(elem, properties, options) {
            var result, stopped, index = 0,
                length = animationPrefilters.length,
                deferred = jQuery.Deferred().always(function () {
                    delete tick.elem
                }),
                tick = function () {
                    if (stopped) return !1;
                    for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
                    return deferred.notifyWith(elem, [animation, percent, remaining]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [animation]), !1)
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(!0, {
                        specialEasing: {}
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function (prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        return animation.tweens.push(tween), tween
                    },
                    stop: function (gotoEnd) {
                        var index = 0,
                            length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) return this;
                        for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
                        return gotoEnd ? deferred.resolveWith(elem, [animation, gotoEnd]) : deferred.rejectWith(elem, [animation, gotoEnd]), this
                    }
                }),
                props = animation.props;
            for (propFilter(props, animation.opts.specialEasing); length > index; index++)
                if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
            return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
        }

        function addToPrefiltersOrTransports(structure) {
            return function (dataTypeExpression, func) {
                "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
                var dataType, i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                if (jQuery.isFunction(func))
                    for (; dataType = dataTypes[i++];) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
            }
        }

        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            function inspect(dataType) {
                var selected;
                return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
                }), selected
            }
            var inspected = {},
                seekingTransport = structure === transports;
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
        }

        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
            return deep && jQuery.extend(!0, target, deep), target
        }

        function ajaxHandleResponses(s, jqXHR, responses) {
            for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
                "*" === dataTypes[0];) dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
            if (ct)
                for (type in contents)
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break
                    }
            if (dataTypes[0] in responses) finalDataType = dataTypes[0];
            else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                        finalDataType = type;
                        break
                    }
                    firstDataType || (firstDataType = type)
                }
                finalDataType = finalDataType || firstDataType
            }
            return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]) : void 0
        }

        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {},
                dataTypes = s.dataTypes.slice();
            if (dataTypes[1])
                for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
            for (current = dataTypes.shift(); current;)
                if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                    if ("*" === current) current = prev;
                    else if ("*" !== prev && prev !== current) {
                if (conv = converters[prev + " " + current] || converters["* " + current], !conv)
                    for (conv2 in converters)
                        if (tmp = conv2.split(" "), tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                            conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], dataTypes.unshift(tmp[1]));
                            break
                        }
                if (conv !== !0)
                    if (conv && s["throws"]) response = conv(response);
                    else try {
                        response = conv(response)
                    } catch (e) {
                        return {
                            state: "parsererror",
                            error: conv ? e : "No conversion from " + prev + " to " + current
                        }
                    }
            }
            return {
                state: "success",
                data: response
            }
        }

        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) jQuery.each(obj, function (i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add)
            });
            else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj);
            else
                for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
        }

        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView
        }
        var arr = [],
            slice = arr.slice,
            concat = arr.concat,
            push = arr.push,
            indexOf = arr.indexOf,
            class2type = {},
            toString = class2type.toString,
            hasOwn = class2type.hasOwnProperty,
            support = {},
            document = window.document,
            version = "2.1.1",
            jQuery = function (selector, context) {
                return new jQuery.fn.init(selector, context)
            },
            rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
            rmsPrefix = /^-ms-/,
            rdashAlpha = /-([\da-z])/gi,
            fcamelCase = function (all, letter) {
                return letter.toUpperCase()
            };
        jQuery.fn = jQuery.prototype = {
            jquery: version,
            constructor: jQuery,
            selector: "",
            length: 0,
            toArray: function () {
                return slice.call(this)
            },
            get: function (num) {
                return null != num ? 0 > num ? this[num + this.length] : this[num] : slice.call(this)
            },
            pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this, ret.context = this.context, ret
            },
            each: function (callback, args) {
                return jQuery.each(this, callback, args)
            },
            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem)
                }))
            },
            slice: function () {
                return this.pushStack(slice.apply(this, arguments))
            },
            first: function () {
                return this.eq(0)
            },
            last: function () {
                return this.eq(-1)
            },
            eq: function (i) {
                var len = this.length,
                    j = +i + (0 > i ? len : 0);
                return this.pushStack(j >= 0 && len > j ? [this[j]] : [])
            },
            end: function () {
                return this.prevObject || this.constructor(null)
            },
            push: push,
            sort: arr.sort,
            splice: arr.splice
        }, jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, i--); length > i; i++)
                if (null != (options = arguments[i]))
                    for (name in options) src = target[name], copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target
        }, jQuery.extend({
            expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function (msg) {
                throw new Error(msg)
            },
            noop: function () {},
            isFunction: function (obj) {
                return "function" === jQuery.type(obj)
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return null != obj && obj === obj.window
            },
            isNumeric: function (obj) {
                return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0
            },
            isPlainObject: function (obj) {
                return "object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj) ? !1 : obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ? !1 : !0
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) return !1;
                return !0
            },
            type: function (obj) {
                return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
            },
            globalEval: function (code) {
                var script, indirect = eval;
                code = jQuery.trim(code), code && (1 === code.indexOf("use strict") ? (script = document.createElement("script"), script.text = code, document.head.appendChild(script).parentNode.removeChild(script)) : indirect(code))
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
            },
            each: function (obj, callback, args) {
                var value, i = 0,
                    length = obj.length,
                    isArray = isArraylike(obj);
                if (args) {
                    if (isArray)
                        for (; length > i && (value = callback.apply(obj[i], args), value !== !1); i++);
                    else
                        for (i in obj)
                            if (value = callback.apply(obj[i], args), value === !1) break
                } else if (isArray)
                    for (; length > i && (value = callback.call(obj[i], i, obj[i]), value !== !1); i++);
                else
                    for (i in obj)
                        if (value = callback.call(obj[i], i, obj[i]), value === !1) break; return obj
            },
            trim: function (text) {
                return null == text ? "" : (text + "").replace(rtrim, "")
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
            },
            inArray: function (elem, arr, i) {
                return null == arr ? -1 : indexOf.call(arr, elem, i)
            },
            merge: function (first, second) {
                for (var len = +second.length, j = 0, i = first.length; len > j; j++) first[i++] = second[j];
                return first.length = i, first
            },
            grep: function (elems, callback, invert) {
                for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++) callbackInverse = !callback(elems[i], i), callbackInverse !== callbackExpect && matches.push(elems[i]);
                return matches
            },
            map: function (elems, callback, arg) {
                var value, i = 0,
                    length = elems.length,
                    isArray = isArraylike(elems),
                    ret = [];
                if (isArray)
                    for (; length > i; i++) value = callback(elems[i], i, arg), null != value && ret.push(value);
                else
                    for (i in elems) value = callback(elems[i], i, arg), null != value && ret.push(value);
                return concat.apply([], ret)
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function () {
                    return fn.apply(context || this, args.concat(slice.call(arguments)))
                }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0
            },
            now: Date.now,
            support: support
        }), jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase()
        });
        var Sizzle =
            /*!
             * Sizzle CSS Selector Engine v1.10.19
             * http://sizzlejs.com/
             *
             * Copyright 2013 jQuery Foundation, Inc. and other contributors
             * Released under the MIT license
             * http://jquery.org/license
             *
             * Date: 2014-04-18
             */
            function (window) {
                function Sizzle(selector, context, results, seed) {
                    var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
                    if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, results = results || [], !selector || "string" != typeof selector) return results;
                    if (1 !== (nodeType = context.nodeType) && 9 !== nodeType) return [];
                    if (documentIsHTML && !seed) {
                        if (match = rquickExpr.exec(selector))
                            if (m = match[1]) {
                                if (9 === nodeType) {
                                    if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
                                    if (elem.id === m) return results.push(elem), results
                                } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), results
                            } else {
                                if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), results;
                                if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), results
                            }
                        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            if (nid = old = expando, newContext = context, newSelector = 9 === nodeType && selector, 1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                                for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), nid = "[id='" + nid + "'] ", i = groups.length; i--;) groups[i] = nid + toSelector(groups[i]);
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context, newSelector = groups.join(",")
                            }
                            if (newSelector) try {
                                return push.apply(results, newContext.querySelectorAll(newSelector)), results
                            } catch (qsaError) {} finally {
                                old || context.removeAttribute("id")
                            }
                        }
                    }
                    return select(selector.replace(rtrim, "$1"), context, results, seed)
                }

                function createCache() {
                    function cache(key, value) {
                        return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
                    }
                    var keys = [];
                    return cache
                }

                function markFunction(fn) {
                    return fn[expando] = !0, fn
                }

                function assert(fn) {
                    var div = document.createElement("div");
                    try {
                        return !!fn(div)
                    } catch (e) {
                        return !1
                    } finally {
                        div.parentNode && div.parentNode.removeChild(div), div = null
                    }
                }

                function addHandle(attrs, handler) {
                    for (var arr = attrs.split("|"), i = attrs.length; i--;) Expr.attrHandle[arr[i]] = handler
                }

                function siblingCheck(a, b) {
                    var cur = b && a,
                        diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                    if (diff) return diff;
                    if (cur)
                        for (; cur = cur.nextSibling;)
                            if (cur === b) return -1;
                    return a ? 1 : -1
                }

                function createInputPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return "input" === name && elem.type === type
                    }
                }

                function createButtonPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return ("input" === name || "button" === name) && elem.type === type
                    }
                }

                function createPositionalPseudo(fn) {
                    return markFunction(function (argument) {
                        return argument = +argument, markFunction(function (seed, matches) {
                            for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                        })
                    })
                }

                function testContext(context) {
                    return context && typeof context.getElementsByTagName !== strundefined && context
                }

                function setFilters() {}

                function toSelector(tokens) {
                    for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
                    return selector
                }

                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir,
                        checkNonElements = base && "parentNode" === dir,
                        doneName = done++;
                    return combinator.first ? function (elem, context, xml) {
                        for (; elem = elem[dir];)
                            if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml)
                    } : function (elem, context, xml) {
                        var oldCache, outerCache, newCache = [dirruns, doneName];
                        if (xml) {
                            for (; elem = elem[dir];)
                                if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
                        } else
                            for (; elem = elem[dir];)
                                if (1 === elem.nodeType || checkNonElements) {
                                    if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                                    if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0
                                }
                    }
                }

                function elementMatcher(matchers) {
                    return matchers.length > 1 ? function (elem, context, xml) {
                        for (var i = matchers.length; i--;)
                            if (!matchers[i](elem, context, xml)) return !1;
                        return !0
                    } : matchers[0]
                }

                function multipleContexts(selector, contexts, results) {
                    for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
                    return results
                }

                function condense(unmatched, map, filter, context, xml) {
                    for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++)(elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), mapped && map.push(i));
                    return newUnmatched
                }

                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function (seed, results, context, xml) {
                        var temp, i, elem, preMap = [],
                            postMap = [],
                            preexisting = results.length,
                            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                            matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
                            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                            for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                    postFinder(null, matcherOut = [], temp, xml)
                                }
                                for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                            }
                        } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                    })
                }

                function matcherFromTokens(tokens) {
                    for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                        return elem === checkContext
                    }, implicitRelative, !0), matchAnyContext = addCombinator(function (elem) {
                        return indexOf.call(checkContext, elem) > -1
                    }, implicitRelative, !0), matchers = [
                        function (elem, context, xml) {
                            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                        }
                    ]; len > i; i++)
                        if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                        else {
                            if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                                for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++);
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                    value: " " === tokens[i - 2].type ? "*" : ""
                                })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens))
                            }
                            matchers.push(matcher)
                        }
                    return elementMatcher(matchers)
                }

                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0,
                        byElement = elementMatchers.length > 0,
                        superMatcher = function (seed, context, xml, results, outermost) {
                            var elem, j, matcher, matchedCount = 0,
                                i = "0",
                                unmatched = seed && [],
                                setMatched = [],
                                contextBackup = outermostContext,
                                elems = seed || byElement && Expr.find.TAG("*", outermost),
                                dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1,
                                len = elems.length;
                            for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                                if (byElement && elem) {
                                    for (j = 0; matcher = elementMatchers[j++];)
                                        if (matcher(elem, context, xml)) {
                                            results.push(elem);
                                            break
                                        }
                                    outermost && (dirruns = dirrunsUnique)
                                }
                                bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                            }
                            if (matchedCount += i, bySet && i !== matchedCount) {
                                for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                                if (seed) {
                                    if (matchedCount > 0)
                                        for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                                    setMatched = condense(setMatched)
                                }
                                push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                            }
                            return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                        };
                    return bySet ? markFunction(superMatcher) : superMatcher
                }
                var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date,
                    preferredDoc = window.document,
                    dirruns = 0,
                    done = 0,
                    classCache = createCache(),
                    tokenCache = createCache(),
                    compilerCache = createCache(),
                    sortOrder = function (a, b) {
                        return a === b && (hasDuplicate = !0), 0
                    },
                    strundefined = "undefined",
                    MAX_NEGATIVE = 1 << 31,
                    hasOwn = {}.hasOwnProperty,
                    arr = [],
                    pop = arr.pop,
                    push_native = arr.push,
                    push = arr.push,
                    slice = arr.slice,
                    indexOf = arr.indexOf || function (elem) {
                        for (var i = 0, len = this.length; len > i; i++)
                            if (this[i] === elem) return i;
                        return -1
                    },
                    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    whitespace = "[\\x20\\t\\r\\n\\f]",
                    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                    identifier = characterEncoding.replace("w", "w#"),
                    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
                    pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)",
                    rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
                    rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                    rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
                    rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
                    rpseudo = new RegExp(pseudos),
                    ridentifier = new RegExp("^" + identifier + "$"),
                    matchExpr = {
                        ID: new RegExp("^#(" + characterEncoding + ")"),
                        CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                        TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                        ATTR: new RegExp("^" + attributes),
                        PSEUDO: new RegExp("^" + pseudos),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + booleans + ")$", "i"),
                        needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                    },
                    rinputs = /^(?:input|select|textarea|button)$/i,
                    rheader = /^h\d$/i,
                    rnative = /^[^{]+\{\s*\[native \w/,
                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    rsibling = /[+~]/,
                    rescape = /'|\\/g,
                    runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                    funescape = function (_, escaped, escapedWhitespace) {
                        var high = "0x" + escaped - 65536;
                        return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
                    };
                try {
                    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
                } catch (e) {
                    push = {
                        apply: arr.length ? function (target, els) {
                            push_native.apply(target, slice.call(els))
                        } : function (target, els) {
                            for (var j = target.length, i = 0; target[j++] = els[i++];);
                            target.length = j - 1
                        }
                    }
                }
                support = Sizzle.support = {}, isXML = Sizzle.isXML = function (elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return documentElement ? "HTML" !== documentElement.nodeName : !1
                }, setDocument = Sizzle.setDocument = function (node) {
                    var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc,
                        parent = doc.defaultView;
                    return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = doc.documentElement, documentIsHTML = !isXML(doc), parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", function () {
                        setDocument()
                    }, !1) : parent.attachEvent && parent.attachEvent("onunload", function () {
                        setDocument()
                    })), support.attributes = assert(function (div) {
                        return div.className = "i", !div.getAttribute("className")
                    }), support.getElementsByTagName = assert(function (div) {
                        return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length
                    }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {
                        return div.innerHTML = "<div class='a'></div><div class='a i'></div>", div.firstChild.className = "i", 2 === div.getElementsByClassName("i").length
                    }), support.getById = assert(function (div) {
                        return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length
                    }), support.getById ? (Expr.find.ID = function (id, context) {
                        if (typeof context.getElementById !== strundefined && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m && m.parentNode ? [m] : []
                        }
                    }, Expr.filter.ID = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute("id") === attrId
                        }
                    }) : (delete Expr.find.ID, Expr.filter.ID = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                            return node && node.value === attrId
                        }
                    }), Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
                        return typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag) : void 0
                    } : function (tag, context) {
                        var elem, tmp = [],
                            i = 0,
                            results = context.getElementsByTagName(tag);
                        if ("*" === tag) {
                            for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                            return tmp
                        }
                        return results
                    }, Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
                        return typeof context.getElementsByClassName !== strundefined && documentIsHTML ? context.getElementsByClassName(className) : void 0
                    }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function (div) {
                        div.innerHTML = "<select msallowclip=''><option selected=''></option></select>", div.querySelectorAll("[msallowclip^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked")
                    }), assert(function (div) {
                        var input = doc.createElement("input");
                        input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
                    })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function (div) {
                        support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
                    }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                        var adown = 9 === a.nodeType ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                    } : function (a, b) {
                        if (b)
                            for (; b = b.parentNode;)
                                if (b === a) return !0;
                        return !1
                    }, sortOrder = hasCompare ? function (a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0 : 4 & compare ? -1 : 1)
                    } : function (a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var cur, i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];
                        if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                        if (aup === bup) return siblingCheck(a, b);
                        for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
                        for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
                        for (; ap[i] === bp[i];) i++;
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                    }, doc) : document
                }, Sizzle.matches = function (expr, elements) {
                    return Sizzle(expr, null, null, elements)
                }, Sizzle.matchesSelector = function (elem, expr) {
                    if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), !(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr))) try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
                    } catch (e) {}
                    return Sizzle(expr, document, null, [elem]).length > 0
                }, Sizzle.contains = function (context, elem) {
                    return (context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
                }, Sizzle.attr = function (elem, name) {
                    (elem.ownerDocument || elem) !== document && setDocument(elem);
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                    return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }, Sizzle.error = function (msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg)
                }, Sizzle.uniqueSort = function (results) {
                    var elem, duplicates = [],
                        j = 0,
                        i = 0;
                    if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                        for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
                        for (; j--;) results.splice(duplicates[j], 1)
                    }
                    return sortInput = null, results
                }, getText = Sizzle.getText = function (elem) {
                    var node, ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
                    if (nodeType) {
                        if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                            if ("string" == typeof elem.textContent) return elem.textContent;
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
                        } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
                    } else
                        for (; node = elem[i++];) ret += getText(node);
                    return ret
                }, Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function (match) {
                            return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                        },
                        CHILD: function (match) {
                            return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                        },
                        PSEUDO: function (match) {
                            var excess, unquoted = !match[6] && match[2];
                            return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function (nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return "*" === nodeNameSelector ? function () {
                                return !0
                            } : function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                            }
                        },
                        CLASS: function (className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                                return pattern.test("string" == typeof elem.className && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "")
                            })
                        },
                        ATTR: function (name, operator, check) {
                            return function (elem) {
                                var result = Sizzle.attr(elem, name);
                                return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0
                            }
                        },
                        CHILD: function (type, what, argument, first, last) {
                            var simple = "nth" !== type.slice(0, 3),
                                forward = "last" !== type.slice(-4),
                                ofType = "of-type" === what;
                            return 1 === first && 0 === last ? function (elem) {
                                return !!elem.parentNode
                            } : function (elem, context, xml) {
                                var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType;
                                if (parent) {
                                    if (simple) {
                                        for (; dir;) {
                                            for (node = elem; node = node[dir];)
                                                if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                            start = dir = "only" === type && !start && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                        for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                                            if (1 === node.nodeType && ++diff && node === elem) {
                                                outerCache[type] = [dirruns, nodeIndex, diff];
                                                break
                                            }
                                    } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1];
                                    else
                                        for (;
                                            (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [dirruns, diff]), node !== elem)););
                                    return diff -= last, diff === first || diff % first === 0 && diff / first >= 0
                                }
                            }
                        },
                        PSEUDO: function (pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                for (var idx, matched = fn(seed, argument), i = matched.length; i--;) idx = indexOf.call(seed, matched[i]), seed[idx] = !(matches[idx] = matched[i])
                            }) : function (elem) {
                                return fn(elem, 0, args)
                            }) : fn
                        }
                    },
                    pseudos: {
                        not: markFunction(function (selector) {
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            }) : function (elem, context, xml) {
                                return input[0] = elem, matcher(input, null, xml, results), !results.pop()
                            }
                        }),
                        has: markFunction(function (selector) {
                            return function (elem) {
                                return Sizzle(selector, elem).length > 0
                            }
                        }),
                        contains: markFunction(function (text) {
                            return function (elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                            }
                        }),
                        lang: markFunction(function (lang) {
                            return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(),
                                function (elem) {
                                    var elemLang;
                                    do
                                        if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), elemLang === lang || 0 === elemLang.indexOf(lang + "-");
                                    while ((elem = elem.parentNode) && 1 === elem.nodeType);
                                    return !1
                                }
                        }),
                        target: function (elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id
                        },
                        root: function (elem) {
                            return elem === docElem
                        },
                        focus: function (elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                        },
                        enabled: function (elem) {
                            return elem.disabled === !1
                        },
                        disabled: function (elem) {
                            return elem.disabled === !0
                        },
                        checked: function (elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                        },
                        selected: function (elem) {
                            return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0
                        },
                        empty: function (elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                if (elem.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function (elem) {
                            return !Expr.pseudos.empty(elem)
                        },
                        header: function (elem) {
                            return rheader.test(elem.nodeName)
                        },
                        input: function (elem) {
                            return rinputs.test(elem.nodeName)
                        },
                        button: function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return "input" === name && "button" === elem.type || "button" === name
                        },
                        text: function (elem) {
                            var attr;
                            return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                        },
                        first: createPositionalPseudo(function () {
                            return [0]
                        }),
                        last: createPositionalPseudo(function (matchIndexes, length) {
                            return [length - 1]
                        }),
                        eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                            return [0 > argument ? argument + length : argument]
                        }),
                        even: createPositionalPseudo(function (matchIndexes, length) {
                            for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        odd: createPositionalPseudo(function (matchIndexes, length) {
                            for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                            for (var i = 0 > argument ? argument + length : argument; --i >= 0;) matchIndexes.push(i);
                            return matchIndexes
                        }),
                        gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                            for (var i = 0 > argument ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                            return matchIndexes
                        })
                    }
                }, Expr.pseudos.nth = Expr.pseudos.eq;
                for (i in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) Expr.pseudos[i] = createInputPseudo(i);
                for (i in {
                    submit: !0,
                    reset: !0
                }) Expr.pseudos[i] = createButtonPseudo(i);
                return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                    if (cached) return parseOnly ? 0 : cached.slice(0);
                    for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                        (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        }), soFar = soFar.slice(matched.length));
                        for (type in Expr.filter)!(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        }), soFar = soFar.slice(matched.length));
                        if (!matched) break
                    }
                    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
                }, compile = Sizzle.compile = function (selector, match) {
                    var i, setMatchers = [],
                        elementMatchers = [],
                        cached = compilerCache[selector + " "];
                    if (!cached) {
                        for (match || (match = tokenize(selector)), i = match.length; i--;) cached = matcherFromTokens(match[i]), cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), cached.selector = selector
                    }
                    return cached
                }, select = Sizzle.select = function (selector, context, results, seed) {
                    var i, tokens, token, type, find, compiled = "function" == typeof selector && selector,
                        match = !seed && tokenize(selector = compiled.selector || selector);
                    if (results = results || [], 1 === match.length) {
                        if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                            if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], !context) return results;
                            compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                        }
                        for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
                            if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                                if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), results;
                                break
                            }
                    }
                    return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), results
                }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function (div1) {
                    return 1 & div1.compareDocumentPosition(document.createElement("div"))
                }), assert(function (div) {
                    return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href")
                }) || addHandle("type|href|height|width", function (elem, name, isXML) {
                    return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
                }), support.attributes && assert(function (div) {
                    return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value")
                }) || addHandle("value", function (elem, name, isXML) {
                    return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue
                }), assert(function (div) {
                    return null == div.getAttribute("disabled")
                }) || addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }), Sizzle
            }(window);
        jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains;
        var rneedsContext = jQuery.expr.match.needsContext,
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
            risSimple = /^.[^:#\[\.,]*$/;
        jQuery.filter = function (expr, elems, not) {
            var elem = elems[0];
            return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                return 1 === elem.nodeType
            }))
        }, jQuery.fn.extend({
            find: function (selector) {
                var i, len = this.length,
                    ret = [],
                    self = this;
                if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; len > i; i++)
                        if (jQuery.contains(self[i], this)) return !0
                }));
                for (i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
                return ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret), ret.selector = this.selector ? this.selector + " " + selector : selector, ret
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], !1))
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], !0))
            },
            is: function (selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
            init = jQuery.fn.init = function (selector, context) {
                var match, elem;
                if (!selector) return this;
                if ("string" == typeof selector) {
                    if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector), !match || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
                    if (match[1]) {
                        if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                            for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                        return this
                    }
                    return elem = document.getElementById(match[2]), elem && elem.parentNode && (this.length = 1, this[0] = elem), this.context = document, this.selector = selector, this
                }
                return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? "undefined" != typeof rootjQuery.ready ? rootjQuery.ready(selector) : selector(jQuery) : (void 0 !== selector.selector && (this.selector = selector.selector, this.context = selector.context), jQuery.makeArray(selector, this))
            };
        init.prototype = jQuery.fn, rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            guaranteedUnique = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
        jQuery.extend({
            dir: function (elem, dir, until) {
                for (var matched = [], truncate = void 0 !== until;
                    (elem = elem[dir]) && 9 !== elem.nodeType;)
                    if (1 === elem.nodeType) {
                        if (truncate && jQuery(elem).is(until)) break;
                        matched.push(elem)
                    }
                return matched
            },
            sibling: function (n, elem) {
                for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
                return matched
            }
        }), jQuery.fn.extend({
            has: function (target) {
                var targets = jQuery(target, this),
                    l = targets.length;
                return this.filter(function () {
                    for (var i = 0; l > i; i++)
                        if (jQuery.contains(this, targets[i])) return !0
                })
            },
            closest: function (selectors, context) {
                for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; l > i; i++)
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break
                        }
                return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
            },
            index: function (elem) {
                return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function (selector, context) {
                return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))))
            },
            addBack: function (selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
            }
        }), jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            },
            parents: function (elem) {
                return jQuery.dir(elem, "parentNode")
            },
            parentsUntil: function (elem, i, until) {
                return jQuery.dir(elem, "parentNode", until)
            },
            next: function (elem) {
                return sibling(elem, "nextSibling")
            },
            prev: function (elem) {
                return sibling(elem, "previousSibling")
            },
            nextAll: function (elem) {
                return jQuery.dir(elem, "nextSibling")
            },
            prevAll: function (elem) {
                return jQuery.dir(elem, "previousSibling")
            },
            nextUntil: function (elem, i, until) {
                return jQuery.dir(elem, "nextSibling", until)
            },
            prevUntil: function (elem, i, until) {
                return jQuery.dir(elem, "previousSibling", until)
            },
            siblings: function (elem) {
                return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
            },
            children: function (elem) {
                return jQuery.sibling(elem.firstChild)
            },
            contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes)
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until);
                return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), this.length > 1 && (guaranteedUnique[name] || jQuery.unique(matched), rparentsprev.test(name) && matched.reverse()), this.pushStack(matched)
            }
        });
        var rnotwhite = /\S+/g,
            optionsCache = {};
        jQuery.Callbacks = function (options) {
            options = "string" == typeof options ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
            var memory, fired, firing, firingStart, firingLength, firingIndex, list = [],
                stack = !options.once && [],
                fire = function (data) {
                    for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++)
                        if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
                            memory = !1;
                            break
                        }
                    firing = !1, list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable())
                },
                self = {
                    add: function () {
                        if (list) {
                            var start = list.length;
                            ! function add(args) {
                                jQuery.each(args, function (_, arg) {
                                    var type = jQuery.type(arg);
                                    "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && add(arg)
                                })
                            }(arguments), firing ? firingLength = list.length : memory && (firingStart = start, fire(memory))
                        }
                        return this
                    },
                    remove: function () {
                        return list && jQuery.each(arguments, function (_, arg) {
                            for (var index;
                                (index = jQuery.inArray(arg, list, index)) > -1;) list.splice(index, 1), firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--)
                        }), this
                    },
                    has: function (fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length)
                    },
                    empty: function () {
                        return list = [], firingLength = 0, this
                    },
                    disable: function () {
                        return list = stack = memory = void 0, this
                    },
                    disabled: function () {
                        return !list
                    },
                    lock: function () {
                        return stack = void 0, memory || self.disable(), this
                    },
                    locked: function () {
                        return !stack
                    },
                    fireWith: function (context, args) {
                        return !list || fired && !stack || (args = args || [], args = [context, args.slice ? args.slice() : args], firing ? stack.push(args) : fire(args)), this
                    },
                    fire: function () {
                        return self.fireWith(this, arguments), this
                    },
                    fired: function () {
                        return !!fired
                    }
                };
            return self
        }, jQuery.extend({
            Deferred: function (func) {
                var tuples = [
                        ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", jQuery.Callbacks("memory")]
                    ],
                    state = "pending",
                    promise = {
                        state: function () {
                            return state
                        },
                        always: function () {
                            return deferred.done(arguments).fail(arguments), this
                        },
                        then: function () {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                                    })
                                }), fns = null
                            }).promise()
                        },
                        promise: function (obj) {
                            return null != obj ? jQuery.extend(obj, promise) : promise
                        }
                    },
                    deferred = {};
                return promise.pipe = promise.then, jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2],
                        stateString = tuple[3];
                    promise[tuple[1]] = list.add, stateString && list.add(function () {
                        state = stateString
                    }, tuples[1 ^ i][2].disable, tuples[2][2].lock), deferred[tuple[0]] = function () {
                        return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments), this
                    }, deferred[tuple[0] + "With"] = list.fireWith
                }), promise.promise(deferred), func && func.call(deferred, deferred), deferred
            },
            when: function (subordinate) {
                var progressValues, progressContexts, resolveContexts, i = 0,
                    resolveValues = slice.call(arguments),
                    length = resolveValues.length,
                    remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                    deferred = 1 === remaining ? subordinate : jQuery.Deferred(),
                    updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) : value, values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values)
                        }
                    };
                if (length > 1)
                    for (progressValues = new Array(length), progressContexts = new Array(length), resolveContexts = new Array(length); length > i; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
                return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise()
            }
        });
        var readyList;
        jQuery.fn.ready = function (fn) {
            return jQuery.ready.promise().done(fn), this
        }, jQuery.extend({
            isReady: !1,
            readyWait: 1,
            holdReady: function (hold) {
                hold ? jQuery.readyWait++ : jQuery.ready(!0)
            },
            ready: function (wait) {
                (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [jQuery]), jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready"))))
            }
        }), jQuery.ready.promise = function (obj) {
            return readyList || (readyList = jQuery.Deferred(), "complete" === document.readyState ? setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed, !1), window.addEventListener("load", completed, !1))), readyList.promise(obj)
        }, jQuery.ready.promise();
        var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0,
                len = elems.length,
                bulk = null == key;
            if ("object" === jQuery.type(key)) {
                chainable = !0;
                for (i in key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw)
            } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function (elem, key, value) {
                return bulk.call(jQuery(elem), value)
            })), fn))
                for (; len > i; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
        };
        jQuery.acceptData = function (owner) {
            return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
        }, Data.uid = 1, Data.accepts = jQuery.acceptData, Data.prototype = {
            key: function (owner) {
                if (!Data.accepts(owner)) return 0;
                var descriptor = {},
                    unlock = owner[this.expando];
                if (!unlock) {
                    unlock = Data.uid++;
                    try {
                        descriptor[this.expando] = {
                            value: unlock
                        }, Object.defineProperties(owner, descriptor)
                    } catch (e) {
                        descriptor[this.expando] = unlock, jQuery.extend(owner, descriptor)
                    }
                }
                return this.cache[unlock] || (this.cache[unlock] = {}), unlock
            },
            set: function (owner, data, value) {
                var prop, unlock = this.key(owner),
                    cache = this.cache[unlock];
                if ("string" == typeof data) cache[data] = value;
                else if (jQuery.isEmptyObject(cache)) jQuery.extend(this.cache[unlock], data);
                else
                    for (prop in data) cache[prop] = data[prop];
                return cache
            },
            get: function (owner, key) {
                var cache = this.cache[this.key(owner)];
                return void 0 === key ? cache : cache[key]
            },
            access: function (owner, key, value) {
                var stored;
                return void 0 === key || key && "string" == typeof key && void 0 === value ? (stored = this.get(owner, key), void 0 !== stored ? stored : this.get(owner, jQuery.camelCase(key))) : (this.set(owner, key, value), void 0 !== value ? value : key)
            },
            remove: function (owner, key) {
                var i, name, camel, unlock = this.key(owner),
                    cache = this.cache[unlock];
                if (void 0 === key) this.cache[unlock] = {};
                else {
                    jQuery.isArray(key) ? name = key.concat(key.map(jQuery.camelCase)) : (camel = jQuery.camelCase(key), key in cache ? name = [key, camel] : (name = camel, name = name in cache ? [name] : name.match(rnotwhite) || [])), i = name.length;
                    for (; i--;) delete cache[name[i]]
                }
            },
            hasData: function (owner) {
                return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
            },
            discard: function (owner) {
                owner[this.expando] && delete this.cache[owner[this.expando]]
            }
        };
        var data_priv = new Data,
            data_user = new Data,
            rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /([A-Z])/g;
        jQuery.extend({
            hasData: function (elem) {
                return data_user.hasData(elem) || data_priv.hasData(elem)
            },
            data: function (elem, name, data) {
                return data_user.access(elem, name, data)
            },
            removeData: function (elem, name) {
                data_user.remove(elem, name)
            },
            _data: function (elem, name, data) {
                return data_priv.access(elem, name, data)
            },
            _removeData: function (elem, name) {
                data_priv.remove(elem, name)
            }
        }), jQuery.fn.extend({
            data: function (key, value) {
                var i, name, data, elem = this[0],
                    attrs = elem && elem.attributes;
                if (void 0 === key) {
                    if (this.length && (data = data_user.get(elem), 1 === elem.nodeType && !data_priv.get(elem, "hasDataAttrs"))) {
                        for (i = attrs.length; i--;) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), dataAttr(elem, name, data[name])));
                        data_priv.set(elem, "hasDataAttrs", !0)
                    }
                    return data
                }
                return "object" == typeof key ? this.each(function () {
                    data_user.set(this, key)
                }) : access(this, function (value) {
                    var data, camelKey = jQuery.camelCase(key);
                    if (elem && void 0 === value) {
                        if (data = data_user.get(elem, key), void 0 !== data) return data;
                        if (data = data_user.get(elem, camelKey), void 0 !== data) return data;
                        if (data = dataAttr(elem, camelKey, void 0), void 0 !== data) return data
                    } else this.each(function () {
                        var data = data_user.get(this, camelKey);
                        data_user.set(this, camelKey, value), -1 !== key.indexOf("-") && void 0 !== data && data_user.set(this, key, value)
                    })
                }, null, value, arguments.length > 1, null, !0)
            },
            removeData: function (key) {
                return this.each(function () {
                    data_user.remove(this, key)
                })
            }
        }), jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                return elem ? (type = (type || "fx") + "queue", queue = data_priv.get(elem, type), data && (!queue || jQuery.isArray(data) ? queue = data_priv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []) : void 0
            },
            dequeue: function (elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks(elem, type),
                    next = function () {
                        jQuery.dequeue(elem, type)
                    };
                "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire()
            },
            _queueHooks: function (elem, type) {
                var key = type + "queueHooks";
                return data_priv.get(elem, key) || data_priv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function () {
                        data_priv.remove(elem, [type + "queue", key])
                    })
                })
            }
        }), jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function () {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                })
            },
            dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type)
                })
            },
            clearQueue: function (type) {
                return this.queue(type || "fx", [])
            },
            promise: function (type, obj) {
                var tmp, count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function () {
                        --count || defer.resolveWith(elements, [elements])
                    };
                for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--;) tmp = data_priv.get(elements[i], type + "queueHooks"), tmp && tmp.empty && (count++, tmp.empty.add(resolve));
                return resolve(), defer.promise(obj)
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            cssExpand = ["Top", "Right", "Bottom", "Left"],
            isHidden = function (elem, el) {
                return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem)
            },
            rcheckableType = /^(?:checkbox|radio)$/i;
        ! function () {
            var fragment = document.createDocumentFragment(),
                div = fragment.appendChild(document.createElement("div")),
                input = document.createElement("input");
            input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue
        }();
        var strundefined = "undefined";
        support.focusinBubbles = "onfocusin" in window;
        var rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
            rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
        jQuery.event = {
            global: {},
            add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
                if (elemData)
                    for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function (e) {
                        return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                    }), types = (types || "").match(rnotwhite) || [""], t = types.length; t--;) tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join(".")
                    }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle, !1)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0)
            },
            remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
                if (elemData && (events = elemData.events)) {
                    for (types = (types || "").match(rnotwhite) || [""], t = types.length; t--;)
                        if (tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                            for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                            origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                        } else
                            for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && (delete elemData.handle, data_priv.remove(elem, "events"))
                }
            },
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                    type = hasOwn.call(event, "type") ? event.type : event,
                    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                    }
                    for (i = 0;
                        (cur = eventPath[i++]) && !event.isPropagationStopped();) event.type = i > 1 ? bubbleType : special.bindType || type, handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle"), handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), event.result === !1 && event.preventDefault());
                    return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !jQuery.acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result
                }
            },
            dispatch: function (event) {
                event = jQuery.event.fix(event);
                var i, j, ret, matched, handleObj, handlerQueue = [],
                    args = slice.call(arguments),
                    handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                    special = jQuery.event.special[event.type] || {};
                if (args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0;
                        (matched = handlerQueue[i++]) && !event.isPropagationStopped();)
                        for (event.currentTarget = matched.elem, j = 0;
                            (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();)(!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event), event.result
                }
            },
            handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;
                if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type))
                    for (; cur !== this; cur = cur.parentNode || this)
                        if (cur.disabled !== !0 || "click" !== event.type) {
                            for (matches = [], i = 0; delegateCount > i; i++) handleObj = handlers[i], sel = handleObj.selector + " ", void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length), matches[sel] && matches.push(handleObj);
                            matches.length && handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            })
                        }
                return delegateCount < handlers.length && handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                }), handlerQueue
            },
            props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
            fixHooks: {},
            keyHooks: {
                props: "char charCode key keyCode".split(" "),
                filter: function (event, original) {
                    return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode), event
                }
            },
            mouseHooks: {
                props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                filter: function (event, original) {
                    var eventDoc, doc, body, button = original.button;
                    return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), event.which || void 0 === button || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), event
                }
            },
            fix: function (event) {
                if (event[jQuery.expando]) return event;
                var i, prop, copy, type = event.type,
                    originalEvent = event,
                    fixHook = this.fixHooks[type];
                for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}), copy = fixHook.props ? this.props.concat(fixHook.props) : this.props, event = new jQuery.Event(originalEvent), i = copy.length; i--;) prop = copy[i], event[prop] = originalEvent[prop];
                return event.target || (event.target = document), 3 === event.target.nodeType && (event.target = event.target.parentNode), fixHook.filter ? fixHook.filter(event, originalEvent) : event
            },
            special: {
                load: {
                    noBubble: !0
                },
                focus: {
                    trigger: function () {
                        return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0
                    },
                    delegateType: "focusin"
                },
                blur: {
                    trigger: function () {
                        return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0
                    },
                    delegateType: "focusout"
                },
                click: {
                    trigger: function () {
                        return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), !1) : void 0
                    },
                    _default: function (event) {
                        return jQuery.nodeName(event.target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function (event) {
                        void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                    }
                }
            },
            simulate: function (type, elem, event, bubble) {
                var e = jQuery.extend(new jQuery.Event, event, {
                    type: type,
                    isSimulated: !0,
                    originalEvent: {}
                });
                bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e), e.isDefaultPrevented() && event.preventDefault()
            }
        }, jQuery.removeEvent = function (elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle, !1)
        }, jQuery.Event = function (src, props) {
            return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), void(this[jQuery.expando] = !0)) : new jQuery.Event(src, props)
        }, jQuery.Event.prototype = {
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue, e && e.preventDefault && e.preventDefault()
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue, e && e.stopPropagation && e.stopPropagation()
            },
            stopImmediatePropagation: function () {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function (event) {
                    var ret, target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;
                    return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
                }
            }
        }), support.focusinBubbles || jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0)
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix);
                    attaches || doc.addEventListener(orig, handler, !0), data_priv.access(doc, fix, (attaches || 0) + 1)
                },
                teardown: function () {
                    var doc = this.ownerDocument || this,
                        attaches = data_priv.access(doc, fix) - 1;
                    attaches ? data_priv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), data_priv.remove(doc, fix))
                }
            }
        }), jQuery.fn.extend({
            on: function (types, selector, data, fn, one) {
                var origFn, type;
                if ("object" == typeof types) {
                    "string" != typeof selector && (data = data || selector, selector = void 0);
                    for (type in types) this.on(type, selector, data, types[type], one);
                    return this
                }
                if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse;
                else if (!fn) return this;
                return 1 === one && (origFn = fn, fn = function (event) {
                    return jQuery().off(event), origFn.apply(this, arguments)
                }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function () {
                    jQuery.event.add(this, types, fn, data, selector)
                })
            },
            one: function (types, selector, data, fn) {
                return this.on(types, selector, data, fn, 1)
            },
            off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
                if ("object" == typeof types) {
                    for (type in types) this.off(type, selector, types[type]);
                    return this
                }
                return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), fn === !1 && (fn = returnFalse), this.each(function () {
                    jQuery.event.remove(this, types, fn, selector)
                })
            },
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this)
                })
            },
            triggerHandler: function (type, data) {
                var elem = this[0];
                return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0
            }
        });
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            rtagName = /<([\w:]+)/,
            rhtml = /<|&#?\w+;/,
            rnoInnerhtml = /<(?:script|style|link)/i,
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rscriptType = /^$|\/(?:java|ecma)script/i,
            rscriptTypeMasked = /^true\/(.*)/,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
            wrapMap = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td, jQuery.extend({
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(!0),
                    inPage = jQuery.contains(elem.ownerDocument, elem);
                if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                    for (destElements = getAll(clone), srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++) fixInput(srcElements[i], destElements[i]);
                if (dataAndEvents)
                    if (deepDataAndEvents)
                        for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++) cloneCopyEvent(srcElements[i], destElements[i]);
                    else cloneCopyEvent(elem, clone);
                return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), clone
            },
            buildFragment: function (elems, context, scripts, selection) {
                for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++)
                    if (elem = elems[i], elem || 0 === elem)
                        if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                        else if (rhtml.test(elem)) {
                    for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], j = wrap[0]; j--;) tmp = tmp.lastChild;
                    jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
                } else nodes.push(context.createTextNode(elem));
                for (fragment.textContent = "", i = 0; elem = nodes[i++];)
                    if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts))
                        for (j = 0; elem = tmp[j++];) rscriptType.test(elem.type || "") && scripts.push(elem);
                return fragment
            },
            cleanData: function (elems) {
                for (var data, elem, type, key, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) {
                    if (jQuery.acceptData(elem) && (key = elem[data_priv.expando], key && (data = data_priv.cache[key]))) {
                        if (data.events)
                            for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        data_priv.cache[key] && delete data_priv.cache[key]
                    }
                    delete data_user.cache[elem[data_user.expando]]
                }
            }
        }), jQuery.fn.extend({
            text: function (value) {
                return access(this, function (value) {
                    return void 0 === value ? jQuery.text(this) : this.empty().each(function () {
                        (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value)
                    })
                }, null, value, arguments.length)
            },
            append: function () {
                return this.domManip(arguments, function (elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem)
                    }
                })
            },
            prepend: function () {
                return this.domManip(arguments, function (elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild)
                    }
                })
            },
            before: function () {
                return this.domManip(arguments, function (elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this)
                })
            },
            after: function () {
                return this.domManip(arguments, function (elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                })
            },
            remove: function (selector, keepData) {
                for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), elem.parentNode.removeChild(elem));
                return this
            },
            empty: function () {
                for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
                return this
            },
            clone: function (dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map(function () {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                })
            },
            html: function (value) {
                return access(this, function (value) {
                    var elem = this[0] || {},
                        i = 0,
                        l = this.length;
                    if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                    if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                        value = value.replace(rxhtmlTag, "<$1></$2>");
                        try {
                            for (; l > i; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                            elem = 0
                        } catch (e) {}
                    }
                    elem && this.empty().append(value)
                }, null, value, arguments.length)
            },
            replaceWith: function () {
                var arg = arguments[0];
                return this.domManip(arguments, function (elem) {
                    arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this)
                }), arg && (arg.length || arg.nodeType) ? this : this.remove()
            },
            detach: function (selector) {
                return this.remove(selector, !0)
            },
            domManip: function (args, callback) {
                args = concat.apply([], args);
                var fragment, first, scripts, hasScripts, node, doc, i = 0,
                    l = this.length,
                    set = this,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction(value);
                if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return this.each(function (index) {
                    var self = set.eq(index);
                    isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback)
                });
                if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this), first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), first)) {
                    for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(this[i], node, i);
                    if (hasScripts)
                        for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; hasScripts > i; i++) node = scripts[i], rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : jQuery.globalEval(node.textContent.replace(rcleanScript, "")))
                }
                return this
            }
        }), jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function (name, original) {
            jQuery.fn[name] = function (selector) {
                for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++) elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
                return this.pushStack(ret)
            }
        });
        var iframe, elemdisplay = {},
            rmargin = /^margin/,
            rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"),
            getStyles = function (elem) {
                return elem.ownerDocument.defaultView.getComputedStyle(elem, null)
            };
        ! function () {
            function computePixelPositionAndBoxSizingReliable() {
                div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", div.innerHTML = "", docElem.appendChild(container);
                var divStyle = window.getComputedStyle(div, null);
                pixelPositionVal = "1%" !== divStyle.top, boxSizingReliableVal = "4px" === divStyle.width, docElem.removeChild(container)
            }
            var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement,
                container = document.createElement("div"),
                div = document.createElement("div");
            div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", container.appendChild(div), window.getComputedStyle && jQuery.extend(support, {
                pixelPosition: function () {
                    return computePixelPositionAndBoxSizingReliable(), pixelPositionVal
                },
                boxSizingReliable: function () {
                    return null == boxSizingReliableVal && computePixelPositionAndBoxSizingReliable(), boxSizingReliableVal
                },
                reliableMarginRight: function () {
                    var ret, marginDiv = div.appendChild(document.createElement("div"));
                    return marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", marginDiv.style.marginRight = marginDiv.style.width = "0", div.style.width = "1px", docElem.appendChild(container), ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight), docElem.removeChild(container), ret
                }
            }))
        }(), jQuery.swap = function (elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
            ret = callback.apply(elem, args || []);
            for (name in options) elem.style[name] = old[name];
            return ret
        };
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
            rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
            cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            },
            cssPrefixes = ["Webkit", "O", "Moz", "ms"];
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret
                        }
                    }
                }
            },
            cssNumber: {
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {
                "float": "cssFloat"
            },
            style: function (elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = jQuery.camelCase(name),
                        style = elem.style;
                    return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, "string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), type = "number"), null != value && value === value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), void 0)
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 : val) : val
            }
        }), jQuery.each(["height", "width"], function (i, name) {
            jQuery.cssHooks[name] = {
                get: function (elem, computed, extra) {
                    return computed ? rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra)
                    }) : getWidthOrHeight(elem, name, extra) : void 0
                },
                set: function (elem, value, extra) {
                    var styles = extra && getStyles(elem);
                    return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0)
                }
            }
        }), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
            return computed ? jQuery.swap(elem, {
                display: "inline-block"
            }, curCSS, [elem, "marginRight"]) : void 0
        }), jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    return expanded
                }
            }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
        }), jQuery.fn.extend({
            css: function (name, value) {
                return access(this, function (elem, name, value) {
                    var styles, len, map = {},
                        i = 0;
                    if (jQuery.isArray(name)) {
                        for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                        return map
                    }
                    return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                }, name, value, arguments.length > 1)
            },
            show: function () {
                return showHide(this, !0)
            },
            hide: function () {
                return showHide(this)
            },
            toggle: function (state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function () {
                    isHidden(this) ? jQuery(this).show() : jQuery(this).hide()
                })
            }
        }), jQuery.Tween = Tween, Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.pos = eased = this.options.duration ? jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
            }
        }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), result && "auto" !== result ? result : 0) : tween.elem[tween.prop]
                },
                set: function (tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now
                }
            }
        }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
            }
        }, jQuery.easing = {
            linear: function (p) {
                return p
            },
            swing: function (p) {
                return .5 - Math.cos(p * Math.PI) / 2
            }
        }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
            rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
            rrun = /queueHooks$/,
            animationPrefilters = [defaultPrefilter],
            tweeners = {
                "*": [
                    function (prop, value) {
                        var tween = this.createTween(prop, value),
                            target = tween.cur(),
                            parts = rfxnum.exec(value),
                            unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                            start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                            scale = 1,
                            maxIterations = 20;
                        if (start && start[3] !== unit) {
                            unit = unit || start[3], parts = parts || [], start = +target || 1;
                            do scale = scale || ".5", start /= scale, jQuery.style(tween.elem, prop, start + unit); while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations)
                        }
                        return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]), tween
                    }
                ]
            };
        jQuery.Animation = jQuery.extend(Animation, {
                tweener: function (props, callback) {
                    jQuery.isFunction(props) ? (callback = props, props = ["*"]) : props = props.split(" ");
                    for (var prop, index = 0, length = props.length; length > index; index++) prop = props[index], tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback)
                },
                prefilter: function (callback, prepend) {
                    prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback)
                }
            }), jQuery.speed = function (speed, easing, fn) {
                var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
                return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function () {
                    jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
                }, opt
            }, jQuery.fn.extend({
                fadeTo: function (speed, to, easing, callback) {
                    return this.filter(isHidden).css("opacity", 0).show().end().animate({
                        opacity: to
                    }, speed, easing, callback)
                },
                animate: function (prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function () {
                            var anim = Animation(this, jQuery.extend({}, prop), optall);
                            (empty || data_priv.get(this, "finish")) && anim.stop(!0)
                        };
                    return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
                },
                stop: function (type, clearQueue, gotoEnd) {
                    var stopQueue = function (hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop, stop(gotoEnd)
                    };
                    return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function () {
                        var dequeue = !0,
                            index = null != type && type + "queueHooks",
                            timers = jQuery.timers,
                            data = data_priv.get(this);
                        if (index) data[index] && data[index].stop && stopQueue(data[index]);
                        else
                            for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                        for (index = timers.length; index--;) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                        (dequeue || !gotoEnd) && jQuery.dequeue(this, type)
                    })
                },
                finish: function (type) {
                    return type !== !1 && (type = type || "fx"), this.each(function () {
                        var index, data = data_priv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;
                        for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                        for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                        delete data.finish
                    })
                }
            }), jQuery.each(["toggle", "show", "hide"], function (i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function (speed, easing, callback) {
                    return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
                }
            }), jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function (name, props) {
                jQuery.fn[name] = function (speed, easing, callback) {
                    return this.animate(props, speed, easing, callback)
                }
            }), jQuery.timers = [], jQuery.fx.tick = function () {
                var timer, i = 0,
                    timers = jQuery.timers;
                for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
                timers.length || jQuery.fx.stop(), fxNow = void 0
            }, jQuery.fx.timer = function (timer) {
                jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop()
            }, jQuery.fx.interval = 13, jQuery.fx.start = function () {
                timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval))
            }, jQuery.fx.stop = function () {
                clearInterval(timerId), timerId = null
            }, jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, jQuery.fn.delay = function (time, type) {
                return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", this.queue(type, function (next, hooks) {
                    var timeout = setTimeout(next, time);
                    hooks.stop = function () {
                        clearTimeout(timeout)
                    }
                })
            },
            function () {
                var input = document.createElement("input"),
                    select = document.createElement("select"),
                    opt = select.appendChild(document.createElement("option"));
                input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), input.value = "t", input.type = "radio", support.radioValue = "t" === input.value
            }();
        var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function (name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1)
            },
            removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name)
                })
            }
        }), jQuery.extend({
            attr: function (elem, name, value) {
                var hooks, ret, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), void 0 === value ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), null == ret ? void 0 : ret) : null !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : void jQuery.removeAttr(elem, name))
            },
            removeAttr: function (elem, value) {
                var name, propName, i = 0,
                    attrNames = value && value.match(rnotwhite);
                if (attrNames && 1 === elem.nodeType)
                    for (; name = attrNames[i++];) propName = jQuery.propFix[name] || name, jQuery.expr.match.bool.test(name) && (elem[propName] = !1), elem.removeAttribute(name)
            },
            attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value), val && (elem.value = val), value
                        }
                    }
                }
            }
        }), boolHook = {
            set: function (elem, value, name) {
                return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), name
            }
        }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function (elem, name, isXML) {
                var ret, handle;
                return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() : null, attrHandle[name] = handle), ret
            }
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i;
        jQuery.fn.extend({
            prop: function (name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1)
            },
            removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name]
                })
            }
        }), jQuery.extend({
            propFix: {
                "for": "htmlFor",
                "class": "className"
            },
            prop: function (elem, name, value) {
                var ret, hooks, notxml, nType = elem.nodeType;
                if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return notxml = 1 !== nType || !jQuery.isXMLDoc(elem), notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
            },
            propHooks: {
                tabIndex: {
                    get: function (elem) {
                        return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
                    }
                }
            }
        }), support.optSelected || (jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.parentNode && parent.parentNode.selectedIndex, null
            }
        }), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
            jQuery.propFix[this.toLowerCase()] = this
        });
        var rclass = /[\t\r\n\f]/g;
        jQuery.fn.extend({
            addClass: function (value) {
                var classes, elem, cur, clazz, j, finalValue, proceed = "string" == typeof value && value,
                    i = 0,
                    len = this.length;
                if (jQuery.isFunction(value)) return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(rnotwhite) || []; len > i; i++)
                        if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                            for (j = 0; clazz = classes[j++];) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                            finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue)
                        }
                return this
            },
            removeClass: function (value) {
                var classes, elem, cur, clazz, j, finalValue, proceed = 0 === arguments.length || "string" == typeof value && value,
                    i = 0,
                    len = this.length;
                if (jQuery.isFunction(value)) return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                });
                if (proceed)
                    for (classes = (value || "").match(rnotwhite) || []; len > i; i++)
                        if (elem = this[i], cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                            for (j = 0; clazz = classes[j++];)
                                for (; cur.indexOf(" " + clazz + " ") >= 0;) cur = cur.replace(" " + clazz + " ", " ");
                            finalValue = value ? jQuery.trim(cur) : "", elem.className !== finalValue && (elem.className = finalValue)
                        }
                return this
            },
            toggleClass: function (value, stateVal) {
                var type = typeof value;
                return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : this.each(jQuery.isFunction(value) ? function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
                } : function () {
                    if ("string" === type)
                        for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++];) self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                    else(type === strundefined || "boolean" === type) && (this.className && data_priv.set(this, "__className__", this.className), this.className = this.className || value === !1 ? "" : data_priv.get(this, "__className__") || "")
                })
            },
            hasClass: function (selector) {
                for (var className = " " + selector + " ", i = 0, l = this.length; l > i; i++)
                    if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
                return !1
            }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0]; {
                    if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function (i) {
                        var val;
                        1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function (value) {
                            return null == value ? "" : value + ""
                        })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                    });
                    if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)
                }
            }
        }), jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return null != val ? val : jQuery.trim(jQuery.text(elem))
                    }
                },
                select: {
                    get: function (elem) {
                        for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || 0 > index, values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++)
                            if (option = options[i], !(!option.selected && i !== index || (support.optDisabled ? option.disabled : null !== option.getAttribute("disabled")) || option.parentNode.disabled && jQuery.nodeName(option.parentNode, "optgroup"))) {
                                if (value = jQuery(option).val(), one) return value;
                                values.push(value)
                            }
                        return values
                    },
                    set: function (elem, value) {
                        for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--;) option = options[i], (option.selected = jQuery.inArray(option.value, values) >= 0) && (optionSet = !0);
                        return optionSet || (elem.selectedIndex = -1), values
                    }
                }
            }
        }), jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                set: function (elem, value) {
                    return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 : void 0
                }
            }, support.checkOn || (jQuery.valHooks[this].get = function (elem) {
                return null === elem.getAttribute("value") ? "on" : elem.value
            })
        }), jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (i, name) {
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
            }
        }), jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            },
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn)
            },
            unbind: function (types, fn) {
                return this.off(types, null, fn)
            },
            delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn)
            },
            undelegate: function (selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
            }
        });
        var nonce = jQuery.now(),
            rquery = /\?/;
        jQuery.parseJSON = function (data) {
            return JSON.parse(data + "")
        }, jQuery.parseXML = function (data) {
            var xml, tmp;
            if (!data || "string" != typeof data) return null;
            try {
                tmp = new DOMParser, xml = tmp.parseFromString(data, "text/xml")
            } catch (e) {
                xml = void 0
            }
            return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), xml
        };
        var ajaxLocParts, ajaxLocation, rhash = /#.*$/,
            rts = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
            prefilters = {},
            transports = {},
            allTypes = "*/".concat("*");
        try {
            ajaxLocation = location.href
        } catch (e) {
            ajaxLocation = document.createElement("a"), ajaxLocation.href = "", ajaxLocation = ajaxLocation.href
        }
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ajaxLocation,
                type: "GET",
                isLocal: rlocalProtocol.test(ajaxLocParts[1]),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /xml/,
                    html: /html/,
                    json: /json/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": jQuery.parseJSON,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
                }
                "object" == typeof url && (options = url, url = void 0), options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    state = 0,
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function (key) {
                            var match;
                            if (2 === state) {
                                if (!responseHeaders)
                                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);) responseHeaders[match[1].toLowerCase()] = match[2];
                                match = responseHeaders[key.toLowerCase()]
                            }
                            return null == match ? null : match
                        },
                        getAllResponseHeaders: function () {
                            return 2 === state ? responseHeadersString : null
                        },
                        setRequestHeader: function (name, value) {
                            var lname = name.toLowerCase();
                            return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, requestHeaders[name] = value), this
                        },
                        overrideMimeType: function (type) {
                            return state || (s.mimeType = type), this
                        },
                        statusCode: function (map) {
                            var code;
                            if (map)
                                if (2 > state)
                                    for (code in map) statusCode[code] = [statusCode[code], map[code]];
                                else jqXHR.always(map[jqXHR.status]);
                            return this
                        },
                        abort: function (statusText) {
                            var finalText = statusText || strAbort;
                            return transport && transport.abort(finalText), done(0, finalText), this
                        }
                    };
                if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""], null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
                fireGlobals = s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++)), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state)) return jqXHR.abort();
                strAbort = "abort";
                for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) jqXHR[i](s[i]);
                if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout")
                    }, s.timeout));
                    try {
                        state = 1, transport.send(requestHeaders, done)
                    } catch (e) {
                        if (!(2 > state)) throw e;
                        done(-1, e)
                    }
                } else done(-1, "No Transport");
                return jqXHR
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, "json")
            },
            getScript: function (url, callback) {
                return jQuery.get(url, void 0, callback, "script")
            }
        }), jQuery.each(["get", "post"], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
                return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                })
            }
        }), jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
            jQuery.fn[type] = function (fn) {
                return this.on(type, fn)
            }
        }), jQuery._evalUrl = function (url) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }, jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                return jQuery.isFunction(html) ? this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i))
                }) : (this[0] && (wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function () {
                    for (var elem = this; elem.firstElementChild;) elem = elem.firstElementChild;
                    return elem
                }).append(this)), this)
            },
            wrapInner: function (html) {
                return this.each(jQuery.isFunction(html) ? function (i) {
                    jQuery(this).wrapInner(html.call(this, i))
                } : function () {
                    var self = jQuery(this),
                        contents = self.contents();
                    contents.length ? contents.wrapAll(html) : self.append(html)
                })
            },
            wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
                })
            },
            unwrap: function () {
                return this.parent().each(function () {
                    jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes)
                }).end()
            }
        }), jQuery.expr.filters.hidden = function (elem) {
            return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
        }, jQuery.expr.filters.visible = function (elem) {
            return !jQuery.expr.filters.hidden(elem)
        };
        var r20 = /%20/g,
            rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.param = function (a, traditional) {
            var prefix, s = [],
                add = function (key, value) {
                    value = jQuery.isFunction(value) ? value() : null == value ? "" : value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
                };
            if (void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function () {
                add(this.name, this.value)
            });
            else
                for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
            return s.join("&").replace(r20, "+")
        }, jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray())
            },
            serializeArray: function () {
                return this.map(function () {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this
                }).filter(function () {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        }
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
                }).get()
            }
        }), jQuery.ajaxSettings.xhr = function () {
            try {
                return new XMLHttpRequest
            } catch (e) {}
        };
        var xhrId = 0,
            xhrCallbacks = {},
            xhrSuccessStatus = {
                0: 200,
                1223: 204
            },
            xhrSupported = jQuery.ajaxSettings.xhr();
        window.ActiveXObject && jQuery(window).on("unload", function () {
            for (var key in xhrCallbacks) xhrCallbacks[key]()
        }), support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, jQuery.ajaxTransport(function (options) {
            var callback;
            return support.cors || xhrSupported && !options.crossDomain ? {
                send: function (headers, complete) {
                    var i, xhr = options.xhr(),
                        id = ++xhrId;
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
                        for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                    for (i in headers) xhr.setRequestHeader(i, headers[i]);
                    callback = function (type) {
                        return function () {
                            callback && (delete xhrCallbacks[id], callback = xhr.onload = xhr.onerror = null, "abort" === type ? xhr.abort() : "error" === type ? complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "string" == typeof xhr.responseText ? {
                                text: xhr.responseText
                            } : void 0, xhr.getAllResponseHeaders()))
                        }
                    }, xhr.onload = callback(), xhr.onerror = callback("error"), callback = xhrCallbacks[id] = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null)
                    } catch (e) {
                        if (callback) throw e
                    }
                },
                abort: function () {
                    callback && callback()
                }
            } : void 0
        }), jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /(?:java|ecma)script/
            },
            converters: {
                "text script": function (text) {
                    return jQuery.globalEval(text), text
                }
            }
        }), jQuery.ajaxPrefilter("script", function (s) {
            void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET")
        }), jQuery.ajaxTransport("script", function (s) {
            if (s.crossDomain) {
                var script, callback;
                return {
                    send: function (_, complete) {
                        script = jQuery("<script>").prop({
                            async: !0,
                            charset: s.scriptCharset,
                            src: s.url
                        }).on("load error", callback = function (evt) {
                            script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type)
                        }), document.head.appendChild(script[0])
                    },
                    abort: function () {
                        callback && callback()
                    }
                }
            }
        });
        var oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                return this[callback] = !0, callback
            }
        }), jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function () {
                return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
            }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function () {
                responseContainer = arguments
            }, jqXHR.always(function () {
                window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
            }), "script") : void 0
        }), jQuery.parseHTML = function (data, context, keepScripts) {
            if (!data || "string" != typeof data) return null;
            "boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
            var parsed = rsingleTag.exec(data),
                scripts = !keepScripts && [];
            return parsed ? [context.createElement(parsed[1])] : (parsed = jQuery.buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes))
        };
        var _load = jQuery.fn.load;
        jQuery.fn.load = function (url, params, callback) {
            if ("string" != typeof url && _load) return _load.apply(this, arguments);
            var selector, type, response, self = this,
                off = url.indexOf(" ");
            return off >= 0 && (selector = jQuery.trim(url.slice(off)), url = url.slice(0, off)), jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), self.length > 0 && jQuery.ajax({
                url: url,
                type: type,
                dataType: "html",
                data: params
            }).done(function (responseText) {
                response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
            }).complete(callback && function (jqXHR, status) {
                self.each(callback, response || [jqXHR.responseText, status, jqXHR])
            }), this
        }, jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem
            }).length
        };
        var docElem = window.document.documentElement;
        jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
                    curElem = jQuery(elem),
                    props = {};
                "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using" in options ? options.using.call(elem, props) : curElem.css(props)
            }
        }, jQuery.fn.extend({
            offset: function (options) {
                if (arguments.length) return void 0 === options ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i)
                });
                var docElem, win, elem = this[0],
                    box = {
                        top: 0,
                        left: 0
                    },
                    doc = elem && elem.ownerDocument;
                if (doc) return docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), win = getWindow(doc), {
                    top: box.top + win.pageYOffset - docElem.clientTop,
                    left: box.left + win.pageXOffset - docElem.clientLeft
                }) : box
            },
            position: function () {
                if (this[0]) {
                    var offsetParent, offset, elem = this[0],
                        parentOffset = {
                            top: 0,
                            left: 0
                        };
                    return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function () {
                return this.map(function () {
                    for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.offsetParent;
                    return offsetParent || docElem
                })
            }
        }), jQuery.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function (method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function (val) {
                return access(this, function (elem, method, val) {
                    var win = getWindow(elem);
                    return void 0 === val ? win ? win[prop] : elem[method] : void(win ? win.scrollTo(top ? window.pageXOffset : val, top ? val : window.pageYOffset) : elem[method] = val)
                }, method, val, arguments.length, null)
            }
        }), jQuery.each(["top", "left"], function (i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
                return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0
            })
        }), jQuery.each({
            Height: "height",
            Width: "width"
        }, function (name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, function (defaultExtra, funcName) {
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin),
                        extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                    return access(this, function (elem, type, value) {
                        var doc;
                        return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                    }, type, chainable ? margin : void 0, chainable, null)
                }
            })
        }), jQuery.fn.size = function () {
            return this.length
        }, jQuery.fn.andSelf = jQuery.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
            return jQuery
        });
        var _jQuery = window.jQuery,
            _$ = window.$;
        return jQuery.noConflict = function (deep) {
            return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
        }, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery
    }),
    /*! jQuery UI - v1.10.3 - 2013-05-03
     * http://jqueryui.com
     * Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
     * Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
    function ($, undefined) {
        function focusable(element, isTabIndexNotNaN) {
            var map, mapName, img, nodeName = element.nodeName.toLowerCase();
            return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap=#" + mapName + "]")[0], !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element)
        }

        function visible(element) {
            return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
                return "hidden" === $.css(this, "visibility")
            }).length
        }
        var uuid = 0,
            runiqueId = /^ui-id-\d+$/;
        $.ui = $.ui || {}, $.extend($.ui, {
            version: "1.10.3",
            keyCode: {
                BACKSPACE: 8,
                COMMA: 188,
                DELETE: 46,
                DOWN: 40,
                END: 35,
                ENTER: 13,
                ESCAPE: 27,
                HOME: 36,
                LEFT: 37,
                NUMPAD_ADD: 107,
                NUMPAD_DECIMAL: 110,
                NUMPAD_DIVIDE: 111,
                NUMPAD_ENTER: 108,
                NUMPAD_MULTIPLY: 106,
                NUMPAD_SUBTRACT: 109,
                PAGE_DOWN: 34,
                PAGE_UP: 33,
                PERIOD: 190,
                RIGHT: 39,
                SPACE: 32,
                TAB: 9,
                UP: 38
            }
        }), $.fn.extend({
            focus: function (orig) {
                return function (delay, fn) {
                    return "number" == typeof delay ? this.each(function () {
                        var elem = this;
                        setTimeout(function () {
                            $(elem).focus(), fn && fn.call(elem)
                        }, delay)
                    }) : orig.apply(this, arguments)
                }
            }($.fn.focus),
            scrollParent: function () {
                var scrollParent;
                return scrollParent = $.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function () {
                    return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"))
                }).eq(0) : this.parents().filter(function () {
                    return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"))
                }).eq(0), /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent
            },
            zIndex: function (zIndex) {
                if (zIndex !== undefined) return this.css("zIndex", zIndex);
                if (this.length)
                    for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document;) {
                        if (position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (value = parseInt(elem.css("zIndex"), 10), !isNaN(value) && 0 !== value)) return value;
                        elem = elem.parent()
                    }
                return 0
            },
            uniqueId: function () {
                return this.each(function () {
                    this.id || (this.id = "ui-id-" + ++uuid)
                })
            },
            removeUniqueId: function () {
                return this.each(function () {
                    runiqueId.test(this.id) && $(this).removeAttr("id")
                })
            }
        }), $.extend($.expr[":"], {
            data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
                return function (elem) {
                    return !!$.data(elem, dataName)
                }
            }) : function (elem, i, match) {
                return !!$.data(elem, match[3])
            },
            focusable: function (element) {
                return focusable(element, !isNaN($.attr(element, "tabindex")))
            },
            tabbable: function (element) {
                var tabIndex = $.attr(element, "tabindex"),
                    isTabIndexNaN = isNaN(tabIndex);
                return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN)
            }
        }), $("<a>").outerWidth(1).jquery || $.each(["Width", "Height"], function (i, name) {
            function reduce(elem, size, border, margin) {
                return $.each(side, function () {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0)
                }), size
            }
            var side = "Width" === name ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };
            $.fn["inner" + name] = function (size) {
                return size === undefined ? orig["inner" + name].call(this) : this.each(function () {
                    $(this).css(type, reduce(this, size) + "px")
                })
            }, $.fn["outer" + name] = function (size, margin) {
                return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function () {
                    $(this).css(type, reduce(this, size, !0, margin) + "px")
                })
            }
        }), $.fn.addBack || ($.fn.addBack = function (selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
        }), $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function (removeData) {
            return function (key) {
                return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this)
            }
        }($.fn.removeData)), $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), $.support.selectstart = "onselectstart" in document.createElement("div"), $.fn.extend({
            disableSelection: function () {
                return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function (event) {
                    event.preventDefault()
                })
            },
            enableSelection: function () {
                return this.unbind(".ui-disableSelection")
            }
        }), $.extend($.ui, {
            plugin: {
                add: function (module, option, set) {
                    var i, proto = $.ui[module].prototype;
                    for (i in set) proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([option, set [i]])
                },
                call: function (instance, name, args) {
                    var i, set = instance.plugins[name];
                    if (set && instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType)
                        for (i = 0; i < set.length; i++) instance.options[set [i][0]] && set [i][1].apply(instance.element, args)
                }
            },
            hasScroll: function (el, a) {
                if ("hidden" === $(el).css("overflow")) return !1;
                var scroll = a && "left" === a ? "scrollLeft" : "scrollTop",
                    has = !1;
                return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, has)
            }
        })
    }(jQuery),
    function ($, undefined) {
        var uuid = 0,
            slice = Array.prototype.slice,
            _cleanData = $.cleanData;
        $.cleanData = function (elems) {
            for (var elem, i = 0; null != (elem = elems[i]); i++) try {
                $(elem).triggerHandler("remove")
            } catch (e) {}
            _cleanData(elems)
        }, $.widget = function (name, base, prototype) {
            var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {},
                namespace = name.split(".")[0];
            name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, base = $.Widget), $.expr[":"][fullName.toLowerCase()] = function (elem) {
                return !!$.data(elem, fullName)
            }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], constructor = $[namespace][name] = function (options, element) {
                return this._createWidget ? void(arguments.length && this._createWidget(options, element)) : new constructor(options, element)
            }, $.extend(constructor, existingConstructor, {
                version: prototype.version,
                _proto: $.extend({}, prototype),
                _childConstructors: []
            }), basePrototype = new base, basePrototype.options = $.widget.extend({}, basePrototype.options), $.each(prototype, function (prop, value) {
                return $.isFunction(value) ? void(proxiedPrototype[prop] = function () {
                    var _super = function () {
                            return base.prototype[prop].apply(this, arguments)
                        },
                        _superApply = function (args) {
                            return base.prototype[prop].apply(this, args)
                        };
                    return function () {
                        var returnValue, __super = this._super,
                            __superApply = this._superApply;
                        return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), this._super = __super, this._superApply = __superApply, returnValue
                    }
                }()) : void(proxiedPrototype[prop] = value)
            }), constructor.prototype = $.widget.extend(basePrototype, {
                widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
            }, proxiedPrototype, {
                constructor: constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            }), existingConstructor ? ($.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto)
            }), delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), $.widget.bridge(name, constructor)
        }, $.widget.extend = function (target) {
            for (var key, value, input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++)
                for (key in input[inputIndex]) value = input[inputIndex][key], input[inputIndex].hasOwnProperty(key) && value !== undefined && (target[key] = $.isPlainObject(value) ? $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value) : value);
            return target
        }, $.widget.bridge = function (name, object) {
            var fullName = object.prototype.widgetFullName || name;
            $.fn[name] = function (options) {
                var isMethodCall = "string" == typeof options,
                    args = slice.call(arguments, 1),
                    returnValue = this;
                return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options, this.each(isMethodCall ? function () {
                    var methodValue, instance = $.data(this, fullName);
                    return instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), methodValue !== instance && methodValue !== undefined ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'")
                } : function () {
                    var instance = $.data(this, fullName);
                    instance ? instance.option(options || {})._init() : $.data(this, fullName, new object(options, this))
                }), returnValue
            }
        }, $.Widget = function () {}, $.Widget._childConstructors = [], $.Widget.prototype = {
            widgetName: "widget",
            widgetEventPrefix: "",
            defaultElement: "<div>",
            options: {
                disabled: !1,
                create: null
            },
            _createWidget: function (options, element) {
                element = $(element || this.defaultElement || this)[0], this.element = $(element), this.uuid = uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), this._on(!0, this.element, {
                    remove: function (event) {
                        event.target === element && this.destroy()
                    }
                }), this.document = $(element.style ? element.ownerDocument : element.document || element), this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), this._create(), this._trigger("create", null, this._getCreateEventData()), this._init()
            },
            _getCreateOptions: $.noop,
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,
            destroy: function () {
                this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")
            },
            _destroy: $.noop,
            widget: function () {
                return this.element
            },
            option: function (key, value) {
                var parts, curOption, i, options = key;
                if (0 === arguments.length) return $.widget.extend({}, this.options);
                if ("string" == typeof key)
                    if (options = {}, parts = key.split("."), key = parts.shift(), parts.length) {
                        for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {}, curOption = curOption[parts[i]];
                        if (key = parts.pop(), value === undefined) return curOption[key] === undefined ? null : curOption[key];
                        curOption[key] = value
                    } else {
                        if (value === undefined) return this.options[key] === undefined ? null : this.options[key];
                        options[key] = value
                    }
                return this._setOptions(options), this
            },
            _setOptions: function (options) {
                var key;
                for (key in options) this._setOption(key, options[key]);
                return this
            },
            _setOption: function (key, value) {
                return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value), this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), this
            },
            enable: function () {
                return this._setOption("disabled", !1)
            },
            disable: function () {
                return this._setOption("disabled", !0)
            },
            _on: function (suppressDisabledCheck, element, handlers) {
                var delegateElement, instance = this;
                "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, suppressDisabledCheck = !1), handlers ? (element = delegateElement = $(element), this.bindings = this.bindings.add(element)) : (handlers = element, element = this.element, delegateElement = this.widget()), $.each(handlers, function (event, handler) {
                    function handlerProxy() {
                        return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0
                    }
                    "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                    var match = event.match(/^(\w+)\s*(.*)$/),
                        eventName = match[1] + instance.eventNamespace,
                        selector = match[2];
                    selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy)
                })
            },
            _off: function (element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, element.unbind(eventName).undelegate(eventName)
            },
            _delay: function (handler, delay) {
                function handlerProxy() {
                    return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments)
                }
                var instance = this;
                return setTimeout(handlerProxy, delay || 0)
            },
            _hoverable: function (element) {
                this.hoverable = this.hoverable.add(element), this._on(element, {
                    mouseenter: function (event) {
                        $(event.currentTarget).addClass("ui-state-hover")
                    },
                    mouseleave: function (event) {
                        $(event.currentTarget).removeClass("ui-state-hover")
                    }
                })
            },
            _focusable: function (element) {
                this.focusable = this.focusable.add(element), this._on(element, {
                    focusin: function (event) {
                        $(event.currentTarget).addClass("ui-state-focus")
                    },
                    focusout: function (event) {
                        $(event.currentTarget).removeClass("ui-state-focus")
                    }
                })
            },
            _trigger: function (type, event, data) {
                var prop, orig, callback = this.options[type];
                if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), event.target = this.element[0], orig = event.originalEvent)
                    for (prop in orig) prop in event || (event[prop] = orig[prop]);
                return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === !1 || event.isDefaultPrevented())
            }
        }, $.each({
            show: "fadeIn",
            hide: "fadeOut"
        }, function (method, defaultEffect) {
            $.Widget.prototype["_" + method] = function (element, options, callback) {
                "string" == typeof options && (options = {
                    effect: options
                });
                var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
                options = options || {}, "number" == typeof options && (options = {
                    duration: options
                }), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function (next) {
                    $(this)[method](), callback && callback.call(element[0]), next()
                })
            }
        })
    }(jQuery),
    function ($) {
        var mouseHandled = !1;
        $(document).mouseup(function () {
            mouseHandled = !1
        }), $.widget("ui.mouse", {
            version: "1.10.3",
            options: {
                cancel: "input,textarea,button,select,option",
                distance: 1,
                delay: 0
            },
            _mouseInit: function () {
                var that = this;
                this.element.bind("mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event)
                }).bind("click." + this.widgetName, function (event) {
                    return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), event.stopImmediatePropagation(), !1) : void 0
                }), this.started = !1
            },
            _mouseDestroy: function () {
                this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate)
            },
            _mouseDown: function (event) {
                if (!mouseHandled) {
                    this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                    var that = this,
                        btnIsLeft = 1 === event.which,
                        elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                    return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
                        that.mouseDelayMet = !0
                    }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (event) {
                        return that._mouseMove(event)
                    }, this._mouseUpDelegate = function (event) {
                        return that._mouseUp(event)
                    }, $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), event.preventDefault(), mouseHandled = !0, !0)) : !0
                }
            },
            _mouseMove: function (event) {
                return $.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button ? this._mouseUp(event) : this._mouseStarted ? (this._mouseDrag(event), event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted)
            },
            _mouseUp: function (event) {
                return $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(event)), !1
            },
            _mouseDistanceMet: function (event) {
                return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance
            },
            _mouseDelayMet: function () {
                return this.mouseDelayMet
            },
            _mouseStart: function () {},
            _mouseDrag: function () {},
            _mouseStop: function () {},
            _mouseCapture: function () {
                return !0
            }
        })
    }(jQuery),
    function ($) {
        $.widget("ui.draggable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "drag",
            options: {
                addClasses: !0,
                appendTo: "parent",
                axis: !1,
                connectToSortable: !1,
                containment: !1,
                cursor: "auto",
                cursorAt: !1,
                grid: !1,
                handle: !1,
                helper: "original",
                iframeFix: !1,
                opacity: !1,
                refreshPositions: !1,
                revert: !1,
                revertDuration: 500,
                scope: "default",
                scroll: !0,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                snap: !1,
                snapMode: "both",
                snapTolerance: 20,
                stack: !1,
                zIndex: !1,
                drag: null,
                start: null,
                stop: null
            },
            _create: function () {
                "original" !== this.options.helper || /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative"), this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), this._mouseInit()
            },
            _destroy: function () {
                this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), this._mouseDestroy()
            },
            _mouseCapture: function (event) {
                var o = this.options;
                return this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(event), this.handle ? ($(o.iframeFix === !0 ? "iframe" : o.iframeFix).each(function () {
                    $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
                        width: this.offsetWidth + "px",
                        height: this.offsetHeight + "px",
                        position: "absolute",
                        opacity: "0.001",
                        zIndex: 1e3
                    }).css($(this).offset()).appendTo("body")
                }), !0) : !1)
            },
            _mouseStart: function (event) {
                var o = this.options;
                return this.helper = this._createHelper(event), this.helper.addClass("ui-draggable-dragging"), this._cacheHelperProportions(), $.ui.ddmanager && ($.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(), this.offsetParent = this.helper.offsetParent(), this.offsetParentCssPosition = this.offsetParent.css("position"), this.offset = this.positionAbs = this.element.offset(), this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                }, this.offset.scroll = !1, $.extend(this.offset, {
                    click: {
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                }), this.originalPosition = this.position = this._generatePosition(event), this.originalPageX = event.pageX, this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this._setContainment(), this._trigger("start", event) === !1 ? (this._clear(), !1) : (this._cacheHelperProportions(), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), this._mouseDrag(event, !0), $.ui.ddmanager && $.ui.ddmanager.dragStart(this, event), !0)
            },
            _mouseDrag: function (event, noPropagation) {
                if ("fixed" === this.offsetParentCssPosition && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), !noPropagation) {
                    var ui = this._uiHash();
                    if (this._trigger("drag", event, ui) === !1) return this._mouseUp({}), !1;
                    this.position = ui.position
                }
                return this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), $.ui.ddmanager && $.ui.ddmanager.drag(this, event), !1
            },
            _mouseStop: function (event) {
                var that = this,
                    dropped = !1;
                return $.ui.ddmanager && !this.options.dropBehaviour && (dropped = $.ui.ddmanager.drop(this, event)), this.dropped && (dropped = this.dropped, this.dropped = !1), "original" !== this.options.helper || $.contains(this.element[0].ownerDocument, this.element[0]) ? ("invalid" === this.options.revert && !dropped || "valid" === this.options.revert && dropped || this.options.revert === !0 || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped) ? $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
                    that._trigger("stop", event) !== !1 && that._clear()
                }) : this._trigger("stop", event) !== !1 && this._clear(), !1) : !1
            },
            _mouseUp: function (event) {
                return $("div.ui-draggable-iframeFix").each(function () {
                    this.parentNode.removeChild(this)
                }), $.ui.ddmanager && $.ui.ddmanager.dragStop(this, event), $.ui.mouse.prototype._mouseUp.call(this, event)
            },
            cancel: function () {
                return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), this
            },
            _getHandle: function (event) {
                return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : !0
            },
            _createHelper: function (event) {
                var o = this.options,
                    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : "clone" === o.helper ? this.element.clone().removeAttr("id") : this.element;
                return helper.parents("body").length || helper.appendTo("parent" === o.appendTo ? this.element[0].parentNode : o.appendTo), helper[0] === this.element[0] || /(fixed|absolute)/.test(helper.css("position")) || helper.css("position", "absolute"), helper
            },
            _adjustOffsetFromHelper: function (obj) {
                "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                }), "left" in obj && (this.offset.click.left = obj.left + this.margins.left), "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), "top" in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
            },
            _getParentOffset: function () {
                var po = this.offsetParent.offset();
                return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                    top: 0,
                    left: 0
                }), {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                }
            },
            _getRelativeOffset: function () {
                if ("relative" === this.cssPosition) {
                    var p = this.element.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    }
                }
                return {
                    top: 0,
                    left: 0
                }
            },
            _cacheMargins: function () {
                this.margins = {
                    left: parseInt(this.element.css("marginLeft"), 10) || 0,
                    top: parseInt(this.element.css("marginTop"), 10) || 0,
                    right: parseInt(this.element.css("marginRight"), 10) || 0,
                    bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                }
            },
            _cacheHelperProportions: function () {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                }
            },
            _setContainment: function () {
                var over, c, ce, o = this.options;
                return o.containment ? "window" === o.containment ? void(this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : "document" === o.containment ? void(this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]) : o.containment.constructor === Array ? void(this.containment = o.containment) : ("parent" === o.containment && (o.containment = this.helper[0].parentNode), c = $(o.containment), ce = c[0], void(ce && (over = "hidden" !== c.css("overflow"), this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relative_container = c))) : void(this.containment = null)
            },
            _convertPositionTo: function (d, pos) {
                pos || (pos = this.position);
                var mod = "absolute" === d ? 1 : -1,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent;
                return this.offset.scroll || (this.offset.scroll = {
                    top: scroll.scrollTop(),
                    left: scroll.scrollLeft()
                }), {
                    top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
                    left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
                }
            },
            _generatePosition: function (event) {
                var containment, co, top, left, o = this.options,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                    pageX = event.pageX,
                    pageY = event.pageY;
                return this.offset.scroll || (this.offset.scroll = {
                    top: scroll.scrollTop(),
                    left: scroll.scrollLeft()
                }), this.originalPosition && (this.containment && (this.relative_container ? (co = this.relative_container.offset(), containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top]) : containment = this.containment, event.pageX - this.offset.click.left < containment[0] && (pageX = containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < containment[1] && (pageY = containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > containment[2] && (pageX = containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > containment[3] && (pageY = containment[3] + this.offset.click.top)), o.grid && (top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), {
                    top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
                    left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
                }
            },
            _clear: function () {
                this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1
            },
            _trigger: function (type, event, ui) {
                return ui = ui || this._uiHash(), $.ui.plugin.call(this, type, [event, ui]), "drag" === type && (this.positionAbs = this._convertPositionTo("absolute")), $.Widget.prototype._trigger.call(this, type, event, ui)
            },
            plugins: {},
            _uiHash: function () {
                return {
                    helper: this.helper,
                    position: this.position,
                    originalPosition: this.originalPosition,
                    offset: this.positionAbs
                }
            }
        }), $.ui.plugin.add("draggable", "connectToSortable", {
            start: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    o = inst.options,
                    uiSortable = $.extend({}, ui, {
                        item: inst.element
                    });
                inst.sortables = [], $(o.connectToSortable).each(function () {
                    var sortable = $.data(this, "ui-sortable");
                    sortable && !sortable.options.disabled && (inst.sortables.push({
                        instance: sortable,
                        shouldRevert: sortable.options.revert
                    }), sortable.refreshPositions(), sortable._trigger("activate", event, uiSortable))
                })
            },
            stop: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    uiSortable = $.extend({}, ui, {
                        item: inst.element
                    });
                $.each(inst.sortables, function () {
                    this.instance.isOver ? (this.instance.isOver = 0, inst.cancelHelperRemoval = !0, this.instance.cancelHelperRemoval = !1, this.shouldRevert && (this.instance.options.revert = this.shouldRevert), this.instance._mouseStop(event), this.instance.options.helper = this.instance.options._helper, "original" === inst.options.helper && this.instance.currentItem.css({
                        top: "auto",
                        left: "auto"
                    })) : (this.instance.cancelHelperRemoval = !1, this.instance._trigger("deactivate", event, uiSortable))
                })
            },
            drag: function (event, ui) {
                var inst = $(this).data("ui-draggable"),
                    that = this;
                $.each(inst.sortables, function () {
                    var innermostIntersecting = !1,
                        thisSortable = this;
                    this.instance.positionAbs = inst.positionAbs, this.instance.helperProportions = inst.helperProportions, this.instance.offset.click = inst.offset.click, this.instance._intersectsWith(this.instance.containerCache) && (innermostIntersecting = !0, $.each(inst.sortables, function () {
                        return this.instance.positionAbs = inst.positionAbs, this.instance.helperProportions = inst.helperProportions, this.instance.offset.click = inst.offset.click, this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0]) && (innermostIntersecting = !1), innermostIntersecting
                    })), innermostIntersecting ? (this.instance.isOver || (this.instance.isOver = 1, this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", !0), this.instance.options._helper = this.instance.options.helper, this.instance.options.helper = function () {
                        return ui.helper[0]
                    }, event.target = this.instance.currentItem[0], this.instance._mouseCapture(event, !0), this.instance._mouseStart(event, !0, !0), this.instance.offset.click.top = inst.offset.click.top, this.instance.offset.click.left = inst.offset.click.left, this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left, this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top, inst._trigger("toSortable", event), inst.dropped = this.instance.element, inst.currentItem = inst.element, this.instance.fromOutside = inst), this.instance.currentItem && this.instance._mouseDrag(event)) : this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, this.instance.options.revert = !1, this.instance._trigger("out", event, this.instance._uiHash(this.instance)), this.instance._mouseStop(event, !0), this.instance.options.helper = this.instance.options._helper, this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), inst._trigger("fromSortable", event), inst.dropped = !1)
                })
            }
        }), $.ui.plugin.add("draggable", "cursor", {
            start: function () {
                var t = $("body"),
                    o = $(this).data("ui-draggable").options;
                t.css("cursor") && (o._cursor = t.css("cursor")), t.css("cursor", o.cursor)
            },
            stop: function () {
                var o = $(this).data("ui-draggable").options;
                o._cursor && $("body").css("cursor", o._cursor)
            }
        }), $.ui.plugin.add("draggable", "opacity", {
            start: function (event, ui) {
                var t = $(ui.helper),
                    o = $(this).data("ui-draggable").options;
                t.css("opacity") && (o._opacity = t.css("opacity")), t.css("opacity", o.opacity)
            },
            stop: function (event, ui) {
                var o = $(this).data("ui-draggable").options;
                o._opacity && $(ui.helper).css("opacity", o._opacity)
            }
        }), $.ui.plugin.add("draggable", "scroll", {
            start: function () {
                var i = $(this).data("ui-draggable");
                i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName && (i.overflowOffset = i.scrollParent.offset())
            },
            drag: function (event) {
                var i = $(this).data("ui-draggable"),
                    o = i.options,
                    scrolled = !1;
                i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName ? (o.axis && "x" === o.axis || (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - i.overflowOffset.top < o.scrollSensitivity && (i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed)), o.axis && "y" === o.axis || (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - i.overflowOffset.left < o.scrollSensitivity && (i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed))), o.axis && "y" === o.axis || (event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)))), scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(i, event)
            }
        }), $.ui.plugin.add("draggable", "snap", {
            start: function () {
                var i = $(this).data("ui-draggable"),
                    o = i.options;
                i.snapElements = [], $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function () {
                    var $t = $(this),
                        $o = $t.offset();
                    this !== i.element[0] && i.snapElements.push({
                        item: this,
                        width: $t.outerWidth(),
                        height: $t.outerHeight(),
                        top: $o.top,
                        left: $o.left
                    })
                })
            },
            drag: function (event, ui) {
                var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data("ui-draggable"),
                    o = inst.options,
                    d = o.snapTolerance,
                    x1 = ui.offset.left,
                    x2 = x1 + inst.helperProportions.width,
                    y1 = ui.offset.top,
                    y2 = y1 + inst.helperProportions.height;
                for (i = inst.snapElements.length - 1; i >= 0; i--) l = inst.snapElements[i].left, r = l + inst.snapElements[i].width, t = inst.snapElements[i].top, b = t + inst.snapElements[i].height, l - d > x2 || x1 > r + d || t - d > y2 || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item) ? (inst.snapElements[i].snapping && inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                    snapItem: inst.snapElements[i].item
                })), inst.snapElements[i].snapping = !1) : ("inner" !== o.snapMode && (ts = Math.abs(t - y2) <= d, bs = Math.abs(b - y1) <= d, ls = Math.abs(l - x2) <= d, rs = Math.abs(r - x1) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {
                    top: t - inst.helperProportions.height,
                    left: 0
                }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                    top: b,
                    left: 0
                }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                    top: 0,
                    left: l - inst.helperProportions.width
                }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                    top: 0,
                    left: r
                }).left - inst.margins.left)), first = ts || bs || ls || rs, "outer" !== o.snapMode && (ts = Math.abs(t - y1) <= d, bs = Math.abs(b - y2) <= d, ls = Math.abs(l - x1) <= d, rs = Math.abs(r - x2) <= d, ts && (ui.position.top = inst._convertPositionTo("relative", {
                    top: t,
                    left: 0
                }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                    top: b - inst.helperProportions.height,
                    left: 0
                }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                    top: 0,
                    left: l
                }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                    top: 0,
                    left: r - inst.helperProportions.width
                }).left - inst.margins.left)), !inst.snapElements[i].snapping && (ts || bs || ls || rs || first) && inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                    snapItem: inst.snapElements[i].item
                })), inst.snapElements[i].snapping = ts || bs || ls || rs || first)
            }
        }), $.ui.plugin.add("draggable", "stack", {
            start: function () {
                var min, o = this.data("ui-draggable").options,
                    group = $.makeArray($(o.stack)).sort(function (a, b) {
                        return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0)
                    });
                group.length && (min = parseInt($(group[0]).css("zIndex"), 10) || 0, $(group).each(function (i) {
                    $(this).css("zIndex", min + i)
                }), this.css("zIndex", min + group.length))
            }
        }), $.ui.plugin.add("draggable", "zIndex", {
            start: function (event, ui) {
                var t = $(ui.helper),
                    o = $(this).data("ui-draggable").options;
                t.css("zIndex") && (o._zIndex = t.css("zIndex")), t.css("zIndex", o.zIndex)
            },
            stop: function (event, ui) {
                var o = $(this).data("ui-draggable").options;
                o._zIndex && $(ui.helper).css("zIndex", o._zIndex)
            }
        })
    }(jQuery),
    function ($) {
        function isOverAxis(x, reference, size) {
            return x > reference && reference + size > x
        }
        $.widget("ui.droppable", {
            version: "1.10.3",
            widgetEventPrefix: "drop",
            options: {
                accept: "*",
                activeClass: !1,
                addClasses: !0,
                greedy: !1,
                hoverClass: !1,
                scope: "default",
                tolerance: "intersect",
                activate: null,
                deactivate: null,
                drop: null,
                out: null,
                over: null
            },
            _create: function () {
                var o = this.options,
                    accept = o.accept;
                this.isover = !1, this.isout = !0, this.accept = $.isFunction(accept) ? accept : function (d) {
                    return d.is(accept)
                }, this.proportions = {
                    width: this.element[0].offsetWidth,
                    height: this.element[0].offsetHeight
                }, $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [], $.ui.ddmanager.droppables[o.scope].push(this), o.addClasses && this.element.addClass("ui-droppable")
            },
            _destroy: function () {
                for (var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope]; i < drop.length; i++) drop[i] === this && drop.splice(i, 1);
                this.element.removeClass("ui-droppable ui-droppable-disabled")
            },
            _setOption: function (key, value) {
                "accept" === key && (this.accept = $.isFunction(value) ? value : function (d) {
                    return d.is(value)
                }), $.Widget.prototype._setOption.apply(this, arguments)
            },
            _activate: function (event) {
                var draggable = $.ui.ddmanager.current;
                this.options.activeClass && this.element.addClass(this.options.activeClass), draggable && this._trigger("activate", event, this.ui(draggable))
            },
            _deactivate: function (event) {
                var draggable = $.ui.ddmanager.current;
                this.options.activeClass && this.element.removeClass(this.options.activeClass), draggable && this._trigger("deactivate", event, this.ui(draggable))
            },
            _over: function (event) {
                var draggable = $.ui.ddmanager.current;
                draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), this._trigger("over", event, this.ui(draggable)))
            },
            _out: function (event) {
                var draggable = $.ui.ddmanager.current;
                draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("out", event, this.ui(draggable)))
            },
            _drop: function (event, custom) {
                var draggable = custom || $.ui.ddmanager.current,
                    childrenIntersection = !1;
                return draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] ? (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
                    var inst = $.data(this, "ui-droppable");
                    return inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                        offset: inst.element.offset()
                    }), inst.options.tolerance) ? (childrenIntersection = !0, !1) : void 0
                }), childrenIntersection ? !1 : this.accept.call(this.element[0], draggable.currentItem || draggable.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", event, this.ui(draggable)), this.element) : !1) : !1
            },
            ui: function (c) {
                return {
                    draggable: c.currentItem || c.element,
                    helper: c.helper,
                    position: c.position,
                    offset: c.positionAbs
                }
            }
        }), $.ui.intersect = function (draggable, droppable, toleranceMode) {
            if (!droppable.offset) return !1;
            var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left,
                x2 = x1 + draggable.helperProportions.width,
                y1 = (draggable.positionAbs || draggable.position.absolute).top,
                y2 = y1 + draggable.helperProportions.height,
                l = droppable.offset.left,
                r = l + droppable.proportions.width,
                t = droppable.offset.top,
                b = t + droppable.proportions.height;
            switch (toleranceMode) {
            case "fit":
                return x1 >= l && r >= x2 && y1 >= t && b >= y2;
            case "intersect":
                return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;
            case "pointer":
                return draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left, draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top, isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);
            case "touch":
                return (y1 >= t && b >= y1 || y2 >= t && b >= y2 || t > y1 && y2 > b) && (x1 >= l && r >= x1 || x2 >= l && r >= x2 || l > x1 && x2 > r);
            default:
                return !1
            }
        }, $.ui.ddmanager = {
            current: null,
            droppables: {
                "default": []
            },
            prepareOffsets: function (t, event) {
                var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [],
                    type = event ? event.type : null,
                    list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
                droppablesLoop: for (i = 0; i < m.length; i++)
                    if (!(m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element))) {
                        for (j = 0; j < list.length; j++)
                            if (list[j] === m[i].element[0]) {
                                m[i].proportions.height = 0;
                                continue droppablesLoop
                            }
                        m[i].visible = "none" !== m[i].element.css("display"), m[i].visible && ("mousedown" === type && m[i]._activate.call(m[i], event), m[i].offset = m[i].element.offset(), m[i].proportions = {
                            width: m[i].element[0].offsetWidth,
                            height: m[i].element[0].offsetHeight
                        })
                    }
            },
            drop: function (draggable, event) {
                var dropped = !1;
                return $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {
                    this.options && (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance) && (dropped = this._drop.call(this, event) || dropped), !this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, event)))
                }), dropped
            },
            dragStart: function (draggable, event) {
                draggable.element.parentsUntil("body").bind("scroll.droppable", function () {
                    draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event)
                })
            },
            drag: function (draggable, event) {
                draggable.options.refreshPositions && $.ui.ddmanager.prepareOffsets(draggable, event), $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {
                    if (!this.options.disabled && !this.greedyChild && this.visible) {
                        var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance),
                            c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                        c && (this.options.greedy && (scope = this.options.scope, parent = this.element.parents(":data(ui-droppable)").filter(function () {
                            return $.data(this, "ui-droppable").options.scope === scope
                        }), parent.length && (parentInstance = $.data(parent[0], "ui-droppable"), parentInstance.greedyChild = "isover" === c)), parentInstance && "isover" === c && (parentInstance.isover = !1, parentInstance.isout = !0, parentInstance._out.call(parentInstance, event)), this[c] = !0, this["isout" === c ? "isover" : "isout"] = !1, this["isover" === c ? "_over" : "_out"].call(this, event), parentInstance && "isout" === c && (parentInstance.isout = !1, parentInstance.isover = !0, parentInstance._over.call(parentInstance, event)))
                    }
                })
            },
            dragStop: function (draggable, event) {
                draggable.element.parentsUntil("body").unbind("scroll.droppable"), draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event)
            }
        }
    }(jQuery),
    function ($) {
        function num(v) {
            return parseInt(v, 10) || 0
        }

        function isNumber(value) {
            return !isNaN(parseInt(value, 10))
        }
        $.widget("ui.resizable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "resize",
            options: {
                alsoResize: !1,
                animate: !1,
                animateDuration: "slow",
                animateEasing: "swing",
                aspectRatio: !1,
                autoHide: !1,
                containment: !1,
                ghost: !1,
                grid: !1,
                handles: "e,s,se",
                helper: !1,
                maxHeight: null,
                maxWidth: null,
                minHeight: 10,
                minWidth: 10,
                zIndex: 90,
                resize: null,
                start: null,
                stop: null
            },
            _create: function () {
                var n, i, handle, axis, hname, that = this,
                    o = this.options;
                if (this.element.addClass("ui-resizable"), $.extend(this, {
                    _aspectRatio: !!o.aspectRatio,
                    aspectRatio: o.aspectRatio,
                    originalElement: this.element,
                    _proportionallyResizeElements: [],
                    _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
                }), this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i) && (this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                    position: this.element.css("position"),
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight(),
                    top: this.element.css("top"),
                    left: this.element.css("left")
                })), this.element = this.element.parent().data("ui-resizable", this.element.data("ui-resizable")), this.elementIsWrapper = !0, this.element.css({
                    marginLeft: this.originalElement.css("marginLeft"),
                    marginTop: this.originalElement.css("marginTop"),
                    marginRight: this.originalElement.css("marginRight"),
                    marginBottom: this.originalElement.css("marginBottom")
                }), this.originalElement.css({
                    marginLeft: 0,
                    marginTop: 0,
                    marginRight: 0,
                    marginBottom: 0
                }), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
                    position: "static",
                    zoom: 1,
                    display: "block"
                })), this.originalElement.css({
                    margin: this.originalElement.css("margin")
                }), this._proportionallyResize()), this.handles = o.handles || ($(".ui-resizable-handle", this.element).length ? {
                    n: ".ui-resizable-n",
                    e: ".ui-resizable-e",
                    s: ".ui-resizable-s",
                    w: ".ui-resizable-w",
                    se: ".ui-resizable-se",
                    sw: ".ui-resizable-sw",
                    ne: ".ui-resizable-ne",
                    nw: ".ui-resizable-nw"
                } : "e,s,se"), this.handles.constructor === String)
                    for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), n = this.handles.split(","), this.handles = {}, i = 0; i < n.length; i++) handle = $.trim(n[i]), hname = "ui-resizable-" + handle, axis = $("<div class='ui-resizable-handle " + hname + "'></div>"), axis.css({
                        zIndex: o.zIndex
                    }), "se" === handle && axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), this.handles[handle] = ".ui-resizable-" + handle, this.element.append(axis);
                this._renderAxis = function (target) {
                    var i, axis, padPos, padWrapper;
                    target = target || this.element;
                    for (i in this.handles) this.handles[i].constructor === String && (this.handles[i] = $(this.handles[i], this.element).show()), this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i) && (axis = $(this.handles[i], this.element), padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth(), padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join(""), target.css(padPos, padWrapper), this._proportionallyResize()), $(this.handles[i]).length
                }, this._renderAxis(this.element), this._handles = $(".ui-resizable-handle", this.element).disableSelection(), this._handles.mouseover(function () {
                    that.resizing || (this.className && (axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), that.axis = axis && axis[1] ? axis[1] : "se")
                }), o.autoHide && (this._handles.hide(), $(this.element).addClass("ui-resizable-autohide").mouseenter(function () {
                    o.disabled || ($(this).removeClass("ui-resizable-autohide"), that._handles.show())
                }).mouseleave(function () {
                    o.disabled || that.resizing || ($(this).addClass("ui-resizable-autohide"), that._handles.hide())
                })), this._mouseInit()
            },
            _destroy: function () {
                this._mouseDestroy();
                var wrapper, _destroy = function (exp) {
                    $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()
                };
                return this.elementIsWrapper && (_destroy(this.element), wrapper = this.element, this.originalElement.css({
                    position: wrapper.css("position"),
                    width: wrapper.outerWidth(),
                    height: wrapper.outerHeight(),
                    top: wrapper.css("top"),
                    left: wrapper.css("left")
                }).insertAfter(wrapper), wrapper.remove()), this.originalElement.css("resize", this.originalResizeStyle), _destroy(this.originalElement), this
            },
            _mouseCapture: function (event) {
                var i, handle, capture = !1;
                for (i in this.handles) handle = $(this.handles[i])[0], (handle === event.target || $.contains(handle, event.target)) && (capture = !0);
                return !this.options.disabled && capture
            },
            _mouseStart: function (event) {
                var curleft, curtop, cursor, o = this.options,
                    iniPos = this.element.position(),
                    el = this.element;
                return this.resizing = !0, /absolute/.test(el.css("position")) ? el.css({
                    position: "absolute",
                    top: el.css("top"),
                    left: el.css("left")
                }) : el.is(".ui-draggable") && el.css({
                    position: "absolute",
                    top: iniPos.top,
                    left: iniPos.left
                }), this._renderProxy(), curleft = num(this.helper.css("left")), curtop = num(this.helper.css("top")), o.containment && (curleft += $(o.containment).scrollLeft() || 0, curtop += $(o.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
                    left: curleft,
                    top: curtop
                }, this.size = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                }, this.originalSize = this._helper ? {
                    width: el.outerWidth(),
                    height: el.outerHeight()
                } : {
                    width: el.width(),
                    height: el.height()
                }, this.originalPosition = {
                    left: curleft,
                    top: curtop
                }, this.sizeDiff = {
                    width: el.outerWidth() - el.width(),
                    height: el.outerHeight() - el.height()
                }, this.originalMousePosition = {
                    left: event.pageX,
                    top: event.pageY
                }, this.aspectRatio = "number" == typeof o.aspectRatio ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1, cursor = $(".ui-resizable-" + this.axis).css("cursor"), $("body").css("cursor", "auto" === cursor ? this.axis + "-resize" : cursor), el.addClass("ui-resizable-resizing"), this._propagate("start", event), !0
            },
            _mouseDrag: function (event) {
                var data, el = this.helper,
                    props = {},
                    smp = this.originalMousePosition,
                    a = this.axis,
                    prevTop = this.position.top,
                    prevLeft = this.position.left,
                    prevWidth = this.size.width,
                    prevHeight = this.size.height,
                    dx = event.pageX - smp.left || 0,
                    dy = event.pageY - smp.top || 0,
                    trigger = this._change[a];
                return trigger ? (data = trigger.apply(this, [event, dx, dy]), this._updateVirtualBoundaries(event.shiftKey), (this._aspectRatio || event.shiftKey) && (data = this._updateRatio(data, event)), data = this._respectSize(data, event), this._updateCache(data), this._propagate("resize", event), this.position.top !== prevTop && (props.top = this.position.top + "px"), this.position.left !== prevLeft && (props.left = this.position.left + "px"), this.size.width !== prevWidth && (props.width = this.size.width + "px"), this.size.height !== prevHeight && (props.height = this.size.height + "px"), el.css(props), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), $.isEmptyObject(props) || this._trigger("resize", event, this.ui()), !1) : !1
            },
            _mouseStop: function (event) {
                this.resizing = !1;
                var pr, ista, soffseth, soffsetw, s, left, top, o = this.options,
                    that = this;
                return this._helper && (pr = this._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, s = {
                    width: that.helper.width() - soffsetw,
                    height: that.helper.height() - soffseth
                }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null, o.animate || this.element.css($.extend(s, {
                    top: top,
                    left: left
                })), that.helper.height(that.size.height), that.helper.width(that.size.width), this._helper && !o.animate && this._proportionallyResize()), $("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), this._propagate("stop", event), this._helper && this.helper.remove(), !1
            },
            _updateVirtualBoundaries: function (forceAspectRatio) {
                var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
                b = {
                    minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                    maxWidth: isNumber(o.maxWidth) ? o.maxWidth : 1 / 0,
                    minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                    maxHeight: isNumber(o.maxHeight) ? o.maxHeight : 1 / 0
                }, (this._aspectRatio || forceAspectRatio) && (pMinWidth = b.minHeight * this.aspectRatio, pMinHeight = b.minWidth / this.aspectRatio, pMaxWidth = b.maxHeight * this.aspectRatio, pMaxHeight = b.maxWidth / this.aspectRatio, pMinWidth > b.minWidth && (b.minWidth = pMinWidth), pMinHeight > b.minHeight && (b.minHeight = pMinHeight), pMaxWidth < b.maxWidth && (b.maxWidth = pMaxWidth), pMaxHeight < b.maxHeight && (b.maxHeight = pMaxHeight)), this._vBoundaries = b
            },
            _updateCache: function (data) {
                this.offset = this.helper.offset(), isNumber(data.left) && (this.position.left = data.left), isNumber(data.top) && (this.position.top = data.top), isNumber(data.height) && (this.size.height = data.height), isNumber(data.width) && (this.size.width = data.width)
            },
            _updateRatio: function (data) {
                var cpos = this.position,
                    csize = this.size,
                    a = this.axis;
                return isNumber(data.height) ? data.width = data.height * this.aspectRatio : isNumber(data.width) && (data.height = data.width / this.aspectRatio), "sw" === a && (data.left = cpos.left + (csize.width - data.width), data.top = null), "nw" === a && (data.top = cpos.top + (csize.height - data.height), data.left = cpos.left + (csize.width - data.width)), data
            },
            _respectSize: function (data) {
                var o = this._vBoundaries,
                    a = this.axis,
                    ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,
                    ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,
                    isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width,
                    isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height,
                    dw = this.originalPosition.left + this.originalSize.width,
                    dh = this.position.top + this.size.height,
                    cw = /sw|nw|w/.test(a),
                    ch = /nw|ne|n/.test(a);
                return isminw && (data.width = o.minWidth), isminh && (data.height = o.minHeight), ismaxw && (data.width = o.maxWidth), ismaxh && (data.height = o.maxHeight), isminw && cw && (data.left = dw - o.minWidth), ismaxw && cw && (data.left = dw - o.maxWidth), isminh && ch && (data.top = dh - o.minHeight), ismaxh && ch && (data.top = dh - o.maxHeight), data.width || data.height || data.left || !data.top ? data.width || data.height || data.top || !data.left || (data.left = null) : data.top = null, data
            },
            _proportionallyResize: function () {
                if (this._proportionallyResizeElements.length) {
                    var i, j, borders, paddings, prel, element = this.helper || this.element;
                    for (i = 0; i < this._proportionallyResizeElements.length; i++) {
                        if (prel = this._proportionallyResizeElements[i], !this.borderDif)
                            for (this.borderDif = [], borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")], paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")], j = 0; j < borders.length; j++) this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                        prel.css({
                            height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
                            width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
                        })
                    }
                }
            },
            _renderProxy: function () {
                var el = this.element,
                    o = this.options;
                this.elementOffset = el.offset(), this._helper ? (this.helper = this.helper || $("<div style='overflow:hidden;'></div>"), this.helper.addClass(this._helper).css({
                    width: this.element.outerWidth() - 1,
                    height: this.element.outerHeight() - 1,
                    position: "absolute",
                    left: this.elementOffset.left + "px",
                    top: this.elementOffset.top + "px",
                    zIndex: ++o.zIndex
                }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element
            },
            _change: {
                e: function (event, dx) {
                    return {
                        width: this.originalSize.width + dx
                    }
                },
                w: function (event, dx) {
                    var cs = this.originalSize,
                        sp = this.originalPosition;
                    return {
                        left: sp.left + dx,
                        width: cs.width - dx
                    }
                },
                n: function (event, dx, dy) {
                    var cs = this.originalSize,
                        sp = this.originalPosition;
                    return {
                        top: sp.top + dy,
                        height: cs.height - dy
                    }
                },
                s: function (event, dx, dy) {
                    return {
                        height: this.originalSize.height + dy
                    }
                },
                se: function (event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]))
                },
                sw: function (event, dx, dy) {
                    return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]))
                },
                ne: function (event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]))
                },
                nw: function (event, dx, dy) {
                    return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]))
                }
            },
            _propagate: function (n, event) {
                $.ui.plugin.call(this, n, [event, this.ui()]), "resize" !== n && this._trigger(n, event, this.ui())
            },
            plugins: {},
            ui: function () {
                return {
                    originalElement: this.originalElement,
                    element: this.element,
                    helper: this.helper,
                    position: this.position,
                    size: this.size,
                    originalSize: this.originalSize,
                    originalPosition: this.originalPosition
                }
            }
        }), $.ui.plugin.add("resizable", "animate", {
            stop: function (event) {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    pr = that._proportionallyResizeElements,
                    ista = pr.length && /textarea/i.test(pr[0].nodeName),
                    soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
                    soffsetw = ista ? 0 : that.sizeDiff.width,
                    style = {
                        width: that.size.width - soffsetw,
                        height: that.size.height - soffseth
                    },
                    left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null,
                    top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
                that.element.animate($.extend(style, top && left ? {
                    top: top,
                    left: left
                } : {}), {
                    duration: o.animateDuration,
                    easing: o.animateEasing,
                    step: function () {
                        var data = {
                            width: parseInt(that.element.css("width"), 10),
                            height: parseInt(that.element.css("height"), 10),
                            top: parseInt(that.element.css("top"), 10),
                            left: parseInt(that.element.css("left"), 10)
                        };
                        pr && pr.length && $(pr[0]).css({
                            width: data.width,
                            height: data.height
                        }), that._updateCache(data), that._propagate("resize", event)
                    }
                })
            }
        }), $.ui.plugin.add("resizable", "containment", {
            start: function () {
                var element, p, co, ch, cw, width, height, that = $(this).data("ui-resizable"),
                    o = that.options,
                    el = that.element,
                    oc = o.containment,
                    ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
                ce && (that.containerElement = $(ce), /document/.test(oc) || oc === document ? (that.containerOffset = {
                    left: 0,
                    top: 0
                }, that.containerPosition = {
                    left: 0,
                    top: 0
                }, that.parentData = {
                    element: $(document),
                    left: 0,
                    top: 0,
                    width: $(document).width(),
                    height: $(document).height() || document.body.parentNode.scrollHeight
                }) : (element = $(ce), p = [], $(["Top", "Right", "Left", "Bottom"]).each(function (i, name) {
                    p[i] = num(element.css("padding" + name))
                }), that.containerOffset = element.offset(), that.containerPosition = element.position(), that.containerSize = {
                    height: element.innerHeight() - p[3],
                    width: element.innerWidth() - p[1]
                }, co = that.containerOffset, ch = that.containerSize.height, cw = that.containerSize.width, width = $.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw, height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch, that.parentData = {
                    element: ce,
                    left: co.left,
                    top: co.top,
                    width: width,
                    height: height
                }))
            },
            resize: function (event) {
                var woset, hoset, isParent, isOffsetRelative, that = $(this).data("ui-resizable"),
                    o = that.options,
                    co = that.containerOffset,
                    cp = that.position,
                    pRatio = that._aspectRatio || event.shiftKey,
                    cop = {
                        top: 0,
                        left: 0
                    },
                    ce = that.containerElement;
                ce[0] !== document && /static/.test(ce.css("position")) && (cop = co), cp.left < (that._helper ? co.left : 0) && (that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left), pRatio && (that.size.height = that.size.width / that.aspectRatio), that.position.left = o.helper ? co.left : 0), cp.top < (that._helper ? co.top : 0) && (that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top), pRatio && (that.size.width = that.size.height * that.aspectRatio), that.position.top = that._helper ? co.top : 0), that.offset.left = that.parentData.left + that.position.left, that.offset.top = that.parentData.top + that.position.top, woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width), hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height), isParent = that.containerElement.get(0) === that.element.parent().get(0), isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position")), isParent && isOffsetRelative && (woset -= that.parentData.left), woset + that.size.width >= that.parentData.width && (that.size.width = that.parentData.width - woset, pRatio && (that.size.height = that.size.width / that.aspectRatio)), hoset + that.size.height >= that.parentData.height && (that.size.height = that.parentData.height - hoset, pRatio && (that.size.width = that.size.height * that.aspectRatio))
            },
            stop: function () {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    co = that.containerOffset,
                    cop = that.containerPosition,
                    ce = that.containerElement,
                    helper = $(that.helper),
                    ho = helper.offset(),
                    w = helper.outerWidth() - that.sizeDiff.width,
                    h = helper.outerHeight() - that.sizeDiff.height;
                that._helper && !o.animate && /relative/.test(ce.css("position")) && $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                }), that._helper && !o.animate && /static/.test(ce.css("position")) && $(this).css({
                    left: ho.left - cop.left - co.left,
                    width: w,
                    height: h
                })
            }
        }), $.ui.plugin.add("resizable", "alsoResize", {
            start: function () {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    _store = function (exp) {
                        $(exp).each(function () {
                            var el = $(this);
                            el.data("ui-resizable-alsoresize", {
                                width: parseInt(el.width(), 10),
                                height: parseInt(el.height(), 10),
                                left: parseInt(el.css("left"), 10),
                                top: parseInt(el.css("top"), 10)
                            })
                        })
                    };
                "object" != typeof o.alsoResize || o.alsoResize.parentNode ? _store(o.alsoResize) : o.alsoResize.length ? (o.alsoResize = o.alsoResize[0], _store(o.alsoResize)) : $.each(o.alsoResize, function (exp) {
                    _store(exp)
                })
            },
            resize: function (event, ui) {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    os = that.originalSize,
                    op = that.originalPosition,
                    delta = {
                        height: that.size.height - os.height || 0,
                        width: that.size.width - os.width || 0,
                        top: that.position.top - op.top || 0,
                        left: that.position.left - op.left || 0
                    },
                    _alsoResize = function (exp, c) {
                        $(exp).each(function () {
                            var el = $(this),
                                start = $(this).data("ui-resizable-alsoresize"),
                                style = {},
                                css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                            $.each(css, function (i, prop) {
                                var sum = (start[prop] || 0) + (delta[prop] || 0);
                                sum && sum >= 0 && (style[prop] = sum || null)
                            }), el.css(style)
                        })
                    };
                "object" != typeof o.alsoResize || o.alsoResize.nodeType ? _alsoResize(o.alsoResize) : $.each(o.alsoResize, function (exp, c) {
                    _alsoResize(exp, c)
                })
            },
            stop: function () {
                $(this).removeData("resizable-alsoresize")
            }
        }), $.ui.plugin.add("resizable", "ghost", {
            start: function () {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    cs = that.size;
                that.ghost = that.originalElement.clone(), that.ghost.css({
                    opacity: .25,
                    display: "block",
                    position: "relative",
                    height: cs.height,
                    width: cs.width,
                    margin: 0,
                    left: 0,
                    top: 0
                }).addClass("ui-resizable-ghost").addClass("string" == typeof o.ghost ? o.ghost : ""), that.ghost.appendTo(that.helper)
            },
            resize: function () {
                var that = $(this).data("ui-resizable");
                that.ghost && that.ghost.css({
                    position: "relative",
                    height: that.size.height,
                    width: that.size.width
                })
            },
            stop: function () {
                var that = $(this).data("ui-resizable");
                that.ghost && that.helper && that.helper.get(0).removeChild(that.ghost.get(0))
            }
        }), $.ui.plugin.add("resizable", "grid", {
            resize: function () {
                var that = $(this).data("ui-resizable"),
                    o = that.options,
                    cs = that.size,
                    os = that.originalSize,
                    op = that.originalPosition,
                    a = that.axis,
                    grid = "number" == typeof o.grid ? [o.grid, o.grid] : o.grid,
                    gridX = grid[0] || 1,
                    gridY = grid[1] || 1,
                    ox = Math.round((cs.width - os.width) / gridX) * gridX,
                    oy = Math.round((cs.height - os.height) / gridY) * gridY,
                    newWidth = os.width + ox,
                    newHeight = os.height + oy,
                    isMaxWidth = o.maxWidth && o.maxWidth < newWidth,
                    isMaxHeight = o.maxHeight && o.maxHeight < newHeight,
                    isMinWidth = o.minWidth && o.minWidth > newWidth,
                    isMinHeight = o.minHeight && o.minHeight > newHeight;
                o.grid = grid, isMinWidth && (newWidth += gridX), isMinHeight && (newHeight += gridY), isMaxWidth && (newWidth -= gridX), isMaxHeight && (newHeight -= gridY), /^(se|s|e)$/.test(a) ? (that.size.width = newWidth, that.size.height = newHeight) : /^(ne)$/.test(a) ? (that.size.width = newWidth, that.size.height = newHeight, that.position.top = op.top - oy) : /^(sw)$/.test(a) ? (that.size.width = newWidth, that.size.height = newHeight, that.position.left = op.left - ox) : (that.size.width = newWidth, that.size.height = newHeight, that.position.top = op.top - oy, that.position.left = op.left - ox)
            }
        })
    }(jQuery),
    function ($) {
        $.widget("ui.selectable", $.ui.mouse, {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoRefresh: !0,
                distance: 0,
                filter: "*",
                tolerance: "touch",
                selected: null,
                selecting: null,
                start: null,
                stop: null,
                unselected: null,
                unselecting: null
            },
            _create: function () {
                var selectees, that = this;
                this.element.addClass("ui-selectable"), this.dragged = !1, this.refresh = function () {
                    selectees = $(that.options.filter, that.element[0]), selectees.addClass("ui-selectee"), selectees.each(function () {
                        var $this = $(this),
                            pos = $this.offset();
                        $.data(this, "selectable-item", {
                            element: this,
                            $element: $this,
                            left: pos.left,
                            top: pos.top,
                            right: pos.left + $this.outerWidth(),
                            bottom: pos.top + $this.outerHeight(),
                            startselected: !1,
                            selected: $this.hasClass("ui-selected"),
                            selecting: $this.hasClass("ui-selecting"),
                            unselecting: $this.hasClass("ui-unselecting")
                        })
                    })
                }, this.refresh(), this.selectees = selectees.addClass("ui-selectee"), this._mouseInit(), this.helper = $("<div class='ui-selectable-helper'></div>")
            },
            _destroy: function () {
                this.selectees.removeClass("ui-selectee").removeData("selectable-item"), this.element.removeClass("ui-selectable ui-selectable-disabled"), this._mouseDestroy()
            },
            _mouseStart: function (event) {
                var that = this,
                    options = this.options;
                this.opos = [event.pageX, event.pageY], this.options.disabled || (this.selectees = $(options.filter, this.element[0]), this._trigger("start", event), $(options.appendTo).append(this.helper), this.helper.css({
                    left: event.pageX,
                    top: event.pageY,
                    width: 0,
                    height: 0
                }), options.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
                    var selectee = $.data(this, "selectable-item");
                    selectee.startselected = !0, event.metaKey || event.ctrlKey || (selectee.$element.removeClass("ui-selected"), selectee.selected = !1, selectee.$element.addClass("ui-unselecting"), selectee.unselecting = !0, that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    }))
                }), $(event.target).parents().addBack().each(function () {
                    var doSelect, selectee = $.data(this, "selectable-item");
                    return selectee ? (doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass("ui-selected"), selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting"), selectee.unselecting = !doSelect, selectee.selecting = doSelect, selectee.selected = doSelect, doSelect ? that._trigger("selecting", event, {
                        selecting: selectee.element
                    }) : that._trigger("unselecting", event, {
                        unselecting: selectee.element
                    }), !1) : void 0
                }))
            },
            _mouseDrag: function (event) {
                if (this.dragged = !0, !this.options.disabled) {
                    var tmp, that = this,
                        options = this.options,
                        x1 = this.opos[0],
                        y1 = this.opos[1],
                        x2 = event.pageX,
                        y2 = event.pageY;
                    return x1 > x2 && (tmp = x2, x2 = x1, x1 = tmp), y1 > y2 && (tmp = y2, y2 = y1, y1 = tmp), this.helper.css({
                        left: x1,
                        top: y1,
                        width: x2 - x1,
                        height: y2 - y1
                    }), this.selectees.each(function () {
                        var selectee = $.data(this, "selectable-item"),
                            hit = !1;
                        selectee && selectee.element !== that.element[0] && ("touch" === options.tolerance ? hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) : "fit" === options.tolerance && (hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2), hit ? (selectee.selected && (selectee.$element.removeClass("ui-selected"), selectee.selected = !1), selectee.unselecting && (selectee.$element.removeClass("ui-unselecting"), selectee.unselecting = !1), selectee.selecting || (selectee.$element.addClass("ui-selecting"), selectee.selecting = !0, that._trigger("selecting", event, {
                            selecting: selectee.element
                        }))) : (selectee.selecting && ((event.metaKey || event.ctrlKey) && selectee.startselected ? (selectee.$element.removeClass("ui-selecting"), selectee.selecting = !1, selectee.$element.addClass("ui-selected"), selectee.selected = !0) : (selectee.$element.removeClass("ui-selecting"), selectee.selecting = !1, selectee.startselected && (selectee.$element.addClass("ui-unselecting"), selectee.unselecting = !0), that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        }))), selectee.selected && (event.metaKey || event.ctrlKey || selectee.startselected || (selectee.$element.removeClass("ui-selected"), selectee.selected = !1, selectee.$element.addClass("ui-unselecting"), selectee.unselecting = !0, that._trigger("unselecting", event, {
                            unselecting: selectee.element
                        })))))
                    }), !1
                }
            },
            _mouseStop: function (event) {
                var that = this;
                return this.dragged = !1, $(".ui-unselecting", this.element[0]).each(function () {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-unselecting"), selectee.unselecting = !1, selectee.startselected = !1, that._trigger("unselected", event, {
                        unselected: selectee.element
                    })
                }), $(".ui-selecting", this.element[0]).each(function () {
                    var selectee = $.data(this, "selectable-item");
                    selectee.$element.removeClass("ui-selecting").addClass("ui-selected"), selectee.selecting = !1, selectee.selected = !0, selectee.startselected = !0, that._trigger("selected", event, {
                        selected: selectee.element
                    })
                }), this._trigger("stop", event), this.helper.remove(), !1
            }
        })
    }(jQuery),
    function ($) {
        function isOverAxis(x, reference, size) {
            return x > reference && reference + size > x
        }

        function isFloating(item) {
            return /left|right/.test(item.css("float")) || /inline|table-cell/.test(item.css("display"))
        }
        $.widget("ui.sortable", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "sort",
            ready: !1,
            options: {
                appendTo: "parent",
                axis: !1,
                connectWith: !1,
                containment: !1,
                cursor: "auto",
                cursorAt: !1,
                dropOnEmpty: !0,
                forcePlaceholderSize: !1,
                forceHelperSize: !1,
                grid: !1,
                handle: !1,
                helper: "original",
                items: "> *",
                opacity: !1,
                placeholder: !1,
                revert: !1,
                scroll: !0,
                scrollSensitivity: 20,
                scrollSpeed: 20,
                scope: "default",
                tolerance: "intersect",
                zIndex: 1e3,
                activate: null,
                beforeStop: null,
                change: null,
                deactivate: null,
                out: null,
                over: null,
                receive: null,
                remove: null,
                sort: null,
                start: null,
                stop: null,
                update: null
            },
            _create: function () {
                var o = this.options;
                this.containerCache = {}, this.element.addClass("ui-sortable"), this.refresh(), this.floating = this.items.length ? "x" === o.axis || isFloating(this.items[0].item) : !1, this.offset = this.element.offset(), this._mouseInit(), this.ready = !0
            },
            _destroy: function () {
                this.element.removeClass("ui-sortable ui-sortable-disabled"), this._mouseDestroy();
                for (var i = this.items.length - 1; i >= 0; i--) this.items[i].item.removeData(this.widgetName + "-item");
                return this
            },
            _setOption: function (key, value) {
                "disabled" === key ? (this.options[key] = value, this.widget().toggleClass("ui-sortable-disabled", !!value)) : $.Widget.prototype._setOption.apply(this, arguments)
            },
            _mouseCapture: function (event, overrideHandle) {
                var currentItem = null,
                    validHandle = !1,
                    that = this;
                return this.reverting ? !1 : this.options.disabled || "static" === this.options.type ? !1 : (this._refreshItems(event), $(event.target).parents().each(function () {
                    return $.data(this, that.widgetName + "-item") === that ? (currentItem = $(this), !1) : void 0
                }), $.data(event.target, that.widgetName + "-item") === that && (currentItem = $(event.target)), currentItem && (!this.options.handle || overrideHandle || ($(this.options.handle, currentItem).find("*").addBack().each(function () {
                    this === event.target && (validHandle = !0)
                }), validHandle)) ? (this.currentItem = currentItem, this._removeCurrentsFromItems(), !0) : !1)
            },
            _mouseStart: function (event, overrideHandle, noActivation) {
                var i, body, o = this.options;
                if (this.currentContainer = this, this.refreshPositions(), this.helper = this._createHelper(event), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
                    top: this.offset.top - this.margins.top,
                    left: this.offset.left - this.margins.left
                }, $.extend(this.offset, {
                    click: {
                        left: event.pageX - this.offset.left,
                        top: event.pageY - this.offset.top
                    },
                    parent: this._getParentOffset(),
                    relative: this._getRelativeOffset()
                }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(event), this.originalPageX = event.pageX, this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), this.domPosition = {
                    prev: this.currentItem.prev()[0],
                    parent: this.currentItem.parent()[0]
                }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), o.containment && this._setContainment(), o.cursor && "auto" !== o.cursor && (body = this.document.find("body"), this.storedCursor = body.css("cursor"), body.css("cursor", o.cursor), this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body)), o.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", o.opacity)), o.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", o.zIndex)), this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", event, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !noActivation)
                    for (i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("activate", event, this._uiHash(this));
                return $.ui.ddmanager && ($.ui.ddmanager.current = this), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), this.dragging = !0, this.helper.addClass("ui-sortable-helper"), this._mouseDrag(event), !0
            },
            _mouseDrag: function (event) {
                var i, item, itemElement, intersection, o = this.options,
                    scrolled = !1;
                for (this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== document && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - this.overflowOffset.top < o.scrollSensitivity && (this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - this.overflowOffset.left < o.scrollSensitivity && (this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed)) : (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed)), event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed))), scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), i = this.items.length - 1; i >= 0; i--)
                    if (item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item), intersection && item.instance === this.currentContainer && itemElement !== this.currentItem[0] && this.placeholder[1 === intersection ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && ("semi-dynamic" === this.options.type ? !$.contains(this.element[0], itemElement) : !0)) {
                        if (this.direction = 1 === intersection ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(item)) break;
                        this._rearrange(event, item), this._trigger("change", event, this._uiHash());
                        break
                    }
                return this._contactContainers(event), $.ui.ddmanager && $.ui.ddmanager.drag(this, event), this._trigger("sort", event, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
            },
            _mouseStop: function (event, noPropagation) {
                if (event) {
                    if ($.ui.ddmanager && !this.options.dropBehaviour && $.ui.ddmanager.drop(this, event), this.options.revert) {
                        var that = this,
                            cur = this.placeholder.offset(),
                            axis = this.options.axis,
                            animation = {};
                        axis && "x" !== axis || (animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft)), axis && "y" !== axis || (animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
                            that._clear(event)
                        })
                    } else this._clear(event, noPropagation);
                    return !1
                }
            },
            cancel: function () {
                if (this.dragging) {
                    this._mouseUp({
                        target: null
                    }), "original" === this.options.helper ? this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper") : this.currentItem.show();
                    for (var i = this.containers.length - 1; i >= 0; i--) this.containers[i]._trigger("deactivate", null, this._uiHash(this)), this.containers[i].containerCache.over && (this.containers[i]._trigger("out", null, this._uiHash(this)), this.containers[i].containerCache.over = 0)
                }
                return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), $.extend(this, {
                    helper: null,
                    dragging: !1,
                    reverting: !1,
                    _noFinalSort: null
                }), this.domPosition.prev ? $(this.domPosition.prev).after(this.currentItem) : $(this.domPosition.parent).prepend(this.currentItem)), this
            },
            serialize: function (o) {
                var items = this._getItemsAsjQuery(o && o.connected),
                    str = [];
                return o = o || {}, $(items).each(function () {
                    var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || /(.+)[\-=_](.+)/);
                    res && str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]))
                }), !str.length && o.key && str.push(o.key + "="), str.join("&")
            },
            toArray: function (o) {
                var items = this._getItemsAsjQuery(o && o.connected),
                    ret = [];
                return o = o || {}, items.each(function () {
                    ret.push($(o.item || this).attr(o.attribute || "id") || "")
                }), ret
            },
            _intersectsWith: function (item) {
                var x1 = this.positionAbs.left,
                    x2 = x1 + this.helperProportions.width,
                    y1 = this.positionAbs.top,
                    y2 = y1 + this.helperProportions.height,
                    l = item.left,
                    r = l + item.width,
                    t = item.top,
                    b = t + item.height,
                    dyClick = this.offset.click.top,
                    dxClick = this.offset.click.left,
                    isOverElementHeight = "x" === this.options.axis || y1 + dyClick > t && b > y1 + dyClick,
                    isOverElementWidth = "y" === this.options.axis || x1 + dxClick > l && r > x1 + dxClick,
                    isOverElement = isOverElementHeight && isOverElementWidth;
                return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"] ? isOverElement : l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b
            },
            _intersectsWithPointer: function (item) {
                var isOverElementHeight = "x" === this.options.axis || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                    isOverElementWidth = "y" === this.options.axis || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                    isOverElement = isOverElementHeight && isOverElementWidth,
                    verticalDirection = this._getDragVerticalDirection(),
                    horizontalDirection = this._getDragHorizontalDirection();
                return isOverElement ? this.floating ? horizontalDirection && "right" === horizontalDirection || "down" === verticalDirection ? 2 : 1 : verticalDirection && ("down" === verticalDirection ? 2 : 1) : !1
            },
            _intersectsWithSides: function (item) {
                var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),
                    isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),
                    verticalDirection = this._getDragVerticalDirection(),
                    horizontalDirection = this._getDragHorizontalDirection();
                return this.floating && horizontalDirection ? "right" === horizontalDirection && isOverRightHalf || "left" === horizontalDirection && !isOverRightHalf : verticalDirection && ("down" === verticalDirection && isOverBottomHalf || "up" === verticalDirection && !isOverBottomHalf)
            },
            _getDragVerticalDirection: function () {
                var delta = this.positionAbs.top - this.lastPositionAbs.top;
                return 0 !== delta && (delta > 0 ? "down" : "up")
            },
            _getDragHorizontalDirection: function () {
                var delta = this.positionAbs.left - this.lastPositionAbs.left;
                return 0 !== delta && (delta > 0 ? "right" : "left")
            },
            refresh: function (event) {
                return this._refreshItems(event), this.refreshPositions(), this
            },
            _connectWith: function () {
                var options = this.options;
                return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith
            },
            _getItemsAsjQuery: function (connected) {
                var i, j, cur, inst, items = [],
                    queries = [],
                    connectWith = this._connectWith();
                if (connectWith && connected)
                    for (i = connectWith.length - 1; i >= 0; i--)
                        for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                for (queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
                    options: this.options,
                    item: this.currentItem
                }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), i = queries.length - 1; i >= 0; i--) queries[i][0].each(function () {
                    items.push(this)
                });
                return $(items)
            },
            _removeCurrentsFromItems: function () {
                var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
                this.items = $.grep(this.items, function (item) {
                    for (var j = 0; j < list.length; j++)
                        if (list[j] === item.item[0]) return !1;
                    return !0
                })
            },
            _refreshItems: function (event) {
                this.items = [], this.containers = [this];
                var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items,
                    queries = [
                        [$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {
                            item: this.currentItem
                        }) : $(this.options.items, this.element), this]
                    ],
                    connectWith = this._connectWith();
                if (connectWith && this.ready)
                    for (i = connectWith.length - 1; i >= 0; i--)
                        for (cur = $(connectWith[i]), j = cur.length - 1; j >= 0; j--) inst = $.data(cur[j], this.widgetFullName), inst && inst !== this && !inst.options.disabled && (queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {
                            item: this.currentItem
                        }) : $(inst.options.items, inst.element), inst]), this.containers.push(inst));
                for (i = queries.length - 1; i >= 0; i--)
                    for (targetData = queries[i][1], _queries = queries[i][0], j = 0, queriesLength = _queries.length; queriesLength > j; j++) item = $(_queries[j]), item.data(this.widgetName + "-item", targetData), items.push({
                        item: item,
                        instance: targetData,
                        width: 0,
                        height: 0,
                        left: 0,
                        top: 0
                    })
            },
            refreshPositions: function (fast) {
                this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset());
                var i, item, t, p;
                for (i = this.items.length - 1; i >= 0; i--) item = this.items[i], item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0] || (t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item, fast || (item.width = t.outerWidth(), item.height = t.outerHeight()), p = t.offset(), item.left = p.left, item.top = p.top);
                if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
                else
                    for (i = this.containers.length - 1; i >= 0; i--) p = this.containers[i].element.offset(), this.containers[i].containerCache.left = p.left, this.containers[i].containerCache.top = p.top, this.containers[i].containerCache.width = this.containers[i].element.outerWidth(), this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                return this
            },
            _createPlaceholder: function (that) {
                that = that || this;
                var className, o = that.options;
                o.placeholder && o.placeholder.constructor !== String || (className = o.placeholder, o.placeholder = {
                    element: function () {
                        var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                            element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
                        return "tr" === nodeName ? that.currentItem.children().each(function () {
                            $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element)
                        }) : "img" === nodeName && element.attr("src", that.currentItem.attr("src")), className || element.css("visibility", "hidden"), element
                    },
                    update: function (container, p) {
                        (!className || o.forcePlaceholderSize) && (p.height() || p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)), p.width() || p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)))
                    }
                }), that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)), that.currentItem.after(that.placeholder), o.placeholder.update(that, that.placeholder)
            },
            _contactContainers: function (event) {
                var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null,
                    innermostIndex = null;
                for (i = this.containers.length - 1; i >= 0; i--)
                    if (!$.contains(this.currentItem[0], this.containers[i].element[0]))
                        if (this._intersectsWith(this.containers[i].containerCache)) {
                            if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) continue;
                            innermostContainer = this.containers[i], innermostIndex = i
                        } else this.containers[i].containerCache.over && (this.containers[i]._trigger("out", event, this._uiHash(this)), this.containers[i].containerCache.over = 0);
                if (innermostContainer)
                    if (1 === this.containers.length) this.containers[innermostIndex].containerCache.over || (this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), this.containers[innermostIndex].containerCache.over = 1);
                    else {
                        for (dist = 1e4, itemWithLeastDistance = null, floating = innermostContainer.floating || isFloating(this.currentItem), posProperty = floating ? "left" : "top", sizeProperty = floating ? "width" : "height", base = this.positionAbs[posProperty] + this.offset.click[posProperty], j = this.items.length - 1; j >= 0; j--) $.contains(this.containers[innermostIndex].element[0], this.items[j].item[0]) && this.items[j].item[0] !== this.currentItem[0] && (!floating || isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) && (cur = this.items[j].item.offset()[posProperty], nearBottom = !1, Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base) && (nearBottom = !0, cur += this.items[j][sizeProperty]), Math.abs(cur - base) < dist && (dist = Math.abs(cur - base), itemWithLeastDistance = this.items[j], this.direction = nearBottom ? "up" : "down"));
                        if (!itemWithLeastDistance && !this.options.dropOnEmpty) return;
                        if (this.currentContainer === this.containers[innermostIndex]) return;
                        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, !0) : this._rearrange(event, null, this.containers[innermostIndex].element, !0), this._trigger("change", event, this._uiHash()), this.containers[innermostIndex]._trigger("change", event, this._uiHash(this)), this.currentContainer = this.containers[innermostIndex], this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[innermostIndex]._trigger("over", event, this._uiHash(this)), this.containers[innermostIndex].containerCache.over = 1
                    }
            },
            _createHelper: function (event) {
                var o = this.options,
                    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : "clone" === o.helper ? this.currentItem.clone() : this.currentItem;
                return helper.parents("body").length || $("parent" !== o.appendTo ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]), helper[0] === this.currentItem[0] && (this._storedCSS = {
                    width: this.currentItem[0].style.width,
                    height: this.currentItem[0].style.height,
                    position: this.currentItem.css("position"),
                    top: this.currentItem.css("top"),
                    left: this.currentItem.css("left")
                }), (!helper[0].style.width || o.forceHelperSize) && helper.width(this.currentItem.width()), (!helper[0].style.height || o.forceHelperSize) && helper.height(this.currentItem.height()), helper
            },
            _adjustOffsetFromHelper: function (obj) {
                "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {
                    left: +obj[0],
                    top: +obj[1] || 0
                }), "left" in obj && (this.offset.click.left = obj.left + this.margins.left), "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), "top" in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top)
            },
            _getParentOffset: function () {
                this.offsetParent = this.helper.offsetParent();
                var po = this.offsetParent.offset();
                return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), po.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                    top: 0,
                    left: 0
                }), {
                    top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                    left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                }
            },
            _getRelativeOffset: function () {
                if ("relative" === this.cssPosition) {
                    var p = this.currentItem.position();
                    return {
                        top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                        left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                    }
                }
                return {
                    top: 0,
                    left: 0
                }
            },
            _cacheMargins: function () {
                this.margins = {
                    left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
                    top: parseInt(this.currentItem.css("marginTop"), 10) || 0
                }
            },
            _cacheHelperProportions: function () {
                this.helperProportions = {
                    width: this.helper.outerWidth(),
                    height: this.helper.outerHeight()
                }
            },
            _setContainment: function () {
                var ce, co, over, o = this.options;
                "parent" === o.containment && (o.containment = this.helper[0].parentNode), ("document" === o.containment || "window" === o.containment) && (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $("document" === o.containment ? document : window).width() - this.helperProportions.width - this.margins.left, ($("document" === o.containment ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(o.containment) || (ce = $(o.containment)[0], co = $(o.containment).offset(), over = "hidden" !== $(ce).css("overflow"), this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
            },
            _convertPositionTo: function (d, pos) {
                pos || (pos = this.position);
                var mod = "absolute" === d ? 1 : -1,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                return {
                    top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                    left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
                }
            },
            _generatePosition: function (event) {
                var top, left, o = this.options,
                    pageX = event.pageX,
                    pageY = event.pageY,
                    scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
                    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
                return "relative" !== this.cssPosition || this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (event.pageX - this.offset.click.left < this.containment[0] && (pageX = this.containment[0] + this.offset.click.left), event.pageY - this.offset.click.top < this.containment[1] && (pageY = this.containment[1] + this.offset.click.top), event.pageX - this.offset.click.left > this.containment[2] && (pageX = this.containment[2] + this.offset.click.left), event.pageY - this.offset.click.top > this.containment[3] && (pageY = this.containment[3] + this.offset.click.top)), o.grid && (top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1], pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top, left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0], pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), {
                    top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                    left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
                }
            },
            _rearrange: function (event, i, a, hardRefresh) {
                a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? i.item[0] : i.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
                var counter = this.counter;
                this._delay(function () {
                    counter === this.counter && this.refreshPositions(!hardRefresh)
                })
            },
            _clear: function (event, noPropagation) {
                this.reverting = !1;
                var i, delayedTriggers = [];
                if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
                    for (i in this._storedCSS)("auto" === this._storedCSS[i] || "static" === this._storedCSS[i]) && (this._storedCSS[i] = "");
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")
                } else this.currentItem.show();
                for (this.fromOutside && !noPropagation && delayedTriggers.push(function (event) {
                    this._trigger("receive", event, this._uiHash(this.fromOutside))
                }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || noPropagation || delayedTriggers.push(function (event) {
                    this._trigger("update", event, this._uiHash())
                }), this !== this.currentContainer && (noPropagation || (delayedTriggers.push(function (event) {
                    this._trigger("remove", event, this._uiHash())
                }), delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("receive", event, this._uiHash(this))
                    }
                }.call(this, this.currentContainer)), delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("update", event, this._uiHash(this))
                    }
                }.call(this, this.currentContainer)))), i = this.containers.length - 1; i >= 0; i--) noPropagation || delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("deactivate", event, this._uiHash(this))
                    }
                }.call(this, this.containers[i])), this.containers[i].containerCache.over && (delayedTriggers.push(function (c) {
                    return function (event) {
                        c._trigger("out", event, this._uiHash(this))
                    }
                }.call(this, this.containers[i])), this.containers[i].containerCache.over = 0);
                if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, this.cancelHelperRemoval) {
                    if (!noPropagation) {
                        for (this._trigger("beforeStop", event, this._uiHash()), i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                        this._trigger("stop", event, this._uiHash())
                    }
                    return this.fromOutside = !1, !1
                }
                if (noPropagation || this._trigger("beforeStop", event, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null, !noPropagation) {
                    for (i = 0; i < delayedTriggers.length; i++) delayedTriggers[i].call(this, event);
                    this._trigger("stop", event, this._uiHash())
                }
                return this.fromOutside = !1, !0
            },
            _trigger: function () {
                $.Widget.prototype._trigger.apply(this, arguments) === !1 && this.cancel()
            },
            _uiHash: function (_inst) {
                var inst = _inst || this;
                return {
                    helper: inst.helper,
                    placeholder: inst.placeholder || $([]),
                    position: inst.position,
                    originalPosition: inst.originalPosition,
                    offset: inst.positionAbs,
                    item: inst.currentItem,
                    sender: _inst ? _inst.element : null
                }
            }
        })
    }(jQuery),
    function ($, undefined) {
        var dataSpace = "ui-effects-";
        $.effects = {
                effect: {}
            },
            /*!
             * jQuery Color Animations v2.1.2
             * https://github.com/jquery/jquery-color
             *
             * Copyright 2013 jQuery Foundation and other contributors
             * Released under the MIT license.
             * http://jquery.org/license
             *
             * Date: Wed Jan 16 08:47:09 2013 -0600
             */
            function (jQuery, undefined) {
                function clamp(value, prop, allowEmpty) {
                    var type = propTypes[prop.type] || {};
                    return null == value ? allowEmpty || !prop.def ? null : prop.def : (value = type.floor ? ~~value : parseFloat(value), isNaN(value) ? prop.def : type.mod ? (value + type.mod) % type.mod : 0 > value ? 0 : type.max < value ? type.max : value)
                }

                function stringParse(string) {
                    var inst = color(),
                        rgba = inst._rgba = [];
                    return string = string.toLowerCase(), each(stringParsers, function (i, parser) {
                        var parsed, match = parser.re.exec(string),
                            values = match && parser.parse(match),
                            spaceName = parser.space || "rgba";
                        return values ? (parsed = inst[spaceName](values), inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache], rgba = inst._rgba = parsed._rgba, !1) : void 0
                    }), rgba.length ? ("0,0,0,0" === rgba.join() && jQuery.extend(rgba, colors.transparent), inst) : colors[string]
                }

                function hue2rgb(p, q, h) {
                    return h = (h + 1) % 1, 1 > 6 * h ? p + (q - p) * h * 6 : 1 > 2 * h ? q : 2 > 3 * h ? p + (q - p) * (2 / 3 - h) * 6 : p
                }
                var colors, stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
                    rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
                    stringParsers = [{
                        re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        parse: function (execResult) {
                            return [execResult[1], execResult[2], execResult[3], execResult[4]]
                        }
                    }, {
                        re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        parse: function (execResult) {
                            return [2.55 * execResult[1], 2.55 * execResult[2], 2.55 * execResult[3], execResult[4]]
                        }
                    }, {
                        re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
                        parse: function (execResult) {
                            return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)]
                        }
                    }, {
                        re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
                        parse: function (execResult) {
                            return [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)]
                        }
                    }, {
                        re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
                        space: "hsla",
                        parse: function (execResult) {
                            return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]]
                        }
                    }],
                    color = jQuery.Color = function (color, green, blue, alpha) {
                        return new jQuery.Color.fn.parse(color, green, blue, alpha)
                    },
                    spaces = {
                        rgba: {
                            props: {
                                red: {
                                    idx: 0,
                                    type: "byte"
                                },
                                green: {
                                    idx: 1,
                                    type: "byte"
                                },
                                blue: {
                                    idx: 2,
                                    type: "byte"
                                }
                            }
                        },
                        hsla: {
                            props: {
                                hue: {
                                    idx: 0,
                                    type: "degrees"
                                },
                                saturation: {
                                    idx: 1,
                                    type: "percent"
                                },
                                lightness: {
                                    idx: 2,
                                    type: "percent"
                                }
                            }
                        }
                    },
                    propTypes = {
                        "byte": {
                            floor: !0,
                            max: 255
                        },
                        percent: {
                            max: 1
                        },
                        degrees: {
                            mod: 360,
                            floor: !0
                        }
                    },
                    support = color.support = {},
                    supportElem = jQuery("<p>")[0],
                    each = jQuery.each;
                supportElem.style.cssText = "background-color:rgba(1,1,1,.5)", support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1, each(spaces, function (spaceName, space) {
                    space.cache = "_" + spaceName, space.props.alpha = {
                        idx: 3,
                        type: "percent",
                        def: 1
                    }
                }), color.fn = jQuery.extend(color.prototype, {
                    parse: function (red, green, blue, alpha) {
                        if (red === undefined) return this._rgba = [null, null, null, null], this;
                        (red.jquery || red.nodeType) && (red = jQuery(red).css(green), green = undefined);
                        var inst = this,
                            type = jQuery.type(red),
                            rgba = this._rgba = [];
                        return green !== undefined && (red = [red, green, blue, alpha], type = "array"), "string" === type ? this.parse(stringParse(red) || colors._default) : "array" === type ? (each(spaces.rgba.props, function (key, prop) {
                            rgba[prop.idx] = clamp(red[prop.idx], prop)
                        }), this) : "object" === type ? (red instanceof color ? each(spaces, function (spaceName, space) {
                            red[space.cache] && (inst[space.cache] = red[space.cache].slice())
                        }) : each(spaces, function (spaceName, space) {
                            var cache = space.cache;
                            each(space.props, function (key, prop) {
                                if (!inst[cache] && space.to) {
                                    if ("alpha" === key || null == red[key]) return;
                                    inst[cache] = space.to(inst._rgba)
                                }
                                inst[cache][prop.idx] = clamp(red[key], prop, !0)
                            }), inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0 && (inst[cache][3] = 1, space.from && (inst._rgba = space.from(inst[cache])))
                        }), this) : void 0
                    },
                    is: function (compare) {
                        var is = color(compare),
                            same = !0,
                            inst = this;
                        return each(spaces, function (_, space) {
                            var localCache, isCache = is[space.cache];
                            return isCache && (localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [], each(space.props, function (_, prop) {
                                return null != isCache[prop.idx] ? same = isCache[prop.idx] === localCache[prop.idx] : void 0
                            })), same
                        }), same
                    },
                    _space: function () {
                        var used = [],
                            inst = this;
                        return each(spaces, function (spaceName, space) {
                            inst[space.cache] && used.push(spaceName)
                        }), used.pop()
                    },
                    transition: function (other, distance) {
                        var end = color(other),
                            spaceName = end._space(),
                            space = spaces[spaceName],
                            startColor = 0 === this.alpha() ? color("transparent") : this,
                            start = startColor[space.cache] || space.to(startColor._rgba),
                            result = start.slice();
                        return end = end[space.cache], each(space.props, function (key, prop) {
                            var index = prop.idx,
                                startValue = start[index],
                                endValue = end[index],
                                type = propTypes[prop.type] || {};
                            null !== endValue && (null === startValue ? result[index] = endValue : (type.mod && (endValue - startValue > type.mod / 2 ? startValue += type.mod : startValue - endValue > type.mod / 2 && (startValue -= type.mod)), result[index] = clamp((endValue - startValue) * distance + startValue, prop)))
                        }), this[spaceName](result)
                    },
                    blend: function (opaque) {
                        if (1 === this._rgba[3]) return this;
                        var rgb = this._rgba.slice(),
                            a = rgb.pop(),
                            blend = color(opaque)._rgba;
                        return color(jQuery.map(rgb, function (v, i) {
                            return (1 - a) * blend[i] + a * v
                        }))
                    },
                    toRgbaString: function () {
                        var prefix = "rgba(",
                            rgba = jQuery.map(this._rgba, function (v, i) {
                                return null == v ? i > 2 ? 1 : 0 : v
                            });
                        return 1 === rgba[3] && (rgba.pop(), prefix = "rgb("), prefix + rgba.join() + ")"
                    },
                    toHslaString: function () {
                        var prefix = "hsla(",
                            hsla = jQuery.map(this.hsla(), function (v, i) {
                                return null == v && (v = i > 2 ? 1 : 0), i && 3 > i && (v = Math.round(100 * v) + "%"), v
                            });
                        return 1 === hsla[3] && (hsla.pop(), prefix = "hsl("), prefix + hsla.join() + ")"
                    },
                    toHexString: function (includeAlpha) {
                        var rgba = this._rgba.slice(),
                            alpha = rgba.pop();
                        return includeAlpha && rgba.push(~~(255 * alpha)), "#" + jQuery.map(rgba, function (v) {
                            return v = (v || 0).toString(16), 1 === v.length ? "0" + v : v
                        }).join("")
                    },
                    toString: function () {
                        return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
                    }
                }), color.fn.parse.prototype = color.fn, spaces.hsla.to = function (rgba) {
                    if (null == rgba[0] || null == rgba[1] || null == rgba[2]) return [null, null, null, rgba[3]];
                    var h, s, r = rgba[0] / 255,
                        g = rgba[1] / 255,
                        b = rgba[2] / 255,
                        a = rgba[3],
                        max = Math.max(r, g, b),
                        min = Math.min(r, g, b),
                        diff = max - min,
                        add = max + min,
                        l = .5 * add;
                    return h = min === max ? 0 : r === max ? 60 * (g - b) / diff + 360 : g === max ? 60 * (b - r) / diff + 120 : 60 * (r - g) / diff + 240, s = 0 === diff ? 0 : .5 >= l ? diff / add : diff / (2 - add), [Math.round(h) % 360, s, l, null == a ? 1 : a]
                }, spaces.hsla.from = function (hsla) {
                    if (null == hsla[0] || null == hsla[1] || null == hsla[2]) return [null, null, null, hsla[3]];
                    var h = hsla[0] / 360,
                        s = hsla[1],
                        l = hsla[2],
                        a = hsla[3],
                        q = .5 >= l ? l * (1 + s) : l + s - l * s,
                        p = 2 * l - q;
                    return [Math.round(255 * hue2rgb(p, q, h + 1 / 3)), Math.round(255 * hue2rgb(p, q, h)), Math.round(255 * hue2rgb(p, q, h - 1 / 3)), a]
                }, each(spaces, function (spaceName, space) {
                    var props = space.props,
                        cache = space.cache,
                        to = space.to,
                        from = space.from;
                    color.fn[spaceName] = function (value) {
                        if (to && !this[cache] && (this[cache] = to(this._rgba)), value === undefined) return this[cache].slice();
                        var ret, type = jQuery.type(value),
                            arr = "array" === type || "object" === type ? value : arguments,
                            local = this[cache].slice();
                        return each(props, function (key, prop) {
                            var val = arr["object" === type ? key : prop.idx];
                            null == val && (val = local[prop.idx]), local[prop.idx] = clamp(val, prop)
                        }), from ? (ret = color(from(local)), ret[cache] = local, ret) : color(local)
                    }, each(props, function (key, prop) {
                        color.fn[key] || (color.fn[key] = function (value) {
                            var match, vtype = jQuery.type(value),
                                fn = "alpha" === key ? this._hsla ? "hsla" : "rgba" : spaceName,
                                local = this[fn](),
                                cur = local[prop.idx];
                            return "undefined" === vtype ? cur : ("function" === vtype && (value = value.call(this, cur), vtype = jQuery.type(value)), null == value && prop.empty ? this : ("string" === vtype && (match = rplusequals.exec(value), match && (value = cur + parseFloat(match[2]) * ("+" === match[1] ? 1 : -1))), local[prop.idx] = value, this[fn](local)))
                        })
                    })
                }), color.hook = function (hook) {
                    var hooks = hook.split(" ");
                    each(hooks, function (i, hook) {
                        jQuery.cssHooks[hook] = {
                            set: function (elem, value) {
                                var parsed, curElem, backgroundColor = "";
                                if ("transparent" !== value && ("string" !== jQuery.type(value) || (parsed = stringParse(value)))) {
                                    if (value = color(parsed || value), !support.rgba && 1 !== value._rgba[3]) {
                                        for (curElem = "backgroundColor" === hook ? elem.parentNode : elem;
                                            ("" === backgroundColor || "transparent" === backgroundColor) && curElem && curElem.style;) try {
                                            backgroundColor = jQuery.css(curElem, "backgroundColor"), curElem = curElem.parentNode
                                        } catch (e) {}
                                        value = value.blend(backgroundColor && "transparent" !== backgroundColor ? backgroundColor : "_default")
                                    }
                                    value = value.toRgbaString()
                                }
                                try {
                                    elem.style[hook] = value
                                } catch (e) {}
                            }
                        }, jQuery.fx.step[hook] = function (fx) {
                            fx.colorInit || (fx.start = color(fx.elem, hook), fx.end = color(fx.end), fx.colorInit = !0), jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos))
                        }
                    })
                }, color.hook(stepHooks), jQuery.cssHooks.borderColor = {
                    expand: function (value) {
                        var expanded = {};
                        return each(["Top", "Right", "Bottom", "Left"], function (i, part) {
                            expanded["border" + part + "Color"] = value
                        }), expanded
                    }
                }, colors = jQuery.Color.names = {
                    aqua: "#00ffff",
                    black: "#000000",
                    blue: "#0000ff",
                    fuchsia: "#ff00ff",
                    gray: "#808080",
                    green: "#008000",
                    lime: "#00ff00",
                    maroon: "#800000",
                    navy: "#000080",
                    olive: "#808000",
                    purple: "#800080",
                    red: "#ff0000",
                    silver: "#c0c0c0",
                    teal: "#008080",
                    white: "#ffffff",
                    yellow: "#ffff00",
                    transparent: [null, null, null, 0],
                    _default: "#ffffff"
                }
            }(jQuery),
            function () {
                function getElementStyles(elem) {
                    var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,
                        styles = {};
                    if (style && style.length && style[0] && style[style[0]])
                        for (len = style.length; len--;) key = style[len], "string" == typeof style[key] && (styles[$.camelCase(key)] = style[key]);
                    else
                        for (key in style) "string" == typeof style[key] && (styles[key] = style[key]);
                    return styles
                }

                function styleDifference(oldStyle, newStyle) {
                    var name, value, diff = {};
                    for (name in newStyle) value = newStyle[name], oldStyle[name] !== value && (shorthandStyles[name] || ($.fx.step[name] || !isNaN(parseFloat(value))) && (diff[name] = value));
                    return diff
                }
                var classAnimationActions = ["add", "remove", "toggle"],
                    shorthandStyles = {
                        border: 1,
                        borderBottom: 1,
                        borderColor: 1,
                        borderLeft: 1,
                        borderRight: 1,
                        borderTop: 1,
                        borderWidth: 1,
                        margin: 1,
                        padding: 1
                    };
                $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (_, prop) {
                    $.fx.step[prop] = function (fx) {
                        ("none" !== fx.end && !fx.setAttr || 1 === fx.pos && !fx.setAttr) && (jQuery.style(fx.elem, prop, fx.end), fx.setAttr = !0)
                    }
                }), $.fn.addBack || ($.fn.addBack = function (selector) {
                    return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
                }), $.effects.animateClass = function (value, duration, easing, callback) {
                    var o = $.speed(duration, easing, callback);
                    return this.queue(function () {
                        var applyClassChange, animated = $(this),
                            baseClass = animated.attr("class") || "",
                            allAnimations = o.children ? animated.find("*").addBack() : animated;
                        allAnimations = allAnimations.map(function () {
                            var el = $(this);
                            return {
                                el: el,
                                start: getElementStyles(this)
                            }
                        }), applyClassChange = function () {
                            $.each(classAnimationActions, function (i, action) {
                                value[action] && animated[action + "Class"](value[action])
                            })
                        }, applyClassChange(), allAnimations = allAnimations.map(function () {
                            return this.end = getElementStyles(this.el[0]), this.diff = styleDifference(this.start, this.end), this
                        }), animated.attr("class", baseClass), allAnimations = allAnimations.map(function () {
                            var styleInfo = this,
                                dfd = $.Deferred(),
                                opts = $.extend({}, o, {
                                    queue: !1,
                                    complete: function () {
                                        dfd.resolve(styleInfo)
                                    }
                                });
                            return this.el.animate(this.diff, opts), dfd.promise()
                        }), $.when.apply($, allAnimations.get()).done(function () {
                            applyClassChange(), $.each(arguments, function () {
                                var el = this.el;
                                $.each(this.diff, function (key) {
                                    el.css(key, "")
                                })
                            }), o.complete.call(animated[0])
                        })
                    })
                }, $.fn.extend({
                    addClass: function (orig) {
                        return function (classNames, speed, easing, callback) {
                            return speed ? $.effects.animateClass.call(this, {
                                add: classNames
                            }, speed, easing, callback) : orig.apply(this, arguments)
                        }
                    }($.fn.addClass),
                    removeClass: function (orig) {
                        return function (classNames, speed, easing, callback) {
                            return arguments.length > 1 ? $.effects.animateClass.call(this, {
                                remove: classNames
                            }, speed, easing, callback) : orig.apply(this, arguments)
                        }
                    }($.fn.removeClass),
                    toggleClass: function (orig) {
                        return function (classNames, force, speed, easing, callback) {
                            return "boolean" == typeof force || force === undefined ? speed ? $.effects.animateClass.call(this, force ? {
                                add: classNames
                            } : {
                                remove: classNames
                            }, speed, easing, callback) : orig.apply(this, arguments) : $.effects.animateClass.call(this, {
                                toggle: classNames
                            }, force, speed, easing)
                        }
                    }($.fn.toggleClass),
                    switchClass: function (remove, add, speed, easing, callback) {
                        return $.effects.animateClass.call(this, {
                            add: add,
                            remove: remove
                        }, speed, easing, callback)
                    }
                })
            }(),
            function () {
                function _normalizeArguments(effect, options, speed, callback) {
                    return $.isPlainObject(effect) && (options = effect, effect = effect.effect), effect = {
                        effect: effect
                    }, null == options && (options = {}), $.isFunction(options) && (callback = options, speed = null, options = {}), ("number" == typeof options || $.fx.speeds[options]) && (callback = speed, speed = options, options = {}), $.isFunction(speed) && (callback = speed, speed = null), options && $.extend(effect, options), speed = speed || options.duration, effect.duration = $.fx.off ? 0 : "number" == typeof speed ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default, effect.complete = callback || options.complete, effect
                }

                function standardAnimationOption(option) {
                    return !option || "number" == typeof option || $.fx.speeds[option] ? !0 : "string" != typeof option || $.effects.effect[option] ? $.isFunction(option) ? !0 : "object" != typeof option || option.effect ? !1 : !0 : !0
                }
                $.extend($.effects, {
                    version: "1.10.3",
                    save: function (element, set) {
                        for (var i = 0; i < set.length; i++) null !== set [i] && element.data(dataSpace + set [i], element[0].style[set [i]])
                    },
                    restore: function (element, set) {
                        var val, i;
                        for (i = 0; i < set.length; i++) null !== set [i] && (val = element.data(dataSpace + set [i]), val === undefined && (val = ""), element.css(set [i], val))
                    },
                    setMode: function (el, mode) {
                        return "toggle" === mode && (mode = el.is(":hidden") ? "show" : "hide"), mode
                    },
                    getBaseline: function (origin, original) {
                        var y, x;
                        switch (origin[0]) {
                        case "top":
                            y = 0;
                            break;
                        case "middle":
                            y = .5;
                            break;
                        case "bottom":
                            y = 1;
                            break;
                        default:
                            y = origin[0] / original.height
                        }
                        switch (origin[1]) {
                        case "left":
                            x = 0;
                            break;
                        case "center":
                            x = .5;
                            break;
                        case "right":
                            x = 1;
                            break;
                        default:
                            x = origin[1] / original.width
                        }
                        return {
                            x: x,
                            y: y
                        }
                    },
                    createWrapper: function (element) {
                        if (element.parent().is(".ui-effects-wrapper")) return element.parent();
                        var props = {
                                width: element.outerWidth(!0),
                                height: element.outerHeight(!0),
                                "float": element.css("float")
                            },
                            wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                                fontSize: "100%",
                                background: "transparent",
                                border: "none",
                                margin: 0,
                                padding: 0
                            }),
                            size = {
                                width: element.width(),
                                height: element.height()
                            },
                            active = document.activeElement;
                        try {
                            active.id
                        } catch (e) {
                            active = document.body
                        }
                        return element.wrap(wrapper), (element[0] === active || $.contains(element[0], active)) && $(active).focus(), wrapper = element.parent(), "static" === element.css("position") ? (wrapper.css({
                            position: "relative"
                        }), element.css({
                            position: "relative"
                        })) : ($.extend(props, {
                            position: element.css("position"),
                            zIndex: element.css("z-index")
                        }), $.each(["top", "left", "bottom", "right"], function (i, pos) {
                            props[pos] = element.css(pos), isNaN(parseInt(props[pos], 10)) && (props[pos] = "auto")
                        }), element.css({
                            position: "relative",
                            top: 0,
                            left: 0,
                            right: "auto",
                            bottom: "auto"
                        })), element.css(size), wrapper.css(props).show()
                    },
                    removeWrapper: function (element) {
                        var active = document.activeElement;
                        return element.parent().is(".ui-effects-wrapper") && (element.parent().replaceWith(element), (element[0] === active || $.contains(element[0], active)) && $(active).focus()), element
                    },
                    setTransition: function (element, list, factor, value) {
                        return value = value || {}, $.each(list, function (i, x) {
                            var unit = element.cssUnit(x);
                            unit[0] > 0 && (value[x] = unit[0] * factor + unit[1])
                        }), value
                    }
                }), $.fn.extend({
                    effect: function () {
                        function run(next) {
                            function done() {
                                $.isFunction(complete) && complete.call(elem[0]), $.isFunction(next) && next()
                            }
                            var elem = $(this),
                                complete = args.complete,
                                mode = args.mode;
                            (elem.is(":hidden") ? "hide" === mode : "show" === mode) ? (elem[mode](), done()) : effectMethod.call(elem[0], args, done)
                        }
                        var args = _normalizeArguments.apply(this, arguments),
                            mode = args.mode,
                            queue = args.queue,
                            effectMethod = $.effects.effect[args.effect];
                        return $.fx.off || !effectMethod ? mode ? this[mode](args.duration, args.complete) : this.each(function () {
                            args.complete && args.complete.call(this)
                        }) : queue === !1 ? this.each(run) : this.queue(queue || "fx", run)
                    },
                    show: function (orig) {
                        return function (option) {
                            if (standardAnimationOption(option)) return orig.apply(this, arguments);
                            var args = _normalizeArguments.apply(this, arguments);
                            return args.mode = "show", this.effect.call(this, args)
                        }
                    }($.fn.show),
                    hide: function (orig) {
                        return function (option) {
                            if (standardAnimationOption(option)) return orig.apply(this, arguments);
                            var args = _normalizeArguments.apply(this, arguments);
                            return args.mode = "hide", this.effect.call(this, args)
                        }
                    }($.fn.hide),
                    toggle: function (orig) {
                        return function (option) {
                            if (standardAnimationOption(option) || "boolean" == typeof option) return orig.apply(this, arguments);
                            var args = _normalizeArguments.apply(this, arguments);
                            return args.mode = "toggle", this.effect.call(this, args)
                        }
                    }($.fn.toggle),
                    cssUnit: function (key) {
                        var style = this.css(key),
                            val = [];
                        return $.each(["em", "px", "%", "pt"], function (i, unit) {
                            style.indexOf(unit) > 0 && (val = [parseFloat(style), unit])
                        }), val
                    }
                })
            }(),
            function () {
                var baseEasings = {};
                $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (i, name) {
                    baseEasings[name] = function (p) {
                        return Math.pow(p, i + 2)
                    }
                }), $.extend(baseEasings, {
                    Sine: function (p) {
                        return 1 - Math.cos(p * Math.PI / 2)
                    },
                    Circ: function (p) {
                        return 1 - Math.sqrt(1 - p * p)
                    },
                    Elastic: function (p) {
                        return 0 === p || 1 === p ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin((80 * (p - 1) - 7.5) * Math.PI / 15)
                    },
                    Back: function (p) {
                        return p * p * (3 * p - 2)
                    },
                    Bounce: function (p) {
                        for (var pow2, bounce = 4; p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11;);
                        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((3 * pow2 - 2) / 22 - p, 2)
                    }
                }), $.each(baseEasings, function (name, easeIn) {
                    $.easing["easeIn" + name] = easeIn, $.easing["easeOut" + name] = function (p) {
                        return 1 - easeIn(1 - p)
                    }, $.easing["easeInOut" + name] = function (p) {
                        return .5 > p ? easeIn(2 * p) / 2 : 1 - easeIn(-2 * p + 2) / 2
                    }
                })
            }()
    }(jQuery),
    function ($) {
        var uid = 0,
            hideProps = {},
            showProps = {};
        hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide", showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth = "show", $.widget("ui.accordion", {
            version: "1.10.3",
            options: {
                active: 0,
                animate: {},
                collapsible: !1,
                event: "click",
                header: "> li > :first-child,> :not(li):even",
                heightStyle: "auto",
                icons: {
                    activeHeader: "ui-icon-triangle-1-s",
                    header: "ui-icon-triangle-1-e"
                },
                activate: null,
                beforeActivate: null
            },
            _create: function () {
                var options = this.options;
                this.prevShow = this.prevHide = $(), this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist"), options.collapsible || options.active !== !1 && null != options.active || (options.active = 0), this._processPanels(), options.active < 0 && (options.active += this.headers.length), this._refresh()
            },
            _getCreateEventData: function () {
                return {
                    header: this.active,
                    panel: this.active.length ? this.active.next() : $(),
                    content: this.active.length ? this.active.next() : $()
                }
            },
            _createIcons: function () {
                var icons = this.options.icons;
                icons && ($("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers), this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader), this.headers.addClass("ui-accordion-icons"))
            },
            _destroyIcons: function () {
                this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()
            },
            _destroy: function () {
                var contents;
                this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"), this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function () {
                    /^ui-accordion/.test(this.id) && this.removeAttribute("id")
                }), this._destroyIcons(), contents = this.headers.next().css("display", "").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function () {
                    /^ui-accordion/.test(this.id) && this.removeAttribute("id")
                }), "content" !== this.options.heightStyle && contents.css("height", "")
            },
            _setOption: function (key, value) {
                return "active" === key ? void this._activate(value) : ("event" === key && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(value)), this._super(key, value), "collapsible" !== key || value || this.options.active !== !1 || this._activate(0), "icons" === key && (this._destroyIcons(), value && this._createIcons()), void("disabled" === key && this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value)))
            },
            _keydown: function (event) {
                if (!event.altKey && !event.ctrlKey) {
                    var keyCode = $.ui.keyCode,
                        length = this.headers.length,
                        currentIndex = this.headers.index(event.target),
                        toFocus = !1;
                    switch (event.keyCode) {
                    case keyCode.RIGHT:
                    case keyCode.DOWN:
                        toFocus = this.headers[(currentIndex + 1) % length];
                        break;
                    case keyCode.LEFT:
                    case keyCode.UP:
                        toFocus = this.headers[(currentIndex - 1 + length) % length];
                        break;
                    case keyCode.SPACE:
                    case keyCode.ENTER:
                        this._eventHandler(event);
                        break;
                    case keyCode.HOME:
                        toFocus = this.headers[0];
                        break;
                    case keyCode.END:
                        toFocus = this.headers[length - 1]
                    }
                    toFocus && ($(event.target).attr("tabIndex", -1), $(toFocus).attr("tabIndex", 0), toFocus.focus(), event.preventDefault())
                }
            },
            _panelKeyDown: function (event) {
                event.keyCode === $.ui.keyCode.UP && event.ctrlKey && $(event.currentTarget).prev().focus()
            },
            refresh: function () {
                var options = this.options;
                this._processPanels(), options.active === !1 && options.collapsible === !0 || !this.headers.length ? (options.active = !1, this.active = $()) : options.active === !1 ? this._activate(0) : this.active.length && !$.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (options.active = !1, this.active = $()) : this._activate(Math.max(0, options.active - 1)) : options.active = this.headers.index(this.active), this._destroyIcons(), this._refresh()
            },
            _processPanels: function () {
                this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all"), this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide()
            },
            _refresh: function () {
                var maxHeight, options = this.options,
                    heightStyle = options.heightStyle,
                    parent = this.element.parent(),
                    accordionId = this.accordionId = "ui-accordion-" + (this.element.attr("id") || ++uid);
                this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all"), this.active.next().addClass("ui-accordion-content-active").show(), this.headers.attr("role", "tab").each(function (i) {
                    var header = $(this),
                        headerId = header.attr("id"),
                        panel = header.next(),
                        panelId = panel.attr("id");
                    headerId || (headerId = accordionId + "-header-" + i, header.attr("id", headerId)), panelId || (panelId = accordionId + "-panel-" + i, panel.attr("id", panelId)), header.attr("aria-controls", panelId), panel.attr("aria-labelledby", headerId)
                }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
                    "aria-selected": "false",
                    tabIndex: -1
                }).next().attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                }).hide(), this.active.length ? this.active.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                }).next().attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(options.event), "fill" === heightStyle ? (maxHeight = parent.height(), this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");
                    "absolute" !== position && "fixed" !== position && (maxHeight -= elem.outerHeight(!0))
                }), this.headers.each(function () {
                    maxHeight -= $(this).outerHeight(!0)
                }), this.headers.next().each(function () {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()))
                }).css("overflow", "auto")) : "auto" === heightStyle && (maxHeight = 0, this.headers.next().each(function () {
                    maxHeight = Math.max(maxHeight, $(this).css("height", "").height())
                }).height(maxHeight))
            },
            _activate: function (index) {
                var active = this._findActive(index)[0];
                active !== this.active[0] && (active = active || this.active[0], this._eventHandler({
                    target: active,
                    currentTarget: active,
                    preventDefault: $.noop
                }))
            },
            _findActive: function (selector) {
                return "number" == typeof selector ? this.headers.eq(selector) : $()
            },
            _setupEvents: function (event) {
                var events = {
                    keydown: "_keydown"
                };
                event && $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler"
                }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, events), this._on(this.headers.next(), {
                    keydown: "_panelKeyDown"
                }), this._hoverable(this.headers), this._focusable(this.headers)
            },
            _eventHandler: function (event) {
                var options = this.options,
                    active = this.active,
                    clicked = $(event.currentTarget),
                    clickedIsActive = clicked[0] === active[0],
                    collapsing = clickedIsActive && options.collapsible,
                    toShow = collapsing ? $() : clicked.next(),
                    toHide = active.next(),
                    eventData = {
                        oldHeader: active,
                        oldPanel: toHide,
                        newHeader: collapsing ? $() : clicked,
                        newPanel: toShow
                    };
                event.preventDefault(), clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === !1 || (options.active = collapsing ? !1 : this.headers.index(clicked), this.active = clickedIsActive ? $() : clicked, this._toggle(eventData), active.removeClass("ui-accordion-header-active ui-state-active"), options.icons && active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header), clickedIsActive || (clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"), options.icons && clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader), clicked.next().addClass("ui-accordion-content-active")))
            },
            _toggle: function (data) {
                var toShow = data.newPanel,
                    toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
                this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = toShow, this.prevHide = toHide, this.options.animate ? this._animate(toShow, toHide, data) : (toHide.hide(), toShow.show(), this._toggleComplete(data)), toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                }), toHide.prev().attr("aria-selected", "false"), toShow.length && toHide.length ? toHide.prev().attr("tabIndex", -1) : toShow.length && this.headers.filter(function () {
                    return 0 === $(this).attr("tabIndex")
                }).attr("tabIndex", -1), toShow.attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                }).prev().attr({
                    "aria-selected": "true",
                    tabIndex: 0
                })
            },
            _animate: function (toShow, toHide, data) {
                var total, easing, duration, that = this,
                    adjust = 0,
                    down = toShow.length && (!toHide.length || toShow.index() < toHide.index()),
                    animate = this.options.animate || {},
                    options = down && animate.down || animate,
                    complete = function () {
                        that._toggleComplete(data)
                    };
                return "number" == typeof options && (duration = options), "string" == typeof options && (easing = options), easing = easing || options.easing || animate.easing, duration = duration || options.duration || animate.duration, toHide.length ? toShow.length ? (total = toShow.show().outerHeight(), toHide.animate(hideProps, {
                    duration: duration,
                    easing: easing,
                    step: function (now, fx) {
                        fx.now = Math.round(now)
                    }
                }), void toShow.hide().animate(showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function (now, fx) {
                        fx.now = Math.round(now), "height" !== fx.prop ? adjust += fx.now : "content" !== that.options.heightStyle && (fx.now = Math.round(total - toHide.outerHeight() - adjust), adjust = 0)
                    }
                })) : toHide.animate(hideProps, duration, easing, complete) : toShow.animate(showProps, duration, easing, complete)
            },
            _toggleComplete: function (data) {
                var toHide = data.oldPanel;
                toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"), toHide.length && (toHide.parent()[0].className = toHide.parent()[0].className), this._trigger("activate", null, data)
            }
        })
    }(jQuery),
    function ($) {
        var requestIndex = 0;
        $.widget("ui.autocomplete", {
            version: "1.10.3",
            defaultElement: "<input>",
            options: {
                appendTo: null,
                autoFocus: !1,
                delay: 300,
                minLength: 1,
                position: {
                    my: "left top",
                    at: "left bottom",
                    collision: "none"
                },
                source: null,
                change: null,
                close: null,
                focus: null,
                open: null,
                response: null,
                search: null,
                select: null
            },
            pending: 0,
            _create: function () {
                var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(),
                    isTextarea = "textarea" === nodeName,
                    isInput = "input" === nodeName;
                this.isMultiLine = isTextarea ? !0 : isInput ? !1 : this.element.prop("isContentEditable"), this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"], this.isNewMenu = !0, this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off"), this._on(this.element, {
                    keydown: function (event) {
                        if (this.element.prop("readOnly")) return suppressKeyPress = !0, suppressInput = !0, void(suppressKeyPressRepeat = !0);
                        suppressKeyPress = !1, suppressInput = !1, suppressKeyPressRepeat = !1;
                        var keyCode = $.ui.keyCode;
                        switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = !0, this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = !0, this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = !0, this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = !0, this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            this.menu.active && (suppressKeyPress = !0, event.preventDefault(), this.menu.select(event));
                            break;
                        case keyCode.TAB:
                            this.menu.active && this.menu.select(event);
                            break;
                        case keyCode.ESCAPE:
                            this.menu.element.is(":visible") && (this._value(this.term), this.close(event), event.preventDefault());
                            break;
                        default:
                            suppressKeyPressRepeat = !0, this._searchTimeout(event)
                        }
                    },
                    keypress: function (event) {
                        if (suppressKeyPress) return suppressKeyPress = !1, void((!this.isMultiLine || this.menu.element.is(":visible")) && event.preventDefault());
                        if (!suppressKeyPressRepeat) {
                            var keyCode = $.ui.keyCode;
                            switch (event.keyCode) {
                            case keyCode.PAGE_UP:
                                this._move("previousPage", event);
                                break;
                            case keyCode.PAGE_DOWN:
                                this._move("nextPage", event);
                                break;
                            case keyCode.UP:
                                this._keyEvent("previous", event);
                                break;
                            case keyCode.DOWN:
                                this._keyEvent("next", event)
                            }
                        }
                    },
                    input: function (event) {
                        return suppressInput ? (suppressInput = !1, void event.preventDefault()) : void this._searchTimeout(event)
                    },
                    focus: function () {
                        this.selectedItem = null, this.previous = this._value()
                    },
                    blur: function (event) {
                        return this.cancelBlur ? void delete this.cancelBlur : (clearTimeout(this.searching), this.close(event), void this._change(event))
                    }
                }), this._initSource(), this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({
                    role: null
                }).hide().data("ui-menu"), this._on(this.menu.element, {
                    mousedown: function (event) {
                        event.preventDefault(), this.cancelBlur = !0, this._delay(function () {
                            delete this.cancelBlur
                        });
                        var menuElement = this.menu.element[0];
                        $(event.target).closest(".ui-menu-item").length || this._delay(function () {
                            var that = this;
                            this.document.one("mousedown", function (event) {
                                event.target === that.element[0] || event.target === menuElement || $.contains(menuElement, event.target) || that.close()
                            })
                        })
                    },
                    menufocus: function (event, ui) {
                        if (this.isNewMenu && (this.isNewMenu = !1, event.originalEvent && /^mouse/.test(event.originalEvent.type))) return this.menu.blur(), void this.document.one("mousemove", function () {
                            $(event.target).trigger(event.originalEvent)
                        });
                        var item = ui.item.data("ui-autocomplete-item");
                        !1 !== this._trigger("focus", event, {
                            item: item
                        }) ? event.originalEvent && /^key/.test(event.originalEvent.type) && this._value(item.value) : this.liveRegion.text(item.value)
                    },
                    menuselect: function (event, ui) {
                        var item = ui.item.data("ui-autocomplete-item"),
                            previous = this.previous;
                        this.element[0] !== this.document[0].activeElement && (this.element.focus(), this.previous = previous, this._delay(function () {
                            this.previous = previous, this.selectedItem = item
                        })), !1 !== this._trigger("select", event, {
                            item: item
                        }) && this._value(item.value), this.term = this._value(), this.close(event), this.selectedItem = item
                    }
                }), this.liveRegion = $("<span>", {
                    role: "status",
                    "aria-live": "polite"
                }).addClass("ui-helper-hidden-accessible").insertBefore(this.element), this._on(this.window, {
                    beforeunload: function () {
                        this.element.removeAttr("autocomplete")
                    }
                })
            },
            _destroy: function () {
                clearTimeout(this.searching), this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
            },
            _setOption: function (key, value) {
                this._super(key, value), "source" === key && this._initSource(), "appendTo" === key && this.menu.element.appendTo(this._appendTo()), "disabled" === key && value && this.xhr && this.xhr.abort()
            },
            _appendTo: function () {
                var element = this.options.appendTo;
                return element && (element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0)), element || (element = this.element.closest(".ui-front")), element.length || (element = this.document[0].body), element
            },
            _initSource: function () {
                var array, url, that = this;
                $.isArray(this.options.source) ? (array = this.options.source, this.source = function (request, response) {
                    response($.ui.autocomplete.filter(array, request.term))
                }) : "string" == typeof this.options.source ? (url = this.options.source, this.source = function (request, response) {
                    that.xhr && that.xhr.abort(), that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function (data) {
                            response(data)
                        },
                        error: function () {
                            response([])
                        }
                    })
                }) : this.source = this.options.source
            },
            _searchTimeout: function (event) {
                clearTimeout(this.searching), this.searching = this._delay(function () {
                    this.term !== this._value() && (this.selectedItem = null, this.search(null, event))
                }, this.options.delay)
            },
            search: function (value, event) {
                return value = null != value ? value : this._value(), this.term = this._value(), value.length < this.options.minLength ? this.close(event) : this._trigger("search", event) !== !1 ? this._search(value) : void 0
            },
            _search: function (value) {
                this.pending++, this.element.addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
                    term: value
                }, this._response())
            },
            _response: function () {
                var that = this,
                    index = ++requestIndex;
                return function (content) {
                    index === requestIndex && that.__response(content), that.pending--, that.pending || that.element.removeClass("ui-autocomplete-loading")
                }
            },
            __response: function (content) {
                content && (content = this._normalize(content)), this._trigger("response", null, {
                    content: content
                }), !this.options.disabled && content && content.length && !this.cancelSearch ? (this._suggest(content), this._trigger("open")) : this._close()
            },
            close: function (event) {
                this.cancelSearch = !0, this._close(event)
            },
            _close: function (event) {
                this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", event))
            },
            _change: function (event) {
                this.previous !== this._value() && this._trigger("change", event, {
                    item: this.selectedItem
                })
            },
            _normalize: function (items) {
                return items.length && items[0].label && items[0].value ? items : $.map(items, function (item) {
                    return "string" == typeof item ? {
                        label: item,
                        value: item
                    } : $.extend({
                        label: item.label || item.value,
                        value: item.value || item.label
                    }, item)
                })
            },
            _suggest: function (items) {
                var ul = this.menu.element.empty();
                this._renderMenu(ul, items), this.isNewMenu = !0, this.menu.refresh(), ul.show(), this._resizeMenu(), ul.position($.extend({
                    of: this.element
                }, this.options.position)), this.options.autoFocus && this.menu.next()
            },
            _resizeMenu: function () {
                var ul = this.menu.element;
                ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()))
            },
            _renderMenu: function (ul, items) {
                var that = this;
                $.each(items, function (index, item) {
                    that._renderItemData(ul, item)
                })
            },
            _renderItemData: function (ul, item) {
                return this._renderItem(ul, item).data("ui-autocomplete-item", item)
            },
            _renderItem: function (ul, item) {
                return $("<li>").append($("<a>").text(item.label)).appendTo(ul)
            },
            _move: function (direction, event) {
                return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction) ? (this._value(this.term), void this.menu.blur()) : void this.menu[direction](event) : void this.search(null, event)
            },
            widget: function () {
                return this.menu.element
            },
            _value: function () {
                return this.valueMethod.apply(this.element, arguments)
            },
            _keyEvent: function (keyEvent, event) {
                (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(keyEvent, event), event.preventDefault())
            }
        }), $.extend($.ui.autocomplete, {
            escapeRegex: function (value) {
                return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
            },
            filter: function (array, term) {
                var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
                return $.grep(array, function (value) {
                    return matcher.test(value.label || value.value || value)
                })
            }
        }), $.widget("ui.autocomplete", $.ui.autocomplete, {
            options: {
                messages: {
                    noResults: "No search results.",
                    results: function (amount) {
                        return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
                    }
                }
            },
            __response: function (content) {
                var message;
                this._superApply(arguments), this.options.disabled || this.cancelSearch || (message = content && content.length ? this.options.messages.results(content.length) : this.options.messages.noResults, this.liveRegion.text(message))
            }
        })
    }(jQuery),
    function ($) {
        var lastActive, startXPos, startYPos, clickDragged, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
            stateClasses = "ui-state-hover ui-state-active ",
            typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
            formResetHandler = function () {
                var form = $(this);
                setTimeout(function () {
                    form.find(":ui-button").button("refresh")
                }, 1)
            },
            radioGroup = function (radio) {
                var name = radio.name,
                    form = radio.form,
                    radios = $([]);
                return name && (name = name.replace(/'/g, "\\'"), radios = form ? $(form).find("[name='" + name + "']") : $("[name='" + name + "']", radio.ownerDocument).filter(function () {
                    return !this.form
                })), radios
            };
        $.widget("ui.button", {
            version: "1.10.3",
            defaultElement: "<button>",
            options: {
                disabled: null,
                text: !0,
                label: null,
                icons: {
                    primary: null,
                    secondary: null
                }
            },
            _create: function () {
                this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler), "boolean" != typeof this.options.disabled ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
                var that = this,
                    options = this.options,
                    toggleButton = "checkbox" === this.type || "radio" === this.type,
                    activeClass = toggleButton ? "" : "ui-state-active",
                    focusClass = "ui-state-focus";
                null === options.label && (options.label = "input" === this.type ? this.buttonElement.val() : this.buttonElement.html()), this._hoverable(this.buttonElement), this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function () {
                    options.disabled || this === lastActive && $(this).addClass("ui-state-active")
                }).bind("mouseleave" + this.eventNamespace, function () {
                    options.disabled || $(this).removeClass(activeClass)
                }).bind("click" + this.eventNamespace, function (event) {
                    options.disabled && (event.preventDefault(), event.stopImmediatePropagation())
                }), this.element.bind("focus" + this.eventNamespace, function () {
                    that.buttonElement.addClass(focusClass)
                }).bind("blur" + this.eventNamespace, function () {
                    that.buttonElement.removeClass(focusClass)
                }), toggleButton && (this.element.bind("change" + this.eventNamespace, function () {
                    clickDragged || that.refresh()
                }), this.buttonElement.bind("mousedown" + this.eventNamespace, function (event) {
                    options.disabled || (clickDragged = !1, startXPos = event.pageX, startYPos = event.pageY)
                }).bind("mouseup" + this.eventNamespace, function (event) {
                    options.disabled || (startXPos !== event.pageX || startYPos !== event.pageY) && (clickDragged = !0)
                })), "checkbox" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                    return options.disabled || clickDragged ? !1 : void 0
                }) : "radio" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function () {
                    if (options.disabled || clickDragged) return !1;
                    $(this).addClass("ui-state-active"), that.buttonElement.attr("aria-pressed", "true");
                    var radio = that.element[0];
                    radioGroup(radio).not(radio).map(function () {
                        return $(this).button("widget")[0]
                    }).removeClass("ui-state-active").attr("aria-pressed", "false")
                }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function () {
                    return options.disabled ? !1 : ($(this).addClass("ui-state-active"), lastActive = this, void that.document.one("mouseup", function () {
                        lastActive = null
                    }))
                }).bind("mouseup" + this.eventNamespace, function () {
                    return options.disabled ? !1 : void $(this).removeClass("ui-state-active")
                }).bind("keydown" + this.eventNamespace, function (event) {
                    return options.disabled ? !1 : void((event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) && $(this).addClass("ui-state-active"))
                }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function () {
                    $(this).removeClass("ui-state-active")
                }), this.buttonElement.is("a") && this.buttonElement.keyup(function (event) {
                    event.keyCode === $.ui.keyCode.SPACE && $(this).click()
                })), this._setOption("disabled", options.disabled), this._resetButton()
            },
            _determineButtonType: function () {
                var ancestor, labelSelector, checked;
                this.type = this.element.is("[type=checkbox]") ? "checkbox" : this.element.is("[type=radio]") ? "radio" : this.element.is("input") ? "input" : "button", "checkbox" === this.type || "radio" === this.type ? (ancestor = this.element.parents().last(), labelSelector = "label[for='" + this.element.attr("id") + "']", this.buttonElement = ancestor.find(labelSelector), this.buttonElement.length || (ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings(), this.buttonElement = ancestor.filter(labelSelector), this.buttonElement.length || (this.buttonElement = ancestor.find(labelSelector))), this.element.addClass("ui-helper-hidden-accessible"), checked = this.element.is(":checked"), checked && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", checked)) : this.buttonElement = this.element
            },
            widget: function () {
                return this.buttonElement
            },
            _destroy: function () {
                this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(baseClasses + " " + stateClasses + " " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), this.hasTitle || this.buttonElement.removeAttr("title")
            },
            _setOption: function (key, value) {
                return this._super(key, value), "disabled" === key ? void(value ? this.element.prop("disabled", !0) : this.element.prop("disabled", !1)) : void this._resetButton()
            },
            refresh: function () {
                var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
                isDisabled !== this.options.disabled && this._setOption("disabled", isDisabled), "radio" === this.type ? radioGroup(this.element[0]).each(function () {
                    $(this).is(":checked") ? $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false")
                }) : "checkbox" === this.type && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"))
            },
            _resetButton: function () {
                if ("input" === this.type) return void(this.options.label && this.element.val(this.options.label));
                var buttonElement = this.buttonElement.removeClass(typeClasses),
                    buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(),
                    icons = this.options.icons,
                    multipleIcons = icons.primary && icons.secondary,
                    buttonClasses = [];
                icons.primary || icons.secondary ? (this.options.text && buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary")), icons.primary && buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>"), icons.secondary && buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>"), this.options.text || (buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only"), this.hasTitle || buttonElement.attr("title", $.trim(buttonText)))) : buttonClasses.push("ui-button-text-only"), buttonElement.addClass(buttonClasses.join(" "))
            }
        }), $.widget("ui.buttonset", {
            version: "1.10.3",
            options: {
                items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
            },
            _create: function () {
                this.element.addClass("ui-buttonset")
            },
            _init: function () {
                this.refresh()
            },
            _setOption: function (key, value) {
                "disabled" === key && this.buttons.button("option", key, value), this._super(key, value)
            },
            refresh: function () {
                var rtl = "rtl" === this.element.css("direction");
                this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function () {
                    return $(this).button("widget")[0]
                }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end()
            },
            _destroy: function () {
                this.element.removeClass("ui-buttonset"), this.buttons.map(function () {
                    return $(this).button("widget")[0]
                }).removeClass("ui-corner-left ui-corner-right").end().button("destroy")
            }
        })
    }(jQuery),
    function ($, undefined) {
        function Datepicker() {
            this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
                closeText: "Done",
                prevText: "Prev",
                nextText: "Next",
                currentText: "Today",
                monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                weekHeader: "Wk",
                dateFormat: "mm/dd/yy",
                firstDay: 0,
                isRTL: !1,
                showMonthAfterYear: !1,
                yearSuffix: ""
            }, this._defaults = {
                showOn: "focus",
                showAnim: "fadeIn",
                showOptions: {},
                defaultDate: null,
                appendText: "",
                buttonText: "...",
                buttonImage: "",
                buttonImageOnly: !1,
                hideIfNoPrevNext: !1,
                navigationAsDateFormat: !1,
                gotoCurrent: !1,
                changeMonth: !1,
                changeYear: !1,
                yearRange: "c-10:c+10",
                showOtherMonths: !1,
                selectOtherMonths: !1,
                showWeek: !1,
                calculateWeek: this.iso8601Week,
                shortYearCutoff: "+10",
                minDate: null,
                maxDate: null,
                duration: "fast",
                beforeShowDay: null,
                beforeShow: null,
                onSelect: null,
                onChangeMonthYear: null,
                onClose: null,
                numberOfMonths: 1,
                showCurrentAtPos: 0,
                stepMonths: 1,
                stepBigMonths: 12,
                altField: "",
                altFormat: "",
                constrainInput: !0,
                showButtonPanel: !1,
                autoSize: !1,
                disabled: !1
            }, $.extend(this._defaults, this.regional[""]), this.dpDiv = bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
        }

        function bindHover(dpDiv) {
            var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
            return dpDiv.delegate(selector, "mouseout", function () {
                $(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && $(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && $(this).removeClass("ui-datepicker-next-hover")
            }).delegate(selector, "mouseover", function () {
                $.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) || ($(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), $(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && $(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && $(this).addClass("ui-datepicker-next-hover"))
            })
        }

        function extendRemove(target, props) {
            $.extend(target, props);
            for (var name in props) null == props[name] && (target[name] = props[name]);
            return target
        }
        $.extend($.ui, {
            datepicker: {
                version: "1.10.3"
            }
        });
        var instActive, PROP_NAME = "datepicker";
        $.extend(Datepicker.prototype, {
            markerClassName: "hasDatepicker",
            maxRows: 4,
            _widgetDatepicker: function () {
                return this.dpDiv
            },
            setDefaults: function (settings) {
                return extendRemove(this._defaults, settings || {}), this
            },
            _attachDatepicker: function (target, settings) {
                var nodeName, inline, inst;
                nodeName = target.nodeName.toLowerCase(), inline = "div" === nodeName || "span" === nodeName, target.id || (this.uuid += 1, target.id = "dp" + this.uuid), inst = this._newInst($(target), inline), inst.settings = $.extend({}, settings || {}), "input" === nodeName ? this._connectDatepicker(target, inst) : inline && this._inlineDatepicker(target, inst)
            },
            _newInst: function (target, inline) {
                var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
                return {
                    id: id,
                    input: target,
                    selectedDay: 0,
                    selectedMonth: 0,
                    selectedYear: 0,
                    drawMonth: 0,
                    drawYear: 0,
                    inline: inline,
                    dpDiv: inline ? bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
                }
            },
            _connectDatepicker: function (target, inst) {
                var input = $(target);
                inst.append = $([]), inst.trigger = $([]), input.hasClass(this.markerClassName) || (this._attachments(input, inst), input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp), this._autoSize(inst), $.data(target, PROP_NAME, inst), inst.settings.disabled && this._disableDatepicker(target))
            },
            _attachments: function (input, inst) {
                var showOn, buttonText, buttonImage, appendText = this._get(inst, "appendText"),
                    isRTL = this._get(inst, "isRTL");
                inst.append && inst.append.remove(), appendText && (inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>"), input[isRTL ? "before" : "after"](inst.append)), input.unbind("focus", this._showDatepicker), inst.trigger && inst.trigger.remove(), showOn = this._get(inst, "showOn"), ("focus" === showOn || "both" === showOn) && input.focus(this._showDatepicker), ("button" === showOn || "both" === showOn) && (buttonText = this._get(inst, "buttonText"), buttonImage = this._get(inst, "buttonImage"), inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button type='button'></button>").addClass(this._triggerClass).html(buttonImage ? $("<img/>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : buttonText)), input[isRTL ? "before" : "after"](inst.trigger), inst.trigger.click(function () {
                    return $.datepicker._datepickerShowing && $.datepicker._lastInput === input[0] ? $.datepicker._hideDatepicker() : $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0] ? ($.datepicker._hideDatepicker(), $.datepicker._showDatepicker(input[0])) : $.datepicker._showDatepicker(input[0]), !1
                }))
            },
            _autoSize: function (inst) {
                if (this._get(inst, "autoSize") && !inst.inline) {
                    var findMax, max, maxI, i, date = new Date(2009, 11, 20),
                        dateFormat = this._get(inst, "dateFormat");
                    dateFormat.match(/[DM]/) && (findMax = function (names) {
                        for (max = 0, maxI = 0, i = 0; i < names.length; i++) names[i].length > max && (max = names[i].length, maxI = i);
                        return maxI
                    }, date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort"))), date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - date.getDay())), inst.input.attr("size", this._formatDate(inst, date).length)
                }
            },
            _inlineDatepicker: function (target, inst) {
                var divSpan = $(target);
                divSpan.hasClass(this.markerClassName) || (divSpan.addClass(this.markerClassName).append(inst.dpDiv), $.data(target, PROP_NAME, inst), this._setDate(inst, this._getDefaultDate(inst), !0), this._updateDatepicker(inst), this._updateAlternate(inst), inst.settings.disabled && this._disableDatepicker(target), inst.dpDiv.css("display", "block"))
            },
            _dialogDatepicker: function (input, date, onSelect, settings, pos) {
                var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
                return inst || (this.uuid += 1, id = "dp" + this.uuid, this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.keydown(this._doKeyDown), $("body").append(this._dialogInput), inst = this._dialogInst = this._newInst(this._dialogInput, !1), inst.settings = {}, $.data(this._dialogInput[0], PROP_NAME, inst)), extendRemove(inst.settings, settings || {}), date = date && date.constructor === Date ? this._formatDate(inst, date) : date, this._dialogInput.val(date), this._pos = pos ? pos.length ? pos : [pos.pageX, pos.pageY] : null, this._pos || (browserWidth = document.documentElement.clientWidth, browserHeight = document.documentElement.clientHeight, scrollX = document.documentElement.scrollLeft || document.body.scrollLeft, scrollY = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), inst.settings.onSelect = onSelect, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), $.blockUI && $.blockUI(this.dpDiv), $.data(this._dialogInput[0], PROP_NAME, inst), this
            },
            _destroyDatepicker: function (target) {
                var nodeName, $target = $(target),
                    inst = $.data(target, PROP_NAME);
                $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), $.removeData(target, PROP_NAME), "input" === nodeName ? (inst.append.remove(), inst.trigger.remove(), $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp)) : ("div" === nodeName || "span" === nodeName) && $target.removeClass(this.markerClassName).empty())
            },
            _enableDatepicker: function (target) {
                var nodeName, inline, $target = $(target),
                    inst = $.data(target, PROP_NAME);
                $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), "input" === nodeName ? (target.disabled = !1, inst.trigger.filter("button").each(function () {
                    this.disabled = !1
                }).end().filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                })) : ("div" === nodeName || "span" === nodeName) && (inline = $target.children("." + this._inlineClass), inline.children().removeClass("ui-state-disabled"), inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = $.map(this._disabledInputs, function (value) {
                    return value === target ? null : value
                }))
            },
            _disableDatepicker: function (target) {
                var nodeName, inline, $target = $(target),
                    inst = $.data(target, PROP_NAME);
                $target.hasClass(this.markerClassName) && (nodeName = target.nodeName.toLowerCase(), "input" === nodeName ? (target.disabled = !0, inst.trigger.filter("button").each(function () {
                    this.disabled = !0
                }).end().filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                })) : ("div" === nodeName || "span" === nodeName) && (inline = $target.children("." + this._inlineClass), inline.children().addClass("ui-state-disabled"), inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = $.map(this._disabledInputs, function (value) {
                    return value === target ? null : value
                }), this._disabledInputs[this._disabledInputs.length] = target)
            },
            _isDisabledDatepicker: function (target) {
                if (!target) return !1;
                for (var i = 0; i < this._disabledInputs.length; i++)
                    if (this._disabledInputs[i] === target) return !0;
                return !1
            },
            _getInst: function (target) {
                try {
                    return $.data(target, PROP_NAME)
                } catch (err) {
                    throw "Missing instance data for this datepicker"
                }
            },
            _optionDatepicker: function (target, name, value) {
                var settings, date, minDate, maxDate, inst = this._getInst(target);
                return 2 === arguments.length && "string" == typeof name ? "defaults" === name ? $.extend({}, $.datepicker._defaults) : inst ? "all" === name ? $.extend({}, inst.settings) : this._get(inst, name) : null : (settings = name || {}, "string" == typeof name && (settings = {}, settings[name] = value), void(inst && (this._curInst === inst && this._hideDatepicker(), date = this._getDateDatepicker(target, !0), minDate = this._getMinMaxDate(inst, "min"), maxDate = this._getMinMaxDate(inst, "max"), extendRemove(inst.settings, settings), null !== minDate && settings.dateFormat !== undefined && settings.minDate === undefined && (inst.settings.minDate = this._formatDate(inst, minDate)), null !== maxDate && settings.dateFormat !== undefined && settings.maxDate === undefined && (inst.settings.maxDate = this._formatDate(inst, maxDate)), "disabled" in settings && (settings.disabled ? this._disableDatepicker(target) : this._enableDatepicker(target)), this._attachments($(target), inst), this._autoSize(inst), this._setDate(inst, date), this._updateAlternate(inst), this._updateDatepicker(inst))))
            },
            _changeDatepicker: function (target, name, value) {
                this._optionDatepicker(target, name, value)
            },
            _refreshDatepicker: function (target) {
                var inst = this._getInst(target);
                inst && this._updateDatepicker(inst)
            },
            _setDateDatepicker: function (target, date) {
                var inst = this._getInst(target);
                inst && (this._setDate(inst, date), this._updateDatepicker(inst), this._updateAlternate(inst))
            },
            _getDateDatepicker: function (target, noDefault) {
                var inst = this._getInst(target);
                return inst && !inst.inline && this._setDateFromField(inst, noDefault), inst ? this._getDate(inst) : null
            },
            _doKeyDown: function (event) {
                var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target),
                    handled = !0,
                    isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
                if (inst._keyEvent = !0, $.datepicker._datepickerShowing) switch (event.keyCode) {
                case 9:
                    $.datepicker._hideDatepicker(), handled = !1;
                    break;
                case 13:
                    return sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv), sel[0] && $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]), onSelect = $.datepicker._get(inst, "onSelect"), onSelect ? (dateStr = $.datepicker._formatDate(inst), onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst])) : $.datepicker._hideDatepicker(), !1;
                case 27:
                    $.datepicker._hideDatepicker();
                    break;
                case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;
                case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;
                case 35:
                    (event.ctrlKey || event.metaKey) && $.datepicker._clearDate(event.target), handled = event.ctrlKey || event.metaKey;
                    break;
                case 36:
                    (event.ctrlKey || event.metaKey) && $.datepicker._gotoToday(event.target), handled = event.ctrlKey || event.metaKey;
                    break;
                case 37:
                    (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, isRTL ? 1 : -1, "D"), handled = event.ctrlKey || event.metaKey, event.originalEvent.altKey && $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths"), "M");
                    break;
                case 38:
                    (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, -7, "D"), handled = event.ctrlKey || event.metaKey;
                    break;
                case 39:
                    (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, isRTL ? -1 : 1, "D"), handled = event.ctrlKey || event.metaKey, event.originalEvent.altKey && $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths"), "M");
                    break;
                case 40:
                    (event.ctrlKey || event.metaKey) && $.datepicker._adjustDate(event.target, 7, "D"), handled = event.ctrlKey || event.metaKey;
                    break;
                default:
                    handled = !1
                } else 36 === event.keyCode && event.ctrlKey ? $.datepicker._showDatepicker(this) : handled = !1;
                handled && (event.preventDefault(), event.stopPropagation())
            },
            _doKeyPress: function (event) {
                var chars, chr, inst = $.datepicker._getInst(event.target);
                return $.datepicker._get(inst, "constrainInput") ? (chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), chr = String.fromCharCode(null == event.charCode ? event.keyCode : event.charCode), event.ctrlKey || event.metaKey || " " > chr || !chars || chars.indexOf(chr) > -1) : void 0
            },
            _doKeyUp: function (event) {
                var date, inst = $.datepicker._getInst(event.target);
                if (inst.input.val() !== inst.lastVal) try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst)), date && ($.datepicker._setDateFromField(inst), $.datepicker._updateAlternate(inst), $.datepicker._updateDatepicker(inst))
                } catch (err) {}
                return !0
            },
            _showDatepicker: function (input) {
                if (input = input.target || input, "input" !== input.nodeName.toLowerCase() && (input = $("input", input.parentNode)[0]), !$.datepicker._isDisabledDatepicker(input) && $.datepicker._lastInput !== input) {
                    var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
                    inst = $.datepicker._getInst(input), $.datepicker._curInst && $.datepicker._curInst !== inst && ($.datepicker._curInst.dpDiv.stop(!0, !0), inst && $.datepicker._datepickerShowing && $.datepicker._hideDatepicker($.datepicker._curInst.input[0])), beforeShow = $.datepicker._get(inst, "beforeShow"), beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {}, beforeShowSettings !== !1 && (extendRemove(inst.settings, beforeShowSettings), inst.lastVal = null, $.datepicker._lastInput = input, $.datepicker._setDateFromField(inst), $.datepicker._inDialog && (input.value = ""), $.datepicker._pos || ($.datepicker._pos = $.datepicker._findPos(input), $.datepicker._pos[1] += input.offsetHeight), isFixed = !1, $(input).parents().each(function () {
                        return isFixed |= "fixed" === $(this).css("position"), !isFixed
                    }), offset = {
                        left: $.datepicker._pos[0],
                        top: $.datepicker._pos[1]
                    }, $.datepicker._pos = null, inst.dpDiv.empty(), inst.dpDiv.css({
                        position: "absolute",
                        display: "block",
                        top: "-1000px"
                    }), $.datepicker._updateDatepicker(inst), offset = $.datepicker._checkOffset(inst, offset, isFixed), inst.dpDiv.css({
                        position: $.datepicker._inDialog && $.blockUI ? "static" : isFixed ? "fixed" : "absolute",
                        display: "none",
                        left: offset.left + "px",
                        top: offset.top + "px"
                    }), inst.inline || (showAnim = $.datepicker._get(inst, "showAnim"), duration = $.datepicker._get(inst, "duration"), inst.dpDiv.zIndex($(input).zIndex() + 1), $.datepicker._datepickerShowing = !0, $.effects && $.effects.effect[showAnim] ? inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration) : inst.dpDiv[showAnim || "show"](showAnim ? duration : null), $.datepicker._shouldFocusInput(inst) && inst.input.focus(), $.datepicker._curInst = inst))
                }
            },
            _updateDatepicker: function (inst) {
                this.maxRows = 4, instActive = inst, inst.dpDiv.empty().append(this._generateHTML(inst)), this._attachHandlers(inst), inst.dpDiv.find("." + this._dayOverClass + " a").mouseover();
                var origyearshtml, numMonths = this._getNumberOfMonths(inst),
                    cols = numMonths[1],
                    width = 17;
                inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), cols > 1 && inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", width * cols + "em"), inst.dpDiv[(1 !== numMonths[0] || 1 !== numMonths[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst) && inst.input.focus(), inst.yearshtml && (origyearshtml = inst.yearshtml, setTimeout(function () {
                    origyearshtml === inst.yearshtml && inst.yearshtml && inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml), origyearshtml = inst.yearshtml = null
                }, 0))
            },
            _shouldFocusInput: function (inst) {
                return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus")
            },
            _checkOffset: function (inst, offset, isFixed) {
                var dpWidth = inst.dpDiv.outerWidth(),
                    dpHeight = inst.dpDiv.outerHeight(),
                    inputWidth = inst.input ? inst.input.outerWidth() : 0,
                    inputHeight = inst.input ? inst.input.outerHeight() : 0,
                    viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                    viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
                return offset.left -= this._get(inst, "isRTL") ? dpWidth - inputWidth : 0, offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0, offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0, offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0), offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0), offset
            },
            _findPos: function (obj) {
                for (var position, inst = this._getInst(obj), isRTL = this._get(inst, "isRTL"); obj && ("hidden" === obj.type || 1 !== obj.nodeType || $.expr.filters.hidden(obj));) obj = obj[isRTL ? "previousSibling" : "nextSibling"];
                return position = $(obj).offset(), [position.left, position.top]
            },
            _hideDatepicker: function (input) {
                var showAnim, duration, postProcess, onClose, inst = this._curInst;
                !inst || input && inst !== $.data(input, PROP_NAME) || this._datepickerShowing && (showAnim = this._get(inst, "showAnim"), duration = this._get(inst, "duration"), postProcess = function () {
                    $.datepicker._tidyDialog(inst)
                }, $.effects && ($.effects.effect[showAnim] || $.effects[showAnim]) ? inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess) : inst.dpDiv["slideDown" === showAnim ? "slideUp" : "fadeIn" === showAnim ? "fadeOut" : "hide"](showAnim ? duration : null, postProcess), showAnim || postProcess(), this._datepickerShowing = !1, onClose = this._get(inst, "onClose"), onClose && onClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : "", inst]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
                    position: "absolute",
                    left: "0",
                    top: "-100px"
                }), $.blockUI && ($.unblockUI(), $("body").append(this.dpDiv))), this._inDialog = !1)
            },
            _tidyDialog: function (inst) {
                inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")
            },
            _checkExternalClick: function (event) {
                if ($.datepicker._curInst) {
                    var $target = $(event.target),
                        inst = $.datepicker._getInst($target[0]);
                    ($target[0].id !== $.datepicker._mainDivId && 0 === $target.parents("#" + $.datepicker._mainDivId).length && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && (!$.datepicker._inDialog || !$.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) && $.datepicker._hideDatepicker()
                }
            },
            _adjustDate: function (id, offset, period) {
                var target = $(id),
                    inst = this._getInst(target[0]);
                this._isDisabledDatepicker(target[0]) || (this._adjustInstDate(inst, offset + ("M" === period ? this._get(inst, "showCurrentAtPos") : 0), period), this._updateDatepicker(inst))
            },
            _gotoToday: function (id) {
                var date, target = $(id),
                    inst = this._getInst(target[0]);
                this._get(inst, "gotoCurrent") && inst.currentDay ? (inst.selectedDay = inst.currentDay, inst.drawMonth = inst.selectedMonth = inst.currentMonth, inst.drawYear = inst.selectedYear = inst.currentYear) : (date = new Date, inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), inst.drawYear = inst.selectedYear = date.getFullYear()), this._notifyChange(inst), this._adjustDate(target)
            },
            _selectMonthYear: function (id, select, period) {
                var target = $(id),
                    inst = this._getInst(target[0]);
                inst["selected" + ("M" === period ? "Month" : "Year")] = inst["draw" + ("M" === period ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10), this._notifyChange(inst), this._adjustDate(target)
            },
            _selectDay: function (id, month, year, td) {
                var inst, target = $(id);
                $(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0]) || (inst = this._getInst(target[0]), inst.selectedDay = inst.currentDay = $("a", td).html(), inst.selectedMonth = inst.currentMonth = month, inst.selectedYear = inst.currentYear = year, this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear)))
            },
            _clearDate: function (id) {
                var target = $(id);
                this._selectDate(target, "")
            },
            _selectDate: function (id, dateStr) {
                var onSelect, target = $(id),
                    inst = this._getInst(target[0]);
                dateStr = null != dateStr ? dateStr : this._formatDate(inst), inst.input && inst.input.val(dateStr), this._updateAlternate(inst), onSelect = this._get(inst, "onSelect"), onSelect ? onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]) : inst.input && inst.input.trigger("change"), inst.inline ? this._updateDatepicker(inst) : (this._hideDatepicker(), this._lastInput = inst.input[0], "object" != typeof inst.input[0] && inst.input.focus(), this._lastInput = null)
            },
            _updateAlternate: function (inst) {
                var altFormat, date, dateStr, altField = this._get(inst, "altField");
                altField && (altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat"), date = this._getDate(inst), dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst)), $(altField).each(function () {
                    $(this).val(dateStr)
                }))
            },
            noWeekends: function (date) {
                var day = date.getDay();
                return [day > 0 && 6 > day, ""]
            },
            iso8601Week: function (date) {
                var time, checkDate = new Date(date.getTime());
                return checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)), time = checkDate.getTime(), checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1
            },
            parseDate: function (format, value, settings) {
                if (null == format || null == value) throw "Invalid arguments";
                if (value = "object" == typeof value ? value.toString() : value + "", "" === value) return null;
                var iFormat, dim, extra, date, iValue = 0,
                    shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                    shortYearCutoff = "string" != typeof shortYearCutoffTemp ? shortYearCutoffTemp : (new Date).getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10),
                    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                    year = -1,
                    month = -1,
                    day = -1,
                    doy = -1,
                    literal = !1,
                    lookAhead = function (match) {
                        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                        return matches && iFormat++, matches
                    },
                    getNumber = function (match) {
                        var isDoubled = lookAhead(match),
                            size = "@" === match ? 14 : "!" === match ? 20 : "y" === match && isDoubled ? 4 : "o" === match ? 3 : 2,
                            digits = new RegExp("^\\d{1," + size + "}"),
                            num = value.substring(iValue).match(digits);
                        if (!num) throw "Missing number at position " + iValue;
                        return iValue += num[0].length, parseInt(num[0], 10)
                    },
                    getName = function (match, shortNames, longNames) {
                        var index = -1,
                            names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                                return [
                                    [k, v]
                                ]
                            }).sort(function (a, b) {
                                return -(a[1].length - b[1].length)
                            });
                        if ($.each(names, function (i, pair) {
                            var name = pair[1];
                            return value.substr(iValue, name.length).toLowerCase() === name.toLowerCase() ? (index = pair[0], iValue += name.length, !1) : void 0
                        }), -1 !== index) return index + 1;
                        throw "Unknown name at position " + iValue
                    },
                    checkLiteral = function () {
                        if (value.charAt(iValue) !== format.charAt(iFormat)) throw "Unexpected literal at position " + iValue;
                        iValue++
                    };
                for (iFormat = 0; iFormat < format.length; iFormat++)
                    if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? checkLiteral() : literal = !1;
                    else switch (format.charAt(iFormat)) {
                    case "d":
                        day = getNumber("d");
                        break;
                    case "D":
                        getName("D", dayNamesShort, dayNames);
                        break;
                    case "o":
                        doy = getNumber("o");
                        break;
                    case "m":
                        month = getNumber("m");
                        break;
                    case "M":
                        month = getName("M", monthNamesShort, monthNames);
                        break;
                    case "y":
                        year = getNumber("y");
                        break;
                    case "@":
                        date = new Date(getNumber("@")), year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
                        break;
                    case "!":
                        date = new Date((getNumber("!") - this._ticksTo1970) / 1e4), year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
                        break;
                    case "'":
                        lookAhead("'") ? checkLiteral() : literal = !0;
                        break;
                    default:
                        checkLiteral()
                    }
                    if (iValue < value.length && (extra = value.substr(iValue), !/^\s+/.test(extra))) throw "Extra/unparsed characters found in date: " + extra;
                if (-1 === year ? year = (new Date).getFullYear() : 100 > year && (year += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (shortYearCutoff >= year ? 0 : -100)), doy > -1)
                    for (month = 1, day = doy;;) {
                        if (dim = this._getDaysInMonth(year, month - 1), dim >= day) break;
                        month++, day -= dim
                    }
                if (date = this._daylightSavingAdjust(new Date(year, month - 1, day)), date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) throw "Invalid date";
                return date
            },
            ATOM: "yy-mm-dd",
            COOKIE: "D, dd M yy",
            ISO_8601: "yy-mm-dd",
            RFC_822: "D, d M y",
            RFC_850: "DD, dd-M-y",
            RFC_1036: "D, d M y",
            RFC_1123: "D, d M yy",
            RFC_2822: "D, d M yy",
            RSS: "D, d M y",
            TICKS: "!",
            TIMESTAMP: "@",
            W3C: "yy-mm-dd",
            _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
            formatDate: function (format, date, settings) {
                if (!date) return "";
                var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                    lookAhead = function (match) {
                        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                        return matches && iFormat++, matches
                    },
                    formatNumber = function (match, value, len) {
                        var num = "" + value;
                        if (lookAhead(match))
                            for (; num.length < len;) num = "0" + num;
                        return num
                    },
                    formatName = function (match, value, shortNames, longNames) {
                        return lookAhead(match) ? longNames[value] : shortNames[value]
                    },
                    output = "",
                    literal = !1;
                if (date)
                    for (iFormat = 0; iFormat < format.length; iFormat++)
                        if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? output += format.charAt(iFormat) : literal = !1;
                        else switch (format.charAt(iFormat)) {
                        case "d":
                            output += formatNumber("d", date.getDate(), 2);
                            break;
                        case "D":
                            output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                            break;
                        case "o":
                            output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                            break;
                        case "m":
                            output += formatNumber("m", date.getMonth() + 1, 2);
                            break;
                        case "M":
                            output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                            break;
                        case "y":
                            output += lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100;
                            break;
                        case "@":
                            output += date.getTime();
                            break;
                        case "!":
                            output += 1e4 * date.getTime() + this._ticksTo1970;
                            break;
                        case "'":
                            lookAhead("'") ? output += "'" : literal = !0;
                            break;
                        default:
                            output += format.charAt(iFormat)
                        }
                        return output
            },
            _possibleChars: function (format) {
                var iFormat, chars = "",
                    literal = !1,
                    lookAhead = function (match) {
                        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                        return matches && iFormat++, matches
                    };
                for (iFormat = 0; iFormat < format.length; iFormat++)
                    if (literal) "'" !== format.charAt(iFormat) || lookAhead("'") ? chars += format.charAt(iFormat) : literal = !1;
                    else switch (format.charAt(iFormat)) {
                    case "d":
                    case "m":
                    case "y":
                    case "@":
                        chars += "0123456789";
                        break;
                    case "D":
                    case "M":
                        return null;
                    case "'":
                        lookAhead("'") ? chars += "'" : literal = !0;
                        break;
                    default:
                        chars += format.charAt(iFormat)
                    }
                    return chars
            },
            _get: function (inst, name) {
                return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name]
            },
            _setDateFromField: function (inst, noDefault) {
                if (inst.input.val() !== inst.lastVal) {
                    var dateFormat = this._get(inst, "dateFormat"),
                        dates = inst.lastVal = inst.input ? inst.input.val() : null,
                        defaultDate = this._getDefaultDate(inst),
                        date = defaultDate,
                        settings = this._getFormatConfig(inst);
                    try {
                        date = this.parseDate(dateFormat, dates, settings) || defaultDate
                    } catch (event) {
                        dates = noDefault ? "" : dates
                    }
                    inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), inst.drawYear = inst.selectedYear = date.getFullYear(), inst.currentDay = dates ? date.getDate() : 0, inst.currentMonth = dates ? date.getMonth() : 0, inst.currentYear = dates ? date.getFullYear() : 0, this._adjustInstDate(inst)
                }
            },
            _getDefaultDate: function (inst) {
                return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date))
            },
            _determineDate: function (inst, date, defaultDate) {
                var offsetNumeric = function (offset) {
                        var date = new Date;
                        return date.setDate(date.getDate() + offset), date
                    },
                    offsetString = function (offset) {
                        try {
                            return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst))
                        } catch (e) {}
                        for (var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date, year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset); matches;) {
                            switch (matches[2] || "d") {
                            case "d":
                            case "D":
                                day += parseInt(matches[1], 10);
                                break;
                            case "w":
                            case "W":
                                day += 7 * parseInt(matches[1], 10);
                                break;
                            case "m":
                            case "M":
                                month += parseInt(matches[1], 10), day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            case "y":
                            case "Y":
                                year += parseInt(matches[1], 10), day = Math.min(day, $.datepicker._getDaysInMonth(year, month))
                            }
                            matches = pattern.exec(offset)
                        }
                        return new Date(year, month, day)
                    },
                    newDate = null == date || "" === date ? defaultDate : "string" == typeof date ? offsetString(date) : "number" == typeof date ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
                return newDate = newDate && "Invalid Date" === newDate.toString() ? defaultDate : newDate, newDate && (newDate.setHours(0), newDate.setMinutes(0), newDate.setSeconds(0), newDate.setMilliseconds(0)), this._daylightSavingAdjust(newDate)
            },
            _daylightSavingAdjust: function (date) {
                return date ? (date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0), date) : null
            },
            _setDate: function (inst, date, noChange) {
                var clear = !date,
                    origMonth = inst.selectedMonth,
                    origYear = inst.selectedYear,
                    newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date));
                inst.selectedDay = inst.currentDay = newDate.getDate(), inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth(), inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear(), origMonth === inst.selectedMonth && origYear === inst.selectedYear || noChange || this._notifyChange(inst), this._adjustInstDate(inst), inst.input && inst.input.val(clear ? "" : this._formatDate(inst))
            },
            _getDate: function (inst) {
                var startDate = !inst.currentYear || inst.input && "" === inst.input.val() ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return startDate
            },
            _attachHandlers: function (inst) {
                var stepMonths = this._get(inst, "stepMonths"),
                    id = "#" + inst.id.replace(/\\\\/g, "\\");
                inst.dpDiv.find("[data-handler]").map(function () {
                    var handler = {
                        prev: function () {
                            $.datepicker._adjustDate(id, -stepMonths, "M")
                        },
                        next: function () {
                            $.datepicker._adjustDate(id, +stepMonths, "M")
                        },
                        hide: function () {
                            $.datepicker._hideDatepicker()
                        },
                        today: function () {
                            $.datepicker._gotoToday(id)
                        },
                        selectDay: function () {
                            return $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
                        },
                        selectMonth: function () {
                            return $.datepicker._selectMonthYear(id, this, "M"), !1
                        },
                        selectYear: function () {
                            return $.datepicker._selectMonthYear(id, this, "Y"), !1
                        }
                    };
                    $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")])
                })
            },
            _generateHTML: function (inst) {
                var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date,
                    today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
                    isRTL = this._get(inst, "isRTL"),
                    showButtonPanel = this._get(inst, "showButtonPanel"),
                    hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                    navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                    numMonths = this._getNumberOfMonths(inst),
                    showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                    stepMonths = this._get(inst, "stepMonths"),
                    isMultiMonth = 1 !== numMonths[0] || 1 !== numMonths[1],
                    currentDate = this._daylightSavingAdjust(inst.currentDay ? new Date(inst.currentYear, inst.currentMonth, inst.currentDay) : new Date(9999, 9, 9)),
                    minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    drawMonth = inst.drawMonth - showCurrentAtPos,
                    drawYear = inst.drawYear;
                if (0 > drawMonth && (drawMonth += 12, drawYear--), maxDate)
                    for (maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate())), maxDraw = minDate && minDate > maxDraw ? minDate : maxDraw; this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw;) drawMonth--, 0 > drawMonth && (drawMonth = 11, drawYear--);
                for (inst.drawMonth = drawMonth, inst.drawYear = drawYear, prevText = this._get(inst, "prevText"), prevText = navigationAsDateFormat ? this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst)) : prevText, prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>", nextText = this._get(inst, "nextText"), nextText = navigationAsDateFormat ? this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst)) : nextText, next = this._canAdjustMonth(inst, 1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>", currentText = this._get(inst, "currentText"), gotoDate = this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today, currentText = navigationAsDateFormat ? this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)) : currentText, controls = inst.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>", buttonPanel = showButtonPanel ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "", firstDay = parseInt(this._get(inst, "firstDay"), 10), firstDay = isNaN(firstDay) ? 0 : firstDay, showWeek = this._get(inst, "showWeek"), dayNames = this._get(inst, "dayNames"), dayNamesMin = this._get(inst, "dayNamesMin"), monthNames = this._get(inst, "monthNames"), monthNamesShort = this._get(inst, "monthNamesShort"), beforeShowDay = this._get(inst, "beforeShowDay"), showOtherMonths = this._get(inst, "showOtherMonths"), selectOtherMonths = this._get(inst, "selectOtherMonths"), defaultDate = this._getDefaultDate(inst), html = "", row = 0; row < numMonths[0]; row++) {
                    for (group = "", this.maxRows = 4, col = 0; col < numMonths[1]; col++) {
                        if (selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay)), cornerClass = " ui-corner-all", calender = "", isMultiMonth) {
                            if (calender += "<div class='ui-datepicker-group", numMonths[1] > 1) switch (col) {
                            case 0:
                                calender += " ui-datepicker-group-first", cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                break;
                            case numMonths[1] - 1:
                                calender += " ui-datepicker-group-last", cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                break;
                            default:
                                calender += " ui-datepicker-group-middle", cornerClass = ""
                            }
                            calender += "'>"
                        }
                        for (calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && 0 === row ? isRTL ? next : prev : "") + (/all|right/.test(cornerClass) && 0 === row ? isRTL ? prev : next : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead><tr>", thead = showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "", dow = 0; 7 > dow; dow++) day = (dow + firstDay) % 7, thead += "<th" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                        for (calender += thead + "</tr></thead><tbody>", daysInMonth = this._getDaysInMonth(drawYear, drawMonth), drawYear === inst.selectedYear && drawMonth === inst.selectedMonth && (inst.selectedDay = Math.min(inst.selectedDay, daysInMonth)), leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7, curRows = Math.ceil((leadDays + daysInMonth) / 7), numRows = isMultiMonth && this.maxRows > curRows ? this.maxRows : curRows, this.maxRows = numRows, printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays)), dRow = 0; numRows > dRow; dRow++) {
                            for (calender += "<tr>", tbody = showWeek ? "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>" : "", dow = 0; 7 > dow; dow++) daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [!0, ""], otherMonth = printDate.getMonth() !== drawMonth, unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && minDate > printDate || maxDate && printDate > maxDate, tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + (otherMonth && !showOtherMonths || !daySettings[2] ? "" : " title='" + daySettings[2].replace(/'/g, "&#39;") + "'") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>") + "</td>", printDate.setDate(printDate.getDate() + 1), printDate = this._daylightSavingAdjust(printDate);
                            calender += tbody + "</tr>"
                        }
                        drawMonth++, drawMonth > 11 && (drawMonth = 0, drawYear++), calender += "</tbody></table>" + (isMultiMonth ? "</div>" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : ""), group += calender
                    }
                    html += group
                }
                return html += buttonPanel, inst._keyEvent = !1, html
            },
            _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
                var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, "changeMonth"),
                    changeYear = this._get(inst, "changeYear"),
                    showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                    html = "<div class='ui-datepicker-title'>",
                    monthHtml = "";
                if (secondary || !changeMonth) monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
                else {
                    for (inMinYear = minDate && minDate.getFullYear() === drawYear, inMaxYear = maxDate && maxDate.getFullYear() === drawYear, monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", month = 0; 12 > month; month++)(!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth()) && (monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>");
                    monthHtml += "</select>"
                } if (showMonthAfterYear || (html += monthHtml + (!secondary && changeMonth && changeYear ? "" : "&#xa0;")), !inst.yearshtml)
                    if (inst.yearshtml = "", secondary || !changeYear) html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                    else {
                        for (years = this._get(inst, "yearRange").split(":"), thisYear = (new Date).getFullYear(), determineYear = function (value) {
                            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                            return isNaN(year) ? thisYear : year
                        }, year = determineYear(years[0]), endYear = Math.max(year, determineYear(years[1] || "")), year = minDate ? Math.max(year, minDate.getFullYear()) : year, endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear, inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; endYear >= year; year++) inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
                        inst.yearshtml += "</select>", html += inst.yearshtml, inst.yearshtml = null
                    }
                return html += this._get(inst, "yearSuffix"), showMonthAfterYear && (html += (!secondary && changeMonth && changeYear ? "" : "&#xa0;") + monthHtml), html += "</div>"
            },
            _adjustInstDate: function (inst, offset, period) {
                var year = inst.drawYear + ("Y" === period ? offset : 0),
                    month = inst.drawMonth + ("M" === period ? offset : 0),
                    day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + ("D" === period ? offset : 0),
                    date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
                inst.selectedDay = date.getDate(), inst.drawMonth = inst.selectedMonth = date.getMonth(), inst.drawYear = inst.selectedYear = date.getFullYear(), ("M" === period || "Y" === period) && this._notifyChange(inst)
            },
            _restrictMinMax: function (inst, date) {
                var minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    newDate = minDate && minDate > date ? minDate : date;
                return maxDate && newDate > maxDate ? maxDate : newDate
            },
            _notifyChange: function (inst) {
                var onChange = this._get(inst, "onChangeMonthYear");
                onChange && onChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst])
            },
            _getNumberOfMonths: function (inst) {
                var numMonths = this._get(inst, "numberOfMonths");
                return null == numMonths ? [1, 1] : "number" == typeof numMonths ? [1, numMonths] : numMonths
            },
            _getMinMaxDate: function (inst, minMax) {
                return this._determineDate(inst, this._get(inst, minMax + "Date"), null)
            },
            _getDaysInMonth: function (year, month) {
                return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate()
            },
            _getFirstDayOfMonth: function (year, month) {
                return new Date(year, month, 1).getDay()
            },
            _canAdjustMonth: function (inst, offset, curYear, curMonth) {
                var numMonths = this._getNumberOfMonths(inst),
                    date = this._daylightSavingAdjust(new Date(curYear, curMonth + (0 > offset ? offset : numMonths[0] * numMonths[1]), 1));
                return 0 > offset && date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth())), this._isInRange(inst, date)
            },
            _isInRange: function (inst, date) {
                var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, "min"),
                    maxDate = this._getMinMaxDate(inst, "max"),
                    minYear = null,
                    maxYear = null,
                    years = this._get(inst, "yearRange");
                return years && (yearSplit = years.split(":"), currentYear = (new Date).getFullYear(), minYear = parseInt(yearSplit[0], 10), maxYear = parseInt(yearSplit[1], 10), yearSplit[0].match(/[+\-].*/) && (minYear += currentYear), yearSplit[1].match(/[+\-].*/) && (maxYear += currentYear)), (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear)
            },
            _getFormatConfig: function (inst) {
                var shortYearCutoff = this._get(inst, "shortYearCutoff");
                return shortYearCutoff = "string" != typeof shortYearCutoff ? shortYearCutoff : (new Date).getFullYear() % 100 + parseInt(shortYearCutoff, 10), {
                    shortYearCutoff: shortYearCutoff,
                    dayNamesShort: this._get(inst, "dayNamesShort"),
                    dayNames: this._get(inst, "dayNames"),
                    monthNamesShort: this._get(inst, "monthNamesShort"),
                    monthNames: this._get(inst, "monthNames")
                }
            },
            _formatDate: function (inst, day, month, year) {
                day || (inst.currentDay = inst.selectedDay, inst.currentMonth = inst.selectedMonth, inst.currentYear = inst.selectedYear);
                var date = day ? "object" == typeof day ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
                return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst))
            }
        }), $.fn.datepicker = function (options) {
            if (!this.length) return this;
            $.datepicker.initialized || ($(document).mousedown($.datepicker._checkExternalClick), $.datepicker.initialized = !0), 0 === $("#" + $.datepicker._mainDivId).length && $("body").append($.datepicker.dpDiv);
            var otherArgs = Array.prototype.slice.call(arguments, 1);
            return "string" != typeof options || "isDisabled" !== options && "getDate" !== options && "widget" !== options ? "option" === options && 2 === arguments.length && "string" == typeof arguments[1] ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs)) : this.each(function () {
                "string" == typeof options ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options)
            }) : $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs))
        }, $.datepicker = new Datepicker, $.datepicker.initialized = !1, $.datepicker.uuid = (new Date).getTime(), $.datepicker.version = "1.10.3"
    }(jQuery),
    function ($) {
        var sizeRelatedOptions = {
                buttons: !0,
                height: !0,
                maxHeight: !0,
                maxWidth: !0,
                minHeight: !0,
                minWidth: !0,
                width: !0
            },
            resizableRelatedOptions = {
                maxHeight: !0,
                maxWidth: !0,
                minHeight: !0,
                minWidth: !0
            };
        $.widget("ui.dialog", {
            version: "1.10.3",
            options: {
                appendTo: "body",
                autoOpen: !0,
                buttons: [],
                closeOnEscape: !0,
                closeText: "close",
                dialogClass: "",
                draggable: !0,
                hide: null,
                height: "auto",
                maxHeight: null,
                maxWidth: null,
                minHeight: 150,
                minWidth: 150,
                modal: !1,
                position: {
                    my: "center",
                    at: "center",
                    of: window,
                    collision: "fit",
                    using: function (pos) {
                        var topOffset = $(this).css(pos).offset().top;
                        0 > topOffset && $(this).css("top", pos.top - topOffset)
                    }
                },
                resizable: !0,
                show: null,
                title: null,
                width: 300,
                beforeClose: null,
                close: null,
                drag: null,
                dragStart: null,
                dragStop: null,
                focus: null,
                open: null,
                resize: null,
                resizeStart: null,
                resizeStop: null
            },
            _create: function () {
                this.originalCss = {
                    display: this.element[0].style.display,
                    width: this.element[0].style.width,
                    minHeight: this.element[0].style.minHeight,
                    maxHeight: this.element[0].style.maxHeight,
                    height: this.element[0].style.height
                }, this.originalPosition = {
                    parent: this.element.parent(),
                    index: this.element.parent().children().index(this.element)
                }, this.originalTitle = this.element.attr("title"), this.options.title = this.options.title || this.originalTitle, this._createWrapper(), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog), this._createTitlebar(), this._createButtonPane(), this.options.draggable && $.fn.draggable && this._makeDraggable(), this.options.resizable && $.fn.resizable && this._makeResizable(), this._isOpen = !1
            },
            _init: function () {
                this.options.autoOpen && this.open()
            },
            _appendTo: function () {
                var element = this.options.appendTo;
                return element && (element.jquery || element.nodeType) ? $(element) : this.document.find(element || "body").eq(0)
            },
            _destroy: function () {
                var next, originalPosition = this.originalPosition;
                this._destroyOverlay(), this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(), this.uiDialog.stop(!0, !0).remove(), this.originalTitle && this.element.attr("title", this.originalTitle), next = originalPosition.parent.children().eq(originalPosition.index), next.length && next[0] !== this.element[0] ? next.before(this.element) : originalPosition.parent.append(this.element)
            },
            widget: function () {
                return this.uiDialog
            },
            disable: $.noop,
            enable: $.noop,
            close: function (event) {
                var that = this;
                this._isOpen && this._trigger("beforeClose", event) !== !1 && (this._isOpen = !1, this._destroyOverlay(), this.opener.filter(":focusable").focus().length || $(this.document[0].activeElement).blur(), this._hide(this.uiDialog, this.options.hide, function () {
                    that._trigger("close", event)
                }))
            },
            isOpen: function () {
                return this._isOpen
            },
            moveToTop: function () {
                this._moveToTop()
            },
            _moveToTop: function (event, silent) {
                var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
                return moved && !silent && this._trigger("focus", event), moved
            },
            open: function () {
                var that = this;
                return this._isOpen ? void(this._moveToTop() && this._focusTabbable()) : (this._isOpen = !0, this.opener = $(this.document[0].activeElement), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this._show(this.uiDialog, this.options.show, function () {
                    that._focusTabbable(), that._trigger("focus")
                }), void this._trigger("open"))
            },
            _focusTabbable: function () {
                var hasFocus = this.element.find("[autofocus]");
                hasFocus.length || (hasFocus = this.element.find(":tabbable")), hasFocus.length || (hasFocus = this.uiDialogButtonPane.find(":tabbable")), hasFocus.length || (hasFocus = this.uiDialogTitlebarClose.filter(":tabbable")), hasFocus.length || (hasFocus = this.uiDialog), hasFocus.eq(0).focus()
            },
            _keepFocus: function (event) {
                function checkFocus() {
                    var activeElement = this.document[0].activeElement,
                        isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                    isActive || this._focusTabbable()
                }
                event.preventDefault(), checkFocus.call(this), this._delay(checkFocus)
            },
            _createWrapper: function () {
                this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                    tabIndex: -1,
                    role: "dialog"
                }).appendTo(this._appendTo()), this._on(this.uiDialog, {
                    keydown: function (event) {
                        if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) return event.preventDefault(), void this.close(event);
                        if (event.keyCode === $.ui.keyCode.TAB) {
                            var tabbables = this.uiDialog.find(":tabbable"),
                                first = tabbables.filter(":first"),
                                last = tabbables.filter(":last");
                            event.target !== last[0] && event.target !== this.uiDialog[0] || event.shiftKey ? event.target !== first[0] && event.target !== this.uiDialog[0] || !event.shiftKey || (last.focus(1), event.preventDefault()) : (first.focus(1), event.preventDefault())
                        }
                    },
                    mousedown: function (event) {
                        this._moveToTop(event) && this._focusTabbable()
                    }
                }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({
                    "aria-describedby": this.element.uniqueId().attr("id")
                })
            },
            _createTitlebar: function () {
                var uiDialogTitle;
                this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog), this._on(this.uiDialogTitlebar, {
                    mousedown: function (event) {
                        $(event.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.focus()
                    }
                }), this.uiDialogTitlebarClose = $("<button></button>").button({
                    label: this.options.closeText,
                    icons: {
                        primary: "ui-icon-closethick"
                    },
                    text: !1
                }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar), this._on(this.uiDialogTitlebarClose, {
                    click: function (event) {
                        event.preventDefault(), this.close(event)
                    }
                }), uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar), this._title(uiDialogTitle), this.uiDialog.attr({
                    "aria-labelledby": uiDialogTitle.attr("id")
                })
            },
            _title: function (title) {
                this.options.title || title.html("&#160;"), title.text(this.options.title)
            },
            _createButtonPane: function () {
                this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane), this._createButtons()
            },
            _createButtons: function () {
                var that = this,
                    buttons = this.options.buttons;
                return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), $.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length ? void this.uiDialog.removeClass("ui-dialog-buttons") : ($.each(buttons, function (name, props) {
                    var click, buttonOptions;
                    props = $.isFunction(props) ? {
                        click: props,
                        text: name
                    } : props, props = $.extend({
                        type: "button"
                    }, props), click = props.click, props.click = function () {
                        click.apply(that.element[0], arguments)
                    }, buttonOptions = {
                        icons: props.icons,
                        text: props.showText
                    }, delete props.icons, delete props.showText, $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet)
                }), this.uiDialog.addClass("ui-dialog-buttons"), void this.uiDialogButtonPane.appendTo(this.uiDialog))
            },
            _makeDraggable: function () {
                function filteredUi(ui) {
                    return {
                        position: ui.position,
                        offset: ui.offset
                    }
                }
                var that = this,
                    options = this.options;
                this.uiDialog.draggable({
                    cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                    handle: ".ui-dialog-titlebar",
                    containment: "document",
                    start: function (event, ui) {
                        $(this).addClass("ui-dialog-dragging"), that._blockFrames(), that._trigger("dragStart", event, filteredUi(ui))
                    },
                    drag: function (event, ui) {
                        that._trigger("drag", event, filteredUi(ui))
                    },
                    stop: function (event, ui) {
                        options.position = [ui.position.left - that.document.scrollLeft(), ui.position.top - that.document.scrollTop()], $(this).removeClass("ui-dialog-dragging"), that._unblockFrames(), that._trigger("dragStop", event, filteredUi(ui))
                    }
                })
            },
            _makeResizable: function () {
                function filteredUi(ui) {
                    return {
                        originalPosition: ui.originalPosition,
                        originalSize: ui.originalSize,
                        position: ui.position,
                        size: ui.size
                    }
                }
                var that = this,
                    options = this.options,
                    handles = options.resizable,
                    position = this.uiDialog.css("position"),
                    resizeHandles = "string" == typeof handles ? handles : "n,e,s,w,se,sw,ne,nw";
                this.uiDialog.resizable({
                    cancel: ".ui-dialog-content",
                    containment: "document",
                    alsoResize: this.element,
                    maxWidth: options.maxWidth,
                    maxHeight: options.maxHeight,
                    minWidth: options.minWidth,
                    minHeight: this._minHeight(),
                    handles: resizeHandles,
                    start: function (event, ui) {
                        $(this).addClass("ui-dialog-resizing"), that._blockFrames(), that._trigger("resizeStart", event, filteredUi(ui))
                    },
                    resize: function (event, ui) {
                        that._trigger("resize", event, filteredUi(ui))
                    },
                    stop: function (event, ui) {
                        options.height = $(this).height(), options.width = $(this).width(), $(this).removeClass("ui-dialog-resizing"), that._unblockFrames(), that._trigger("resizeStop", event, filteredUi(ui))
                    }
                }).css("position", position)
            },
            _minHeight: function () {
                var options = this.options;
                return "auto" === options.height ? options.minHeight : Math.min(options.minHeight, options.height)
            },
            _position: function () {
                var isVisible = this.uiDialog.is(":visible");
                isVisible || this.uiDialog.show(), this.uiDialog.position(this.options.position), isVisible || this.uiDialog.hide()
            },
            _setOptions: function (options) {
                var that = this,
                    resize = !1,
                    resizableOptions = {};
                $.each(options, function (key, value) {
                    that._setOption(key, value), key in sizeRelatedOptions && (resize = !0), key in resizableRelatedOptions && (resizableOptions[key] = value)
                }), resize && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", resizableOptions)
            },
            _setOption: function (key, value) {
                var isDraggable, isResizable, uiDialog = this.uiDialog;
                "dialogClass" === key && uiDialog.removeClass(this.options.dialogClass).addClass(value), "disabled" !== key && (this._super(key, value), "appendTo" === key && this.uiDialog.appendTo(this._appendTo()), "buttons" === key && this._createButtons(), "closeText" === key && this.uiDialogTitlebarClose.button({
                    label: "" + value
                }), "draggable" === key && (isDraggable = uiDialog.is(":data(ui-draggable)"), isDraggable && !value && uiDialog.draggable("destroy"), !isDraggable && value && this._makeDraggable()), "position" === key && this._position(), "resizable" === key && (isResizable = uiDialog.is(":data(ui-resizable)"), isResizable && !value && uiDialog.resizable("destroy"), isResizable && "string" == typeof value && uiDialog.resizable("option", "handles", value), isResizable || value === !1 || this._makeResizable()), "title" === key && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
            },
            _size: function () {
                var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
                this.element.show().css({
                    width: "auto",
                    minHeight: 0,
                    maxHeight: "none",
                    height: 0
                }), options.minWidth > options.width && (options.width = options.minWidth), nonContentHeight = this.uiDialog.css({
                    height: "auto",
                    width: options.width
                }).outerHeight(), minContentHeight = Math.max(0, options.minHeight - nonContentHeight), maxContentHeight = "number" == typeof options.maxHeight ? Math.max(0, options.maxHeight - nonContentHeight) : "none", "auto" === options.height ? this.element.css({
                    minHeight: minContentHeight,
                    maxHeight: maxContentHeight,
                    height: "auto"
                }) : this.element.height(Math.max(0, options.height - nonContentHeight)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
            },
            _blockFrames: function () {
                this.iframeBlocks = this.document.find("iframe").map(function () {
                    var iframe = $(this);
                    return $("<div>").css({
                        position: "absolute",
                        width: iframe.outerWidth(),
                        height: iframe.outerHeight()
                    }).appendTo(iframe.parent()).offset(iframe.offset())[0]
                })
            },
            _unblockFrames: function () {
                this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
            },
            _allowInteraction: function (event) {
                return $(event.target).closest(".ui-dialog").length ? !0 : !!$(event.target).closest(".ui-datepicker").length
            },
            _createOverlay: function () {
                if (this.options.modal) {
                    var that = this,
                        widgetFullName = this.widgetFullName;
                    $.ui.dialog.overlayInstances || this._delay(function () {
                        $.ui.dialog.overlayInstances && this.document.bind("focusin.dialog", function (event) {
                            that._allowInteraction(event) || (event.preventDefault(), $(".ui-dialog:visible:last .ui-dialog-content").data(widgetFullName)._focusTabbable())
                        })
                    }), this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()), this._on(this.overlay, {
                        mousedown: "_keepFocus"
                    }), $.ui.dialog.overlayInstances++
                }
            },
            _destroyOverlay: function () {
                this.options.modal && this.overlay && ($.ui.dialog.overlayInstances--, $.ui.dialog.overlayInstances || this.document.unbind("focusin.dialog"), this.overlay.remove(), this.overlay = null)
            }
        }), $.ui.dialog.overlayInstances = 0, $.uiBackCompat !== !1 && $.widget("ui.dialog", $.ui.dialog, {
            _position: function () {
                var isVisible, position = this.options.position,
                    myAt = [],
                    offset = [0, 0];
                position ? (("string" == typeof position || "object" == typeof position && "0" in position) && (myAt = position.split ? position.split(" ") : [position[0], position[1]], 1 === myAt.length && (myAt[1] = myAt[0]), $.each(["left", "top"], function (i, offsetPosition) {
                    +myAt[i] === myAt[i] && (offset[i] = myAt[i], myAt[i] = offsetPosition)
                }), position = {
                    my: myAt[0] + (offset[0] < 0 ? offset[0] : "+" + offset[0]) + " " + myAt[1] + (offset[1] < 0 ? offset[1] : "+" + offset[1]),
                    at: myAt.join(" ")
                }), position = $.extend({}, $.ui.dialog.prototype.options.position, position)) : position = $.ui.dialog.prototype.options.position, isVisible = this.uiDialog.is(":visible"), isVisible || this.uiDialog.show(), this.uiDialog.position(position), isVisible || this.uiDialog.hide()
            }
        })
    }(jQuery),
    function ($) {
        var rvertical = /up|down|vertical/,
            rpositivemotion = /up|left|vertical|horizontal/;
        $.effects.effect.blind = function (o, done) {
            var wrapper, distance, margin, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "hide"),
                direction = o.direction || "up",
                vertical = rvertical.test(direction),
                ref = vertical ? "height" : "width",
                ref2 = vertical ? "top" : "left",
                motion = rpositivemotion.test(direction),
                animation = {},
                show = "show" === mode;
            el.parent().is(".ui-effects-wrapper") ? $.effects.save(el.parent(), props) : $.effects.save(el, props), el.show(), wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            }), distance = wrapper[ref](), margin = parseFloat(wrapper.css(ref2)) || 0, animation[ref] = show ? distance : 0, motion || (el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({
                position: "absolute"
            }), animation[ref2] = show ? margin : distance + margin), show && (wrapper.css(ref, 0), motion || wrapper.css(ref2, margin + distance)), wrapper.animate(animation, {
                duration: o.duration,
                easing: o.easing,
                queue: !1,
                complete: function () {
                    "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.bounce = function (o, done) {
            var i, upAnim, downAnim, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "effect"),
                hide = "hide" === mode,
                show = "show" === mode,
                direction = o.direction || "up",
                distance = o.distance,
                times = o.times || 5,
                anims = 2 * times + (show || hide ? 1 : 0),
                speed = o.duration / anims,
                easing = o.easing,
                ref = "up" === direction || "down" === direction ? "top" : "left",
                motion = "up" === direction || "left" === direction,
                queue = el.queue(),
                queuelen = queue.length;
            for ((show || hide) && props.push("opacity"), $.effects.save(el, props), el.show(), $.effects.createWrapper(el), distance || (distance = el["top" === ref ? "outerHeight" : "outerWidth"]() / 3), show && (downAnim = {
                opacity: 1
            }, downAnim[ref] = 0, el.css("opacity", 0).css(ref, motion ? 2 * -distance : 2 * distance).animate(downAnim, speed, easing)), hide && (distance /= Math.pow(2, times - 1)), downAnim = {}, downAnim[ref] = 0, i = 0; times > i; i++) upAnim = {}, upAnim[ref] = (motion ? "-=" : "+=") + distance, el.animate(upAnim, speed, easing).animate(downAnim, speed, easing), distance = hide ? 2 * distance : distance / 2;
            hide && (upAnim = {
                opacity: 0
            }, upAnim[ref] = (motion ? "-=" : "+=") + distance, el.animate(upAnim, speed, easing)), el.queue(function () {
                hide && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
            }), queuelen > 1 && queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1))), el.dequeue()
        }
    }(jQuery),
    function ($) {
        $.effects.effect.clip = function (o, done) {
            var wrapper, animate, distance, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "hide"),
                show = "show" === mode,
                direction = o.direction || "vertical",
                vert = "vertical" === direction,
                size = vert ? "height" : "width",
                position = vert ? "top" : "left",
                animation = {};
            $.effects.save(el, props), el.show(), wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            }), animate = "IMG" === el[0].tagName ? wrapper : el, distance = animate[size](), show && (animate.css(size, 0), animate.css(position, distance / 2)), animation[size] = show ? distance : 0, animation[position] = show ? 0 : distance / 2, animate.animate(animation, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    show || el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.drop = function (o, done) {
            var distance, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "hide"),
                show = "show" === mode,
                direction = o.direction || "left",
                ref = "up" === direction || "down" === direction ? "top" : "left",
                motion = "up" === direction || "left" === direction ? "pos" : "neg",
                animation = {
                    opacity: show ? 1 : 0
                };
            $.effects.save(el, props), el.show(), $.effects.createWrapper(el), distance = o.distance || el["top" === ref ? "outerHeight" : "outerWidth"](!0) / 2, show && el.css("opacity", 0).css(ref, "pos" === motion ? -distance : distance), animation[ref] = (show ? "pos" === motion ? "+=" : "-=" : "pos" === motion ? "-=" : "+=") + distance, el.animate(animation, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.explode = function (o, done) {
            function childComplete() {
                pieces.push(this), pieces.length === rows * cells && animComplete()
            }

            function animComplete() {
                el.css({
                    visibility: "visible"
                }), $(pieces).remove(), show || el.hide(), done()
            }
            var i, j, left, top, mx, my, rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
                cells = rows,
                el = $(this),
                mode = $.effects.setMode(el, o.mode || "hide"),
                show = "show" === mode,
                offset = el.show().css("visibility", "hidden").offset(),
                width = Math.ceil(el.outerWidth() / cells),
                height = Math.ceil(el.outerHeight() / rows),
                pieces = [];
            for (i = 0; rows > i; i++)
                for (top = offset.top + i * height, my = i - (rows - 1) / 2, j = 0; cells > j; j++) left = offset.left + j * width, mx = j - (cells - 1) / 2, el.clone().appendTo("body").wrap("<div></div>").css({
                    position: "absolute",
                    visibility: "visible",
                    left: -j * width,
                    top: -i * height
                }).parent().addClass("ui-effects-explode").css({
                    position: "absolute",
                    overflow: "hidden",
                    width: width,
                    height: height,
                    left: left + (show ? mx * width : 0),
                    top: top + (show ? my * height : 0),
                    opacity: show ? 0 : 1
                }).animate({
                    left: left + (show ? 0 : mx * width),
                    top: top + (show ? 0 : my * height),
                    opacity: show ? 1 : 0
                }, o.duration || 500, o.easing, childComplete)
        }
    }(jQuery),
    function ($) {
        $.effects.effect.fade = function (o, done) {
            var el = $(this),
                mode = $.effects.setMode(el, o.mode || "toggle");
            el.animate({
                opacity: mode
            }, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: done
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.fold = function (o, done) {
            var wrapper, distance, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "hide"),
                show = "show" === mode,
                hide = "hide" === mode,
                size = o.size || 15,
                percent = /([0-9]+)%/.exec(size),
                horizFirst = !!o.horizFirst,
                widthFirst = show !== horizFirst,
                ref = widthFirst ? ["width", "height"] : ["height", "width"],
                duration = o.duration / 2,
                animation1 = {},
                animation2 = {};
            $.effects.save(el, props), el.show(), wrapper = $.effects.createWrapper(el).css({
                overflow: "hidden"
            }), distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()], percent && (size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1]), show && wrapper.css(horizFirst ? {
                height: 0,
                width: size
            } : {
                height: size,
                width: 0
            }), animation1[ref[0]] = show ? distance[0] : size, animation2[ref[1]] = show ? distance[1] : 0, wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {
                hide && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.highlight = function (o, done) {
            var elem = $(this),
                props = ["backgroundImage", "backgroundColor", "opacity"],
                mode = $.effects.setMode(elem, o.mode || "show"),
                animation = {
                    backgroundColor: elem.css("backgroundColor")
                };
            "hide" === mode && (animation.opacity = 0), $.effects.save(elem, props), elem.show().css({
                backgroundImage: "none",
                backgroundColor: o.color || "#ffff99"
            }).animate(animation, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    "hide" === mode && elem.hide(), $.effects.restore(elem, props), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.pulsate = function (o, done) {
            var i, elem = $(this),
                mode = $.effects.setMode(elem, o.mode || "show"),
                show = "show" === mode,
                hide = "hide" === mode,
                showhide = show || "hide" === mode,
                anims = 2 * (o.times || 5) + (showhide ? 1 : 0),
                duration = o.duration / anims,
                animateTo = 0,
                queue = elem.queue(),
                queuelen = queue.length;
            for ((show || !elem.is(":visible")) && (elem.css("opacity", 0).show(), animateTo = 1), i = 1; anims > i; i++) elem.animate({
                opacity: animateTo
            }, duration, o.easing), animateTo = 1 - animateTo;
            elem.animate({
                opacity: animateTo
            }, duration, o.easing), elem.queue(function () {
                hide && elem.hide(), done()
            }), queuelen > 1 && queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1))), elem.dequeue()
        }
    }(jQuery),
    function ($) {
        $.effects.effect.puff = function (o, done) {
            var elem = $(this),
                mode = $.effects.setMode(elem, o.mode || "hide"),
                hide = "hide" === mode,
                percent = parseInt(o.percent, 10) || 150,
                factor = percent / 100,
                original = {
                    height: elem.height(),
                    width: elem.width(),
                    outerHeight: elem.outerHeight(),
                    outerWidth: elem.outerWidth()
                };
            $.extend(o, {
                effect: "scale",
                queue: !1,
                fade: !0,
                mode: mode,
                complete: done,
                percent: hide ? percent : 100,
                from: hide ? original : {
                    height: original.height * factor,
                    width: original.width * factor,
                    outerHeight: original.outerHeight * factor,
                    outerWidth: original.outerWidth * factor
                }
            }), elem.effect(o)
        }, $.effects.effect.scale = function (o, done) {
            var el = $(this),
                options = $.extend(!0, {}, o),
                mode = $.effects.setMode(el, o.mode || "effect"),
                percent = parseInt(o.percent, 10) || (0 === parseInt(o.percent, 10) ? 0 : "hide" === mode ? 0 : 100),
                direction = o.direction || "both",
                origin = o.origin,
                original = {
                    height: el.height(),
                    width: el.width(),
                    outerHeight: el.outerHeight(),
                    outerWidth: el.outerWidth()
                },
                factor = {
                    y: "horizontal" !== direction ? percent / 100 : 1,
                    x: "vertical" !== direction ? percent / 100 : 1
                };
            options.effect = "size", options.queue = !1, options.complete = done, "effect" !== mode && (options.origin = origin || ["middle", "center"], options.restore = !0), options.from = o.from || ("show" === mode ? {
                height: 0,
                width: 0,
                outerHeight: 0,
                outerWidth: 0
            } : original), options.to = {
                height: original.height * factor.y,
                width: original.width * factor.x,
                outerHeight: original.outerHeight * factor.y,
                outerWidth: original.outerWidth * factor.x
            }, options.fade && ("show" === mode && (options.from.opacity = 0, options.to.opacity = 1), "hide" === mode && (options.from.opacity = 1, options.to.opacity = 0)), el.effect(options)
        }, $.effects.effect.size = function (o, done) {
            var original, baseline, factor, el = $(this),
                props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
                props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
                props2 = ["width", "height", "overflow"],
                cProps = ["fontSize"],
                vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
                hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
                mode = $.effects.setMode(el, o.mode || "effect"),
                restore = o.restore || "effect" !== mode,
                scale = o.scale || "both",
                origin = o.origin || ["middle", "center"],
                position = el.css("position"),
                props = restore ? props0 : props1,
                zero = {
                    height: 0,
                    width: 0,
                    outerHeight: 0,
                    outerWidth: 0
                };
            "show" === mode && el.show(), original = {
                height: el.height(),
                width: el.width(),
                outerHeight: el.outerHeight(),
                outerWidth: el.outerWidth()
            }, "toggle" === o.mode && "show" === mode ? (el.from = o.to || zero, el.to = o.from || original) : (el.from = o.from || ("show" === mode ? zero : original), el.to = o.to || ("hide" === mode ? zero : original)), factor = {
                from: {
                    y: el.from.height / original.height,
                    x: el.from.width / original.width
                },
                to: {
                    y: el.to.height / original.height,
                    x: el.to.width / original.width
                }
            }, ("box" === scale || "both" === scale) && (factor.from.y !== factor.to.y && (props = props.concat(vProps), el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from), el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to)), factor.from.x !== factor.to.x && (props = props.concat(hProps), el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from), el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to))), ("content" === scale || "both" === scale) && factor.from.y !== factor.to.y && (props = props.concat(cProps).concat(props2), el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from), el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to)), $.effects.save(el, props), el.show(), $.effects.createWrapper(el), el.css("overflow", "hidden").css(el.from), origin && (baseline = $.effects.getBaseline(origin, original), el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y, el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x, el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y, el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x), el.css(el.from), ("content" === scale || "both" === scale) && (vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps), hProps = hProps.concat(["marginLeft", "marginRight"]), props2 = props0.concat(vProps).concat(hProps), el.find("*[width]").each(function () {
                var child = $(this),
                    c_original = {
                        height: child.height(),
                        width: child.width(),
                        outerHeight: child.outerHeight(),
                        outerWidth: child.outerWidth()
                    };
                restore && $.effects.save(child, props2), child.from = {
                    height: c_original.height * factor.from.y,
                    width: c_original.width * factor.from.x,
                    outerHeight: c_original.outerHeight * factor.from.y,
                    outerWidth: c_original.outerWidth * factor.from.x
                }, child.to = {
                    height: c_original.height * factor.to.y,
                    width: c_original.width * factor.to.x,
                    outerHeight: c_original.height * factor.to.y,
                    outerWidth: c_original.width * factor.to.x
                }, factor.from.y !== factor.to.y && (child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from), child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to)), factor.from.x !== factor.to.x && (child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from), child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to)), child.css(child.from), child.animate(child.to, o.duration, o.easing, function () {
                    restore && $.effects.restore(child, props2)
                })
            })), el.animate(el.to, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    0 === el.to.opacity && el.css("opacity", el.from.opacity), "hide" === mode && el.hide(), $.effects.restore(el, props), restore || ("static" === position ? el.css({
                        position: "relative",
                        top: el.to.top,
                        left: el.to.left
                    }) : $.each(["top", "left"], function (idx, pos) {
                        el.css(pos, function (_, str) {
                            var val = parseInt(str, 10),
                                toRef = idx ? el.to.left : el.to.top;
                            return "auto" === str ? toRef + "px" : val + toRef + "px"
                        })
                    })), $.effects.removeWrapper(el), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.shake = function (o, done) {
            var i, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "height", "width"],
                mode = $.effects.setMode(el, o.mode || "effect"),
                direction = o.direction || "left",
                distance = o.distance || 20,
                times = o.times || 3,
                anims = 2 * times + 1,
                speed = Math.round(o.duration / anims),
                ref = "up" === direction || "down" === direction ? "top" : "left",
                positiveMotion = "up" === direction || "left" === direction,
                animation = {},
                animation1 = {},
                animation2 = {},
                queue = el.queue(),
                queuelen = queue.length;
            for ($.effects.save(el, props), el.show(), $.effects.createWrapper(el), animation[ref] = (positiveMotion ? "-=" : "+=") + distance, animation1[ref] = (positiveMotion ? "+=" : "-=") + 2 * distance, animation2[ref] = (positiveMotion ? "-=" : "+=") + 2 * distance, el.animate(animation, speed, o.easing), i = 1; times > i; i++) el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
            el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {
                "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
            }), queuelen > 1 && queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1))), el.dequeue()
        }
    }(jQuery),
    function ($) {
        $.effects.effect.slide = function (o, done) {
            var distance, el = $(this),
                props = ["position", "top", "bottom", "left", "right", "width", "height"],
                mode = $.effects.setMode(el, o.mode || "show"),
                show = "show" === mode,
                direction = o.direction || "left",
                ref = "up" === direction || "down" === direction ? "top" : "left",
                positiveMotion = "up" === direction || "left" === direction,
                animation = {};
            $.effects.save(el, props), el.show(), distance = o.distance || el["top" === ref ? "outerHeight" : "outerWidth"](!0), $.effects.createWrapper(el).css({
                overflow: "hidden"
            }), show && el.css(ref, positiveMotion ? isNaN(distance) ? "-" + distance : -distance : distance), animation[ref] = (show ? positiveMotion ? "+=" : "-=" : positiveMotion ? "-=" : "+=") + distance, el.animate(animation, {
                queue: !1,
                duration: o.duration,
                easing: o.easing,
                complete: function () {
                    "hide" === mode && el.hide(), $.effects.restore(el, props), $.effects.removeWrapper(el), done()
                }
            })
        }
    }(jQuery),
    function ($) {
        $.effects.effect.transfer = function (o, done) {
            var elem = $(this),
                target = $(o.to),
                targetFixed = "fixed" === target.css("position"),
                body = $("body"),
                fixTop = targetFixed ? body.scrollTop() : 0,
                fixLeft = targetFixed ? body.scrollLeft() : 0,
                endPosition = target.offset(),
                animation = {
                    top: endPosition.top - fixTop,
                    left: endPosition.left - fixLeft,
                    height: target.innerHeight(),
                    width: target.innerWidth()
                },
                startPosition = elem.offset(),
                transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
                    top: startPosition.top - fixTop,
                    left: startPosition.left - fixLeft,
                    height: elem.innerHeight(),
                    width: elem.innerWidth(),
                    position: targetFixed ? "fixed" : "absolute"
                }).animate(animation, o.duration, o.easing, function () {
                    transfer.remove(), done()
                })
        }
    }(jQuery),
    function ($) {
        $.widget("ui.menu", {
            version: "1.10.3",
            defaultElement: "<ul>",
            delay: 300,
            options: {
                icons: {
                    submenu: "ui-icon-carat-1-e"
                },
                menus: "ul",
                position: {
                    my: "left top",
                    at: "right top"
                },
                role: "menu",
                blur: null,
                focus: null,
                select: null
            },
            _create: function () {
                this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
                    role: this.options.role,
                    tabIndex: 0
                }).bind("click" + this.eventNamespace, $.proxy(function (event) {
                    this.options.disabled && event.preventDefault()
                }, this)), this.options.disabled && this.element.addClass("ui-state-disabled").attr("aria-disabled", "true"), this._on({
                    "mousedown .ui-menu-item > a": function (event) {
                        event.preventDefault()
                    },
                    "click .ui-state-disabled > a": function (event) {
                        event.preventDefault()
                    },
                    "click .ui-menu-item:has(a)": function (event) {
                        var target = $(event.target).closest(".ui-menu-item");
                        !this.mouseHandled && target.not(".ui-state-disabled").length && (this.mouseHandled = !0, this.select(event), target.has(".ui-menu").length ? this.expand(event) : this.element.is(":focus") || (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)))
                    },
                    "mouseenter .ui-menu-item": function (event) {
                        var target = $(event.currentTarget);
                        target.siblings().children(".ui-state-active").removeClass("ui-state-active"), this.focus(event, target)
                    },
                    mouseleave: "collapseAll",
                    "mouseleave .ui-menu": "collapseAll",
                    focus: function (event, keepActiveItem) {
                        var item = this.active || this.element.children(".ui-menu-item").eq(0);
                        keepActiveItem || this.focus(event, item)
                    },
                    blur: function (event) {
                        this._delay(function () {
                            $.contains(this.element[0], this.document[0].activeElement) || this.collapseAll(event)
                        })
                    },
                    keydown: "_keydown"
                }), this.refresh(), this._on(this.document, {
                    click: function (event) {
                        $(event.target).closest(".ui-menu").length || this.collapseAll(event), this.mouseHandled = !1
                    }
                })
            },
            _destroy: function () {
                this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(), this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function () {
                    var elem = $(this);
                    elem.data("ui-menu-submenu-carat") && elem.remove()
                }), this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")
            },
            _keydown: function (event) {
                function escape(value) {
                    return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
                }
                var match, prev, character, skip, regex, preventDefault = !0;
                switch (event.keyCode) {
                case $.ui.keyCode.PAGE_UP:
                    this.previousPage(event);
                    break;
                case $.ui.keyCode.PAGE_DOWN:
                    this.nextPage(event);
                    break;
                case $.ui.keyCode.HOME:
                    this._move("first", "first", event);
                    break;
                case $.ui.keyCode.END:
                    this._move("last", "last", event);
                    break;
                case $.ui.keyCode.UP:
                    this.previous(event);
                    break;
                case $.ui.keyCode.DOWN:
                    this.next(event);
                    break;
                case $.ui.keyCode.LEFT:
                    this.collapse(event);
                    break;
                case $.ui.keyCode.RIGHT:
                    this.active && !this.active.is(".ui-state-disabled") && this.expand(event);
                    break;
                case $.ui.keyCode.ENTER:
                case $.ui.keyCode.SPACE:
                    this._activate(event);
                    break;
                case $.ui.keyCode.ESCAPE:
                    this.collapse(event);
                    break;
                default:
                    preventDefault = !1, prev = this.previousFilter || "", character = String.fromCharCode(event.keyCode), skip = !1, clearTimeout(this.filterTimer), character === prev ? skip = !0 : character = prev + character, regex = new RegExp("^" + escape(character), "i"), match = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return regex.test($(this).children("a").text())
                    }), match = skip && -1 !== match.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : match, match.length || (character = String.fromCharCode(event.keyCode), regex = new RegExp("^" + escape(character), "i"), match = this.activeMenu.children(".ui-menu-item").filter(function () {
                        return regex.test($(this).children("a").text())
                    })), match.length ? (this.focus(event, match), match.length > 1 ? (this.previousFilter = character, this.filterTimer = this._delay(function () {
                        delete this.previousFilter
                    }, 1e3)) : delete this.previousFilter) : delete this.previousFilter
                }
                preventDefault && event.preventDefault()
            },
            _activate: function (event) {
                this.active.is(".ui-state-disabled") || (this.active.children("a[aria-haspopup='true']").length ? this.expand(event) : this.select(event))
            },
            refresh: function () {
                var menus, icon = this.options.icons.submenu,
                    submenus = this.element.find(this.options.menus);
                submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({
                    role: this.options.role,
                    "aria-hidden": "true",
                    "aria-expanded": "false"
                }).each(function () {
                    var menu = $(this),
                        item = menu.prev("a"),
                        submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", !0);
                    item.attr("aria-haspopup", "true").prepend(submenuCarat), menu.attr("aria-labelledby", item.attr("id"))
                }), menus = submenus.add(this.element), menus.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role", "presentation").children("a").uniqueId().addClass("ui-corner-all").attr({
                    tabIndex: -1,
                    role: this._itemRole()
                }), menus.children(":not(.ui-menu-item)").each(function () {
                    var item = $(this);
                    /[^\-\u2014\u2013\s]/.test(item.text()) || item.addClass("ui-widget-content ui-menu-divider")
                }), menus.children(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !$.contains(this.element[0], this.active[0]) && this.blur()
            },
            _itemRole: function () {
                return {
                    menu: "menuitem",
                    listbox: "option"
                }[this.options.role]
            },
            _setOption: function (key, value) {
                "icons" === key && this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu), this._super(key, value)
            },
            focus: function (event, item) {
                var nested, focused;
                this.blur(event, event && "focus" === event.type), this._scrollIntoView(item), this.active = item.first(), focused = this.active.children("a").addClass("ui-state-focus"), this.options.role && this.element.attr("aria-activedescendant", focused.attr("id")), this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active"), event && "keydown" === event.type ? this._close() : this.timer = this._delay(function () {
                    this._close()
                }, this.delay), nested = item.children(".ui-menu"), nested.length && /^mouse/.test(event.type) && this._startOpening(nested), this.activeMenu = item.parent(), this._trigger("focus", event, {
                    item: item
                })
            },
            _scrollIntoView: function (item) {
                var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
                this._hasScroll() && (borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0, paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0, offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop, scroll = this.activeMenu.scrollTop(), elementHeight = this.activeMenu.height(), itemHeight = item.height(), 0 > offset ? this.activeMenu.scrollTop(scroll + offset) : offset + itemHeight > elementHeight && this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight))
            },
            blur: function (event, fromFocus) {
                fromFocus || clearTimeout(this.timer), this.active && (this.active.children("a").removeClass("ui-state-focus"), this.active = null, this._trigger("blur", event, {
                    item: this.active
                }))
            },
            _startOpening: function (submenu) {
                clearTimeout(this.timer), "true" === submenu.attr("aria-hidden") && (this.timer = this._delay(function () {
                    this._close(), this._open(submenu)
                }, this.delay))
            },
            _open: function (submenu) {
                var position = $.extend({
                    of: this.active
                }, this.options.position);
                clearTimeout(this.timer), this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true"), submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position)
            },
            collapseAll: function (event, all) {
                clearTimeout(this.timer), this.timer = this._delay(function () {
                    var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
                    currentMenu.length || (currentMenu = this.element), this._close(currentMenu), this.blur(event), this.activeMenu = currentMenu
                }, this.delay)
            },
            _close: function (startMenu) {
                startMenu || (startMenu = this.active ? this.active.parent() : this.element), startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find("a.ui-state-active").removeClass("ui-state-active")
            },
            collapse: function (event) {
                var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
                newItem && newItem.length && (this._close(), this.focus(event, newItem))
            },
            expand: function (event) {
                var newItem = this.active && this.active.children(".ui-menu ").children(".ui-menu-item").first();
                newItem && newItem.length && (this._open(newItem.parent()), this._delay(function () {
                    this.focus(event, newItem)
                }))
            },
            next: function (event) {
                this._move("next", "first", event)
            },
            previous: function (event) {
                this._move("prev", "last", event)
            },
            isFirstItem: function () {
                return this.active && !this.active.prevAll(".ui-menu-item").length
            },
            isLastItem: function () {
                return this.active && !this.active.nextAll(".ui-menu-item").length
            },
            _move: function (direction, filter, event) {
                var next;
                this.active && (next = "first" === direction || "last" === direction ? this.active["first" === direction ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[direction + "All"](".ui-menu-item").eq(0)), next && next.length && this.active || (next = this.activeMenu.children(".ui-menu-item")[filter]()), this.focus(event, next)
            },
            nextPage: function (event) {
                var item, base, height;
                return this.active ? void(this.isLastItem() || (this._hasScroll() ? (base = this.active.offset().top, height = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
                    return item = $(this), item.offset().top - base - height < 0
                }), this.focus(event, item)) : this.focus(event, this.activeMenu.children(".ui-menu-item")[this.active ? "last" : "first"]()))) : void this.next(event)
            },
            previousPage: function (event) {
                var item, base, height;
                return this.active ? void(this.isFirstItem() || (this._hasScroll() ? (base = this.active.offset().top, height = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
                    return item = $(this), item.offset().top - base + height > 0
                }), this.focus(event, item)) : this.focus(event, this.activeMenu.children(".ui-menu-item").first()))) : void this.next(event)
            },
            _hasScroll: function () {
                return this.element.outerHeight() < this.element.prop("scrollHeight")
            },
            select: function (event) {
                this.active = this.active || $(event.target).closest(".ui-menu-item");
                var ui = {
                    item: this.active
                };
                this.active.has(".ui-menu").length || this.collapseAll(event, !0), this._trigger("select", event, ui)
            }
        })
    }(jQuery),
    function ($, undefined) {
        function getOffsets(offsets, width, height) {
            return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)]
        }

        function parseCss(element, property) {
            return parseInt($.css(element, property), 10) || 0
        }

        function getDimensions(elem) {
            var raw = elem[0];
            return 9 === raw.nodeType ? {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: 0,
                    left: 0
                }
            } : $.isWindow(raw) ? {
                width: elem.width(),
                height: elem.height(),
                offset: {
                    top: elem.scrollTop(),
                    left: elem.scrollLeft()
                }
            } : raw.preventDefault ? {
                width: 0,
                height: 0,
                offset: {
                    top: raw.pageY,
                    left: raw.pageX
                }
            } : {
                width: elem.outerWidth(),
                height: elem.outerHeight(),
                offset: elem.offset()
            }
        }
        $.ui = $.ui || {};
        var cachedScrollbarWidth, max = Math.max,
            abs = Math.abs,
            round = Math.round,
            rhorizontal = /left|center|right/,
            rvertical = /top|center|bottom/,
            roffset = /[\+\-]\d+(\.[\d]+)?%?/,
            rposition = /^\w+/,
            rpercent = /%$/,
            _position = $.fn.position;
        $.position = {
                scrollbarWidth: function () {
                    if (cachedScrollbarWidth !== undefined) return cachedScrollbarWidth;
                    var w1, w2, div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                        innerDiv = div.children()[0];
                    return $("body").append(div), w1 = innerDiv.offsetWidth, div.css("overflow", "scroll"), w2 = innerDiv.offsetWidth, w1 === w2 && (w2 = div[0].clientWidth), div.remove(), cachedScrollbarWidth = w1 - w2
                },
                getScrollInfo: function (within) {
                    var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
                        overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
                        hasOverflowX = "scroll" === overflowX || "auto" === overflowX && within.width < within.element[0].scrollWidth,
                        hasOverflowY = "scroll" === overflowY || "auto" === overflowY && within.height < within.element[0].scrollHeight;
                    return {
                        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
                        height: hasOverflowX ? $.position.scrollbarWidth() : 0
                    }
                },
                getWithinInfo: function (element) {
                    var withinElement = $(element || window),
                        isWindow = $.isWindow(withinElement[0]);
                    return {
                        element: withinElement,
                        isWindow: isWindow,
                        offset: withinElement.offset() || {
                            left: 0,
                            top: 0
                        },
                        scrollLeft: withinElement.scrollLeft(),
                        scrollTop: withinElement.scrollTop(),
                        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
                        height: isWindow ? withinElement.height() : withinElement.outerHeight()
                    }
                }
            }, $.fn.position = function (options) {
                if (!options || !options.of) return _position.apply(this, arguments);
                options = $.extend({}, options);
                var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of),
                    within = $.position.getWithinInfo(options.within),
                    scrollInfo = $.position.getScrollInfo(within),
                    collision = (options.collision || "flip").split(" "),
                    offsets = {};
                return dimensions = getDimensions(target), target[0].preventDefault && (options.at = "left top"), targetWidth = dimensions.width, targetHeight = dimensions.height, targetOffset = dimensions.offset, basePosition = $.extend({}, targetOffset), $.each(["my", "at"], function () {
                    var horizontalOffset, verticalOffset, pos = (options[this] || "").split(" ");
                    1 === pos.length && (pos = rhorizontal.test(pos[0]) ? pos.concat(["center"]) : rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"]), pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center", pos[1] = rvertical.test(pos[1]) ? pos[1] : "center", horizontalOffset = roffset.exec(pos[0]), verticalOffset = roffset.exec(pos[1]), offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0], options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]]
                }), 1 === collision.length && (collision[1] = collision[0]), "right" === options.at[0] ? basePosition.left += targetWidth : "center" === options.at[0] && (basePosition.left += targetWidth / 2), "bottom" === options.at[1] ? basePosition.top += targetHeight : "center" === options.at[1] && (basePosition.top += targetHeight / 2), atOffset = getOffsets(offsets.at, targetWidth, targetHeight), basePosition.left += atOffset[0], basePosition.top += atOffset[1], this.each(function () {
                    var collisionPosition, using, elem = $(this),
                        elemWidth = elem.outerWidth(),
                        elemHeight = elem.outerHeight(),
                        marginLeft = parseCss(this, "marginLeft"),
                        marginTop = parseCss(this, "marginTop"),
                        collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
                        collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
                        position = $.extend({}, basePosition),
                        myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
                    "right" === options.my[0] ? position.left -= elemWidth : "center" === options.my[0] && (position.left -= elemWidth / 2), "bottom" === options.my[1] ? position.top -= elemHeight : "center" === options.my[1] && (position.top -= elemHeight / 2), position.left += myOffset[0], position.top += myOffset[1], $.support.offsetFractions || (position.left = round(position.left), position.top = round(position.top)), collisionPosition = {
                        marginLeft: marginLeft,
                        marginTop: marginTop
                    }, $.each(["left", "top"], function (i, dir) {
                        $.ui.position[collision[i]] && $.ui.position[collision[i]][dir](position, {
                            targetWidth: targetWidth,
                            targetHeight: targetHeight,
                            elemWidth: elemWidth,
                            elemHeight: elemHeight,
                            collisionPosition: collisionPosition,
                            collisionWidth: collisionWidth,
                            collisionHeight: collisionHeight,
                            offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                            my: options.my,
                            at: options.at,
                            within: within,
                            elem: elem
                        })
                    }), options.using && (using = function (props) {
                        var left = targetOffset.left - position.left,
                            right = left + targetWidth - elemWidth,
                            top = targetOffset.top - position.top,
                            bottom = top + targetHeight - elemHeight,
                            feedback = {
                                target: {
                                    element: target,
                                    left: targetOffset.left,
                                    top: targetOffset.top,
                                    width: targetWidth,
                                    height: targetHeight
                                },
                                element: {
                                    element: elem,
                                    left: position.left,
                                    top: position.top,
                                    width: elemWidth,
                                    height: elemHeight
                                },
                                horizontal: 0 > right ? "left" : left > 0 ? "right" : "center",
                                vertical: 0 > bottom ? "top" : top > 0 ? "bottom" : "middle"
                            };
                        elemWidth > targetWidth && abs(left + right) < targetWidth && (feedback.horizontal = "center"), elemHeight > targetHeight && abs(top + bottom) < targetHeight && (feedback.vertical = "middle"), feedback.important = max(abs(left), abs(right)) > max(abs(top), abs(bottom)) ? "horizontal" : "vertical", options.using.call(this, props, feedback)
                    }), elem.offset($.extend(position, {
                        using: using
                    }))
                })
            }, $.ui.position = {
                fit: {
                    left: function (position, data) {
                        var newOverRight, within = data.within,
                            withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                            outerWidth = within.width,
                            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                            overLeft = withinOffset - collisionPosLeft,
                            overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset;
                        data.collisionWidth > outerWidth ? overLeft > 0 && 0 >= overRight ? (newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset, position.left += overLeft - newOverRight) : position.left = overRight > 0 && 0 >= overLeft ? withinOffset : overLeft > overRight ? withinOffset + outerWidth - data.collisionWidth : withinOffset : overLeft > 0 ? position.left += overLeft : overRight > 0 ? position.left -= overRight : position.left = max(position.left - collisionPosLeft, position.left)
                    },
                    top: function (position, data) {
                        var newOverBottom, within = data.within,
                            withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                            outerHeight = data.within.height,
                            collisionPosTop = position.top - data.collisionPosition.marginTop,
                            overTop = withinOffset - collisionPosTop,
                            overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset;
                        data.collisionHeight > outerHeight ? overTop > 0 && 0 >= overBottom ? (newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset, position.top += overTop - newOverBottom) : position.top = overBottom > 0 && 0 >= overTop ? withinOffset : overTop > overBottom ? withinOffset + outerHeight - data.collisionHeight : withinOffset : overTop > 0 ? position.top += overTop : overBottom > 0 ? position.top -= overBottom : position.top = max(position.top - collisionPosTop, position.top)
                    }
                },
                flip: {
                    left: function (position, data) {
                        var newOverRight, newOverLeft, within = data.within,
                            withinOffset = within.offset.left + within.scrollLeft,
                            outerWidth = within.width,
                            offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                            overLeft = collisionPosLeft - offsetLeft,
                            overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                            myOffset = "left" === data.my[0] ? -data.elemWidth : "right" === data.my[0] ? data.elemWidth : 0,
                            atOffset = "left" === data.at[0] ? data.targetWidth : "right" === data.at[0] ? -data.targetWidth : 0,
                            offset = -2 * data.offset[0];
                        0 > overLeft ? (newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset, (0 > newOverRight || newOverRight < abs(overLeft)) && (position.left += myOffset + atOffset + offset)) : overRight > 0 && (newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft, (newOverLeft > 0 || abs(newOverLeft) < overRight) && (position.left += myOffset + atOffset + offset))
                    },
                    top: function (position, data) {
                        var newOverTop, newOverBottom, within = data.within,
                            withinOffset = within.offset.top + within.scrollTop,
                            outerHeight = within.height,
                            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                            collisionPosTop = position.top - data.collisionPosition.marginTop,
                            overTop = collisionPosTop - offsetTop,
                            overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                            top = "top" === data.my[1],
                            myOffset = top ? -data.elemHeight : "bottom" === data.my[1] ? data.elemHeight : 0,
                            atOffset = "top" === data.at[1] ? data.targetHeight : "bottom" === data.at[1] ? -data.targetHeight : 0,
                            offset = -2 * data.offset[1];
                        0 > overTop ? (newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset, position.top + myOffset + atOffset + offset > overTop && (0 > newOverBottom || newOverBottom < abs(overTop)) && (position.top += myOffset + atOffset + offset)) : overBottom > 0 && (newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop, position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom) && (position.top += myOffset + atOffset + offset))
                    }
                },
                flipfit: {
                    left: function () {
                        $.ui.position.flip.left.apply(this, arguments), $.ui.position.fit.left.apply(this, arguments)
                    },
                    top: function () {
                        $.ui.position.flip.top.apply(this, arguments), $.ui.position.fit.top.apply(this, arguments)
                    }
                }
            },
            function () {
                var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName("body")[0],
                    div = document.createElement("div");
                testElement = document.createElement(body ? "div" : "body"), testElementStyle = {
                    visibility: "hidden",
                    width: 0,
                    height: 0,
                    border: 0,
                    margin: 0,
                    background: "none"
                }, body && $.extend(testElementStyle, {
                    position: "absolute",
                    left: "-1000px",
                    top: "-1000px"
                });
                for (i in testElementStyle) testElement.style[i] = testElementStyle[i];
                testElement.appendChild(div), testElementParent = body || document.documentElement, testElementParent.insertBefore(testElement, testElementParent.firstChild), div.style.cssText = "position: absolute; left: 10.7432222px;", offsetLeft = $(div).offset().left, $.support.offsetFractions = offsetLeft > 10 && 11 > offsetLeft, testElement.innerHTML = "", testElementParent.removeChild(testElement)
            }()
    }(jQuery),
    function ($, undefined) {
        $.widget("ui.progressbar", {
            version: "1.10.3",
            options: {
                max: 100,
                value: 0,
                change: null,
                complete: null
            },
            min: 0,
            _create: function () {
                this.oldValue = this.options.value = this._constrainedValue(), this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
                    role: "progressbar",
                    "aria-valuemin": this.min
                }), this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element), this._refreshValue()
            },
            _destroy: function () {
                this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.valueDiv.remove()
            },
            value: function (newValue) {
                return newValue === undefined ? this.options.value : (this.options.value = this._constrainedValue(newValue), void this._refreshValue())
            },
            _constrainedValue: function (newValue) {
                return newValue === undefined && (newValue = this.options.value), this.indeterminate = newValue === !1, "number" != typeof newValue && (newValue = 0), this.indeterminate ? !1 : Math.min(this.options.max, Math.max(this.min, newValue))
            },
            _setOptions: function (options) {
                var value = options.value;
                delete options.value, this._super(options), this.options.value = this._constrainedValue(value), this._refreshValue()
            },
            _setOption: function (key, value) {
                "max" === key && (value = Math.max(this.min, value)), this._super(key, value)
            },
            _percentage: function () {
                return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min)
            },
            _refreshValue: function () {
                var value = this.options.value,
                    percentage = this._percentage();
                this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%"), this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv))) : (this.element.attr({
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": value
                }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== value && (this.oldValue = value, this._trigger("change")), value === this.options.max && this._trigger("complete")
            }
        })
    }(jQuery),
    function ($) {
        var numPages = 5;
        $.widget("ui.slider", $.ui.mouse, {
            version: "1.10.3",
            widgetEventPrefix: "slide",
            options: {
                animate: !1,
                distance: 0,
                max: 100,
                min: 0,
                orientation: "horizontal",
                range: !1,
                step: 1,
                value: 0,
                values: null,
                change: null,
                slide: null,
                start: null,
                stop: null
            },
            _create: function () {
                this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget ui-widget-content ui-corner-all"), this._refresh(), this._setOption("disabled", this.options.disabled), this._animateOff = !1
            },
            _refresh: function () {
                this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
            },
            _createHandles: function () {
                var i, handleCount, options = this.options,
                    existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                    handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                    handles = [];
                for (handleCount = options.values && options.values.length || 1, existingHandles.length > handleCount && (existingHandles.slice(handleCount).remove(), existingHandles = existingHandles.slice(0, handleCount)), i = existingHandles.length; handleCount > i; i++) handles.push(handle);
                this.handles = existingHandles.add($(handles.join("")).appendTo(this.element)), this.handle = this.handles.eq(0), this.handles.each(function (i) {
                    $(this).data("ui-slider-handle-index", i)
                })
            },
            _createRange: function () {
                var options = this.options,
                    classes = "";
                options.range ? (options.range === !0 && (options.values ? options.values.length && 2 !== options.values.length ? options.values = [options.values[0], options.values[0]] : $.isArray(options.values) && (options.values = options.values.slice(0)) : options.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
                    left: "",
                    bottom: ""
                }) : (this.range = $("<div></div>").appendTo(this.element), classes = "ui-slider-range ui-widget-header ui-corner-all"), this.range.addClass(classes + ("min" === options.range || "max" === options.range ? " ui-slider-range-" + options.range : ""))) : this.range = $([])
            },
            _setupEvents: function () {
                var elements = this.handles.add(this.range).filter("a");
                this._off(elements), this._on(elements, this._handleEvents), this._hoverable(elements), this._focusable(elements)
            },
            _destroy: function () {
                this.handles.remove(), this.range.remove(), this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-widget ui-widget-content ui-corner-all"), this._mouseDestroy()
            },
            _mouseCapture: function (event) {
                var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this,
                    o = this.options;
                return o.disabled ? !1 : (this.elementSize = {
                    width: this.element.outerWidth(),
                    height: this.element.outerHeight()
                }, this.elementOffset = this.element.offset(), position = {
                    x: event.pageX,
                    y: event.pageY
                }, normValue = this._normValueFromMouse(position), distance = this._valueMax() - this._valueMin() + 1, this.handles.each(function (i) {
                    var thisDistance = Math.abs(normValue - that.values(i));
                    (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) && (distance = thisDistance, closestHandle = $(this), index = i)
                }), allowed = this._start(event, index), allowed === !1 ? !1 : (this._mouseSliding = !0, this._handleIndex = index, closestHandle.addClass("ui-state-active").focus(), offset = closestHandle.offset(), mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = mouseOverHandle ? {
                    left: 0,
                    top: 0
                } : {
                    left: event.pageX - offset.left - closestHandle.width() / 2,
                    top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
                }, this.handles.hasClass("ui-state-hover") || this._slide(event, index, normValue), this._animateOff = !0, !0))
            },
            _mouseStart: function () {
                return !0
            },
            _mouseDrag: function (event) {
                var position = {
                        x: event.pageX,
                        y: event.pageY
                    },
                    normValue = this._normValueFromMouse(position);
                return this._slide(event, this._handleIndex, normValue), !1
            },
            _mouseStop: function (event) {
                return this.handles.removeClass("ui-state-active"), this._mouseSliding = !1, this._stop(event, this._handleIndex), this._change(event, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1, !1
            },
            _detectOrientation: function () {
                this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
            },
            _normValueFromMouse: function (position) {
                var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
                return "horizontal" === this.orientation ? (pixelTotal = this.elementSize.width, pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (pixelTotal = this.elementSize.height, pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)), percentMouse = pixelMouse / pixelTotal, percentMouse > 1 && (percentMouse = 1), 0 > percentMouse && (percentMouse = 0), "vertical" === this.orientation && (percentMouse = 1 - percentMouse), valueTotal = this._valueMax() - this._valueMin(), valueMouse = this._valueMin() + percentMouse * valueTotal, this._trimAlignValue(valueMouse)
            },
            _start: function (event, index) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                return this.options.values && this.options.values.length && (uiHash.value = this.values(index), uiHash.values = this.values()), this._trigger("start", event, uiHash)
            },
            _slide: function (event, index, newVal) {
                var otherVal, newValues, allowed;
                this.options.values && this.options.values.length ? (otherVal = this.values(index ? 0 : 1), 2 === this.options.values.length && this.options.range === !0 && (0 === index && newVal > otherVal || 1 === index && otherVal > newVal) && (newVal = otherVal), newVal !== this.values(index) && (newValues = this.values(), newValues[index] = newVal, allowed = this._trigger("slide", event, {
                    handle: this.handles[index],
                    value: newVal,
                    values: newValues
                }), otherVal = this.values(index ? 0 : 1), allowed !== !1 && this.values(index, newVal, !0))) : newVal !== this.value() && (allowed = this._trigger("slide", event, {
                    handle: this.handles[index],
                    value: newVal
                }), allowed !== !1 && this.value(newVal))
            },
            _stop: function (event, index) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                this.options.values && this.options.values.length && (uiHash.value = this.values(index), uiHash.values = this.values()), this._trigger("stop", event, uiHash)
            },
            _change: function (event, index) {
                if (!this._keySliding && !this._mouseSliding) {
                    var uiHash = {
                        handle: this.handles[index],
                        value: this.value()
                    };
                    this.options.values && this.options.values.length && (uiHash.value = this.values(index), uiHash.values = this.values()), this._lastChangedValue = index, this._trigger("change", event, uiHash)
                }
            },
            value: function (newValue) {
                return arguments.length ? (this.options.value = this._trimAlignValue(newValue), this._refreshValue(), void this._change(null, 0)) : this._value()
            },
            values: function (index, newValue) {
                var vals, newValues, i;
                if (arguments.length > 1) return this.options.values[index] = this._trimAlignValue(newValue), this._refreshValue(), void this._change(null, index);
                if (!arguments.length) return this._values();
                if (!$.isArray(arguments[0])) return this.options.values && this.options.values.length ? this._values(index) : this.value();
                for (vals = this.options.values, newValues = arguments[0], i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(newValues[i]), this._change(null, i);
                this._refreshValue()
            },
            _setOption: function (key, value) {
                var i, valsLength = 0;
                switch ("range" === key && this.options.range === !0 && ("min" === value ? (this.options.value = this._values(0), this.options.values = null) : "max" === value && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), $.isArray(this.options.values) && (valsLength = this.options.values.length), $.Widget.prototype._setOption.apply(this, arguments), key) {
                case "orientation":
                    this._detectOrientation(), this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation), this._refreshValue();
                    break;
                case "value":
                    this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
                    break;
                case "values":
                    for (this._animateOff = !0, this._refreshValue(), i = 0; valsLength > i; i += 1) this._change(null, i);
                    this._animateOff = !1;
                    break;
                case "min":
                case "max":
                    this._animateOff = !0, this._refreshValue(), this._animateOff = !1;
                    break;
                case "range":
                    this._animateOff = !0, this._refresh(), this._animateOff = !1
                }
            },
            _value: function () {
                var val = this.options.value;
                return val = this._trimAlignValue(val)
            },
            _values: function (index) {
                var val, vals, i;
                if (arguments.length) return val = this.options.values[index], val = this._trimAlignValue(val);
                if (this.options.values && this.options.values.length) {
                    for (vals = this.options.values.slice(), i = 0; i < vals.length; i += 1) vals[i] = this._trimAlignValue(vals[i]);
                    return vals
                }
                return []
            },
            _trimAlignValue: function (val) {
                if (val <= this._valueMin()) return this._valueMin();
                if (val >= this._valueMax()) return this._valueMax();
                var step = this.options.step > 0 ? this.options.step : 1,
                    valModStep = (val - this._valueMin()) % step,
                    alignValue = val - valModStep;
                return 2 * Math.abs(valModStep) >= step && (alignValue += valModStep > 0 ? step : -step), parseFloat(alignValue.toFixed(5))
            },
            _valueMin: function () {
                return this.options.min
            },
            _valueMax: function () {
                return this.options.max
            },
            _refreshValue: function () {
                var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range,
                    o = this.options,
                    that = this,
                    animate = this._animateOff ? !1 : o.animate,
                    _set = {};
                this.options.values && this.options.values.length ? this.handles.each(function (i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100, _set["horizontal" === that.orientation ? "left" : "bottom"] = valPercent + "%", $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), that.options.range === !0 && ("horizontal" === that.orientation ? (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                        left: valPercent + "%"
                    }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                        width: valPercent - lastValPercent + "%"
                    }, {
                        queue: !1,
                        duration: o.animate
                    })) : (0 === i && that.range.stop(1, 1)[animate ? "animate" : "css"]({
                        bottom: valPercent + "%"
                    }, o.animate), 1 === i && that.range[animate ? "animate" : "css"]({
                        height: valPercent - lastValPercent + "%"
                    }, {
                        queue: !1,
                        duration: o.animate
                    }))), lastValPercent = valPercent
                }) : (value = this.value(), valueMin = this._valueMin(), valueMax = this._valueMax(), valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0, _set["horizontal" === this.orientation ? "left" : "bottom"] = valPercent + "%", this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate), "min" === oRange && "horizontal" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                    width: valPercent + "%"
                }, o.animate), "max" === oRange && "horizontal" === this.orientation && this.range[animate ? "animate" : "css"]({
                    width: 100 - valPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                }), "min" === oRange && "vertical" === this.orientation && this.range.stop(1, 1)[animate ? "animate" : "css"]({
                    height: valPercent + "%"
                }, o.animate), "max" === oRange && "vertical" === this.orientation && this.range[animate ? "animate" : "css"]({
                    height: 100 - valPercent + "%"
                }, {
                    queue: !1,
                    duration: o.animate
                }))
            },
            _handleEvents: {
                keydown: function (event) {
                    var allowed, curVal, newVal, step, index = $(event.target).data("ui-slider-handle-index");
                    switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (event.preventDefault(), !this._keySliding && (this._keySliding = !0, $(event.target).addClass("ui-state-active"), allowed = this._start(event, index), allowed === !1)) return
                    }
                    switch (step = this.options.step, curVal = newVal = this.options.values && this.options.values.length ? this.values(index) : this.value(), event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) return;
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) return;
                        newVal = this._trimAlignValue(curVal - step)
                    }
                    this._slide(event, index, newVal)
                },
                click: function (event) {
                    event.preventDefault()
                },
                keyup: function (event) {
                    var index = $(event.target).data("ui-slider-handle-index");
                    this._keySliding && (this._keySliding = !1, this._stop(event, index), this._change(event, index), $(event.target).removeClass("ui-state-active"))
                }
            }
        })
    }(jQuery),
    function ($) {
        function modifier(fn) {
            return function () {
                var previous = this.element.val();
                fn.apply(this, arguments), this._refresh(), previous !== this.element.val() && this._trigger("change")
            }
        }
        $.widget("ui.spinner", {
            version: "1.10.3",
            defaultElement: "<input>",
            widgetEventPrefix: "spin",
            options: {
                culture: null,
                icons: {
                    down: "ui-icon-triangle-1-s",
                    up: "ui-icon-triangle-1-n"
                },
                incremental: !0,
                max: null,
                min: null,
                numberFormat: null,
                page: 10,
                step: 1,
                change: null,
                spin: null,
                start: null,
                stop: null
            },
            _create: function () {
                this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
                    beforeunload: function () {
                        this.element.removeAttr("autocomplete")
                    }
                })
            },
            _getCreateOptions: function () {
                var options = {},
                    element = this.element;
                return $.each(["min", "max", "step"], function (i, option) {
                    var value = element.attr(option);
                    void 0 !== value && value.length && (options[option] = value)
                }), options
            },
            _events: {
                keydown: function (event) {
                    this._start(event) && this._keydown(event) && event.preventDefault()
                },
                keyup: "_stop",
                focus: function () {
                    this.previous = this.element.val()
                },
                blur: function (event) {
                    return this.cancelBlur ? void delete this.cancelBlur : (this._stop(), this._refresh(), void(this.previous !== this.element.val() && this._trigger("change", event)))
                },
                mousewheel: function (event, delta) {
                    if (delta) {
                        if (!this.spinning && !this._start(event)) return !1;
                        this._spin((delta > 0 ? 1 : -1) * this.options.step, event), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
                            this.spinning && this._stop(event)
                        }, 100), event.preventDefault()
                    }
                },
                "mousedown .ui-spinner-button": function (event) {
                    function checkFocus() {
                        var isActive = this.element[0] === this.document[0].activeElement;
                        isActive || (this.element.focus(), this.previous = previous, this._delay(function () {
                            this.previous = previous
                        }))
                    }
                    var previous;
                    previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val(), event.preventDefault(), checkFocus.call(this), this.cancelBlur = !0, this._delay(function () {
                        delete this.cancelBlur, checkFocus.call(this)
                    }), this._start(event) !== !1 && this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event)
                },
                "mouseup .ui-spinner-button": "_stop",
                "mouseenter .ui-spinner-button": function (event) {
                    return $(event.currentTarget).hasClass("ui-state-active") ? this._start(event) === !1 ? !1 : void this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event) : void 0
                },
                "mouseleave .ui-spinner-button": "_stop"
            },
            _draw: function () {
                var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
                this.element.attr("role", "spinbutton"), this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all"), this.buttons.height() > Math.ceil(.5 * uiSpinner.height()) && uiSpinner.height() > 0 && uiSpinner.height(uiSpinner.height()), this.options.disabled && this.disable()
            },
            _keydown: function (event) {
                var options = this.options,
                    keyCode = $.ui.keyCode;
                switch (event.keyCode) {
                case keyCode.UP:
                    return this._repeat(null, 1, event), !0;
                case keyCode.DOWN:
                    return this._repeat(null, -1, event), !0;
                case keyCode.PAGE_UP:
                    return this._repeat(null, options.page, event), !0;
                case keyCode.PAGE_DOWN:
                    return this._repeat(null, -options.page, event), !0
                }
                return !1
            },
            _uiSpinnerHtml: function () {
                return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"
            },
            _buttonHtml: function () {
                return "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon " + this.options.icons.up + "'>&#9650;</span></a><a class='ui-spinner-button ui-spinner-down ui-corner-br'><span class='ui-icon " + this.options.icons.down + "'>&#9660;</span></a>"
            },
            _start: function (event) {
                return this.spinning || this._trigger("start", event) !== !1 ? (this.counter || (this.counter = 1), this.spinning = !0, !0) : !1
            },
            _repeat: function (i, steps, event) {
                i = i || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
                    this._repeat(40, steps, event)
                }, i), this._spin(steps * this.options.step, event)
            },
            _spin: function (step, event) {
                var value = this.value() || 0;
                this.counter || (this.counter = 1), value = this._adjustValue(value + step * this._increment(this.counter)), this.spinning && this._trigger("spin", event, {
                    value: value
                }) === !1 || (this._value(value), this.counter++)
            },
            _increment: function (i) {
                var incremental = this.options.incremental;
                return incremental ? $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 5e4 - i * i / 500 + 17 * i / 200 + 1) : 1
            },
            _precision: function () {
                var precision = this._precisionOf(this.options.step);
                return null !== this.options.min && (precision = Math.max(precision, this._precisionOf(this.options.min))), precision
            },
            _precisionOf: function (num) {
                var str = num.toString(),
                    decimal = str.indexOf(".");
                return -1 === decimal ? 0 : str.length - decimal - 1
            },
            _adjustValue: function (value) {
                var base, aboveMin, options = this.options;
                return base = null !== options.min ? options.min : 0, aboveMin = value - base, aboveMin = Math.round(aboveMin / options.step) * options.step, value = base + aboveMin, value = parseFloat(value.toFixed(this._precision())), null !== options.max && value > options.max ? options.max : null !== options.min && value < options.min ? options.min : value
            },
            _stop: function (event) {
                this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", event))
            },
            _setOption: function (key, value) {
                if ("culture" === key || "numberFormat" === key) {
                    var prevValue = this._parse(this.element.val());
                    return this.options[key] = value, void this.element.val(this._format(prevValue))
                }("max" === key || "min" === key || "step" === key) && "string" == typeof value && (value = this._parse(value)), "icons" === key && (this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up), this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down)), this._super(key, value), "disabled" === key && (value ? (this.element.prop("disabled", !0), this.buttons.button("disable")) : (this.element.prop("disabled", !1), this.buttons.button("enable")))
            },
            _setOptions: modifier(function (options) {
                this._super(options), this._value(this.element.val())
            }),
            _parse: function (val) {
                return "string" == typeof val && "" !== val && (val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val), "" === val || isNaN(val) ? null : val
            },
            _format: function (value) {
                return "" === value ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value
            },
            _refresh: function () {
                this.element.attr({
                    "aria-valuemin": this.options.min,
                    "aria-valuemax": this.options.max,
                    "aria-valuenow": this._parse(this.element.val())
                })
            },
            _value: function (value, allowAny) {
                var parsed;
                "" !== value && (parsed = this._parse(value), null !== parsed && (allowAny || (parsed = this._adjustValue(parsed)), value = this._format(parsed))), this.element.val(value), this._refresh()
            },
            _destroy: function () {
                this.element.removeClass("ui-spinner-input").prop("disabled", !1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"), this.uiSpinner.replaceWith(this.element)
            },
            stepUp: modifier(function (steps) {
                this._stepUp(steps)
            }),
            _stepUp: function (steps) {
                this._start() && (this._spin((steps || 1) * this.options.step), this._stop())
            },
            stepDown: modifier(function (steps) {
                this._stepDown(steps)
            }),
            _stepDown: function (steps) {
                this._start() && (this._spin((steps || 1) * -this.options.step), this._stop())
            },
            pageUp: modifier(function (pages) {
                this._stepUp((pages || 1) * this.options.page)
            }),
            pageDown: modifier(function (pages) {
                this._stepDown((pages || 1) * this.options.page)
            }),
            value: function (newVal) {
                return arguments.length ? void modifier(this._value).call(this, newVal) : this._parse(this.element.val())
            },
            widget: function () {
                return this.uiSpinner
            }
        })
    }(jQuery),
    function ($, undefined) {
        function getNextTabId() {
            return ++tabId
        }

        function isLocal(anchor) {
            return anchor.hash.length > 1 && decodeURIComponent(anchor.href.replace(rhash, "")) === decodeURIComponent(location.href.replace(rhash, ""))
        }
        var tabId = 0,
            rhash = /#.*$/;
        $.widget("ui.tabs", {
            version: "1.10.3",
            delay: 300,
            options: {
                active: null,
                collapsible: !1,
                event: "click",
                heightStyle: "content",
                hide: null,
                show: null,
                activate: null,
                beforeActivate: null,
                beforeLoad: null,
                load: null
            },
            _create: function () {
                var that = this,
                    options = this.options;
                this.running = !1, this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible).delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function (event) {
                    $(this).is(".ui-state-disabled") && event.preventDefault()
                }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function () {
                    $(this).closest("li").is(".ui-state-disabled") && this.blur()
                }), this._processTabs(), options.active = this._initialActive(), $.isArray(options.disabled) && (options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function (li) {
                    return that.tabs.index(li)
                }))).sort()), this.active = this.options.active !== !1 && this.anchors.length ? this._findActive(options.active) : $(), this._refresh(), this.active.length && this.load(options.active)
            },
            _initialActive: function () {
                var active = this.options.active,
                    collapsible = this.options.collapsible,
                    locationHash = location.hash.substring(1);
                return null === active && (locationHash && this.tabs.each(function (i, tab) {
                    return $(tab).attr("aria-controls") === locationHash ? (active = i, !1) : void 0
                }), null === active && (active = this.tabs.index(this.tabs.filter(".ui-tabs-active"))), (null === active || -1 === active) && (active = this.tabs.length ? 0 : !1)), active !== !1 && (active = this.tabs.index(this.tabs.eq(active)), -1 === active && (active = collapsible ? !1 : 0)), !collapsible && active === !1 && this.anchors.length && (active = 0), active
            },
            _getCreateEventData: function () {
                return {
                    tab: this.active,
                    panel: this.active.length ? this._getPanelForTab(this.active) : $()
                }
            },
            _tabKeydown: function (event) {
                var focusedTab = $(this.document[0].activeElement).closest("li"),
                    selectedIndex = this.tabs.index(focusedTab),
                    goingForward = !0;
                if (!this._handlePageNav(event)) {
                    switch (event.keyCode) {
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                        selectedIndex++;
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.LEFT:
                        goingForward = !1, selectedIndex--;
                        break;
                    case $.ui.keyCode.END:
                        selectedIndex = this.anchors.length - 1;
                        break;
                    case $.ui.keyCode.HOME:
                        selectedIndex = 0;
                        break;
                    case $.ui.keyCode.SPACE:
                        return event.preventDefault(), clearTimeout(this.activating), void this._activate(selectedIndex);
                    case $.ui.keyCode.ENTER:
                        return event.preventDefault(), clearTimeout(this.activating), void this._activate(selectedIndex === this.options.active ? !1 : selectedIndex);
                    default:
                        return
                    }
                    event.preventDefault(), clearTimeout(this.activating), selectedIndex = this._focusNextTab(selectedIndex, goingForward), event.ctrlKey || (focusedTab.attr("aria-selected", "false"), this.tabs.eq(selectedIndex).attr("aria-selected", "true"), this.activating = this._delay(function () {
                        this.option("active", selectedIndex)
                    }, this.delay))
                }
            },
            _panelKeydown: function (event) {
                this._handlePageNav(event) || event.ctrlKey && event.keyCode === $.ui.keyCode.UP && (event.preventDefault(), this.active.focus())
            },
            _handlePageNav: function (event) {
                return event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0
            },
            _findNextTab: function (index, goingForward) {
                function constrain() {
                    return index > lastTabIndex && (index = 0), 0 > index && (index = lastTabIndex), index
                }
                for (var lastTabIndex = this.tabs.length - 1; - 1 !== $.inArray(constrain(), this.options.disabled);) index = goingForward ? index + 1 : index - 1;
                return index
            },
            _focusNextTab: function (index, goingForward) {
                return index = this._findNextTab(index, goingForward), this.tabs.eq(index).focus(), index
            },
            _setOption: function (key, value) {
                return "active" === key ? void this._activate(value) : "disabled" === key ? void this._setupDisabled(value) : (this._super(key, value), "collapsible" === key && (this.element.toggleClass("ui-tabs-collapsible", value), value || this.options.active !== !1 || this._activate(0)), "event" === key && this._setupEvents(value), void("heightStyle" === key && this._setupHeightStyle(value)))
            },
            _tabId: function (tab) {
                return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId()
            },
            _sanitizeSelector: function (hash) {
                return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
            },
            refresh: function () {
                var options = this.options,
                    lis = this.tablist.children(":has(a[href])");
                options.disabled = $.map(lis.filter(".ui-state-disabled"), function (tab) {
                    return lis.index(tab)
                }), this._processTabs(), options.active !== !1 && this.anchors.length ? this.active.length && !$.contains(this.tablist[0], this.active[0]) ? this.tabs.length === options.disabled.length ? (options.active = !1, this.active = $()) : this._activate(this._findNextTab(Math.max(0, options.active - 1), !1)) : options.active = this.tabs.index(this.active) : (options.active = !1, this.active = $()), this._refresh()
            },
            _refresh: function () {
                this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
                    "aria-selected": "false",
                    tabIndex: -1
                }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                }), this.active.length ? (this.active.addClass("ui-tabs-active ui-state-active").attr({
                    "aria-selected": "true",
                    tabIndex: 0
                }), this._getPanelForTab(this.active).show().attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                })) : this.tabs.eq(0).attr("tabIndex", 0)
            },
            _processTabs: function () {
                var that = this;
                this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist"), this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
                    role: "tab",
                    tabIndex: -1
                }), this.anchors = this.tabs.map(function () {
                    return $("a", this)[0]
                }).addClass("ui-tabs-anchor").attr({
                    role: "presentation",
                    tabIndex: -1
                }), this.panels = $(), this.anchors.each(function (i, anchor) {
                    var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr("id"),
                        tab = $(anchor).closest("li"),
                        originalAriaControls = tab.attr("aria-controls");
                    isLocal(anchor) ? (selector = anchor.hash, panel = that.element.find(that._sanitizeSelector(selector))) : (panelId = that._tabId(tab), selector = "#" + panelId, panel = that.element.find(selector), panel.length || (panel = that._createPanel(panelId), panel.insertAfter(that.panels[i - 1] || that.tablist)), panel.attr("aria-live", "polite")), panel.length && (that.panels = that.panels.add(panel)), originalAriaControls && tab.data("ui-tabs-aria-controls", originalAriaControls), tab.attr({
                        "aria-controls": selector.substring(1),
                        "aria-labelledby": anchorId
                    }), panel.attr("aria-labelledby", anchorId)
                }), this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel")
            },
            _getList: function () {
                return this.element.find("ol,ul").eq(0)
            },
            _createPanel: function (id) {
                return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", !0)
            },
            _setupDisabled: function (disabled) {
                $.isArray(disabled) && (disabled.length ? disabled.length === this.anchors.length && (disabled = !0) : disabled = !1);
                for (var li, i = 0; li = this.tabs[i]; i++) disabled === !0 || -1 !== $.inArray(i, disabled) ? $(li).addClass("ui-state-disabled").attr("aria-disabled", "true") : $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
                this.options.disabled = disabled
            },
            _setupEvents: function (event) {
                var events = {
                    click: function (event) {
                        event.preventDefault()
                    }
                };
                event && $.each(event.split(" "), function (index, eventName) {
                    events[eventName] = "_eventHandler"
                }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(this.anchors, events), this._on(this.tabs, {
                    keydown: "_tabKeydown"
                }), this._on(this.panels, {
                    keydown: "_panelKeydown"
                }), this._focusable(this.tabs), this._hoverable(this.tabs)
            },
            _setupHeightStyle: function (heightStyle) {
                var maxHeight, parent = this.element.parent();
                "fill" === heightStyle ? (maxHeight = parent.height(), maxHeight -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function () {
                    var elem = $(this),
                        position = elem.css("position");
                    "absolute" !== position && "fixed" !== position && (maxHeight -= elem.outerHeight(!0))
                }), this.element.children().not(this.panels).each(function () {
                    maxHeight -= $(this).outerHeight(!0)
                }), this.panels.each(function () {
                    $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()))
                }).css("overflow", "auto")) : "auto" === heightStyle && (maxHeight = 0, this.panels.each(function () {
                    maxHeight = Math.max(maxHeight, $(this).height("").height())
                }).height(maxHeight))
            },
            _eventHandler: function (event) {
                var options = this.options,
                    active = this.active,
                    anchor = $(event.currentTarget),
                    tab = anchor.closest("li"),
                    clickedIsActive = tab[0] === active[0],
                    collapsing = clickedIsActive && options.collapsible,
                    toShow = collapsing ? $() : this._getPanelForTab(tab),
                    toHide = active.length ? this._getPanelForTab(active) : $(),
                    eventData = {
                        oldTab: active,
                        oldPanel: toHide,
                        newTab: collapsing ? $() : tab,
                        newPanel: toShow
                    };
                event.preventDefault(), tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || clickedIsActive && !options.collapsible || this._trigger("beforeActivate", event, eventData) === !1 || (options.active = collapsing ? !1 : this.tabs.index(tab), this.active = clickedIsActive ? $() : tab, this.xhr && this.xhr.abort(), toHide.length || toShow.length || $.error("jQuery UI Tabs: Mismatching fragment identifier."), toShow.length && this.load(this.tabs.index(tab), event), this._toggle(event, eventData))
            },
            _toggle: function (event, eventData) {
                function complete() {
                    that.running = !1, that._trigger("activate", event, eventData)
                }

                function show() {
                    eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active"), toShow.length && that.options.show ? that._show(toShow, that.options.show, complete) : (toShow.show(), complete())
                }
                var that = this,
                    toShow = eventData.newPanel,
                    toHide = eventData.oldPanel;
                this.running = !0, toHide.length && this.options.hide ? this._hide(toHide, this.options.hide, function () {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), show()
                }) : (eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"), toHide.hide(), show()), toHide.attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                }), eventData.oldTab.attr("aria-selected", "false"), toShow.length && toHide.length ? eventData.oldTab.attr("tabIndex", -1) : toShow.length && this.tabs.filter(function () {
                    return 0 === $(this).attr("tabIndex")
                }).attr("tabIndex", -1), toShow.attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                }), eventData.newTab.attr({
                    "aria-selected": "true",
                    tabIndex: 0
                })
            },
            _activate: function (index) {
                var anchor, active = this._findActive(index);
                active[0] !== this.active[0] && (active.length || (active = this.active), anchor = active.find(".ui-tabs-anchor")[0], this._eventHandler({
                    target: anchor,
                    currentTarget: anchor,
                    preventDefault: $.noop
                }))
            },
            _findActive: function (index) {
                return index === !1 ? $() : this.tabs.eq(index)
            },
            _getIndex: function (index) {
                return "string" == typeof index && (index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"))), index
            },
            _destroy: function () {
                this.xhr && this.xhr.abort(), this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"), this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"), this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function () {
                    $.data(this, "ui-tabs-destroy") ? $(this).remove() : $(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")
                }), this.tabs.each(function () {
                    var li = $(this),
                        prev = li.data("ui-tabs-aria-controls");
                    prev ? li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls") : li.removeAttr("aria-controls")
                }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "")
            },
            enable: function (index) {
                var disabled = this.options.disabled;
                disabled !== !1 && (index === undefined ? disabled = !1 : (index = this._getIndex(index), disabled = $.isArray(disabled) ? $.map(disabled, function (num) {
                    return num !== index ? num : null
                }) : $.map(this.tabs, function (li, num) {
                    return num !== index ? num : null
                })), this._setupDisabled(disabled))
            },
            disable: function (index) {
                var disabled = this.options.disabled;
                if (disabled !== !0) {
                    if (index === undefined) disabled = !0;
                    else {
                        if (index = this._getIndex(index), -1 !== $.inArray(index, disabled)) return;
                        disabled = $.isArray(disabled) ? $.merge([index], disabled).sort() : [index]
                    }
                    this._setupDisabled(disabled)
                }
            },
            load: function (index, event) {
                index = this._getIndex(index);
                var that = this,
                    tab = this.tabs.eq(index),
                    anchor = tab.find(".ui-tabs-anchor"),
                    panel = this._getPanelForTab(tab),
                    eventData = {
                        tab: tab,
                        panel: panel
                    };
                isLocal(anchor[0]) || (this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData)), this.xhr && "canceled" !== this.xhr.statusText && (tab.addClass("ui-tabs-loading"), panel.attr("aria-busy", "true"), this.xhr.success(function (response) {
                    setTimeout(function () {
                        panel.html(response), that._trigger("load", event, eventData)
                    }, 1)
                }).complete(function (jqXHR, status) {
                    setTimeout(function () {
                        "abort" === status && that.panels.stop(!1, !0), tab.removeClass("ui-tabs-loading"), panel.removeAttr("aria-busy"), jqXHR === that.xhr && delete that.xhr
                    }, 1)
                })))
            },
            _ajaxSettings: function (anchor, event, eventData) {
                var that = this;
                return {
                    url: anchor.attr("href"),
                    beforeSend: function (jqXHR, settings) {
                        return that._trigger("beforeLoad", event, $.extend({
                            jqXHR: jqXHR,
                            ajaxSettings: settings
                        }, eventData))
                    }
                }
            },
            _getPanelForTab: function (tab) {
                var id = $(tab).attr("aria-controls");
                return this.element.find(this._sanitizeSelector("#" + id))
            }
        })
    }(jQuery),
    function ($) {
        function addDescribedBy(elem, id) {
            var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
            describedby.push(id), elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")))
        }

        function removeDescribedBy(elem) {
            var id = elem.data("ui-tooltip-id"),
                describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
                index = $.inArray(id, describedby); - 1 !== index && describedby.splice(index, 1), elem.removeData("ui-tooltip-id"), describedby = $.trim(describedby.join(" ")), describedby ? elem.attr("aria-describedby", describedby) : elem.removeAttr("aria-describedby")
        }
        var increments = 0;
        $.widget("ui.tooltip", {
            version: "1.10.3",
            options: {
                content: function () {
                    var title = $(this).attr("title") || "";
                    return $("<a>").text(title).html()
                },
                hide: !0,
                items: "[title]:not([disabled])",
                position: {
                    my: "left top+15",
                    at: "left bottom",
                    collision: "flipfit flip"
                },
                show: !0,
                tooltipClass: null,
                track: !1,
                close: null,
                open: null
            },
            _create: function () {
                this._on({
                    mouseover: "open",
                    focusin: "open"
                }), this.tooltips = {}, this.parents = {}, this.options.disabled && this._disable()
            },
            _setOption: function (key, value) {
                var that = this;
                return "disabled" === key ? (this[value ? "_disable" : "_enable"](), void(this.options[key] = value)) : (this._super(key, value), void("content" === key && $.each(this.tooltips, function (id, element) {
                    that._updateContent(element)
                })))
            },
            _disable: function () {
                var that = this;
                $.each(this.tooltips, function (id, element) {
                    var event = $.Event("blur");
                    event.target = event.currentTarget = element[0], that.close(event, !0)
                }), this.element.find(this.options.items).addBack().each(function () {
                    var element = $(this);
                    element.is("[title]") && element.data("ui-tooltip-title", element.attr("title")).attr("title", "")
                })
            },
            _enable: function () {
                this.element.find(this.options.items).addBack().each(function () {
                    var element = $(this);
                    element.data("ui-tooltip-title") && element.attr("title", element.data("ui-tooltip-title"))
                })
            },
            open: function (event) {
                var that = this,
                    target = $(event ? event.target : this.element).closest(this.options.items);
                target.length && !target.data("ui-tooltip-id") && (target.attr("title") && target.data("ui-tooltip-title", target.attr("title")), target.data("ui-tooltip-open", !0), event && "mouseover" === event.type && target.parents().each(function () {
                    var blurEvent, parent = $(this);
                    parent.data("ui-tooltip-open") && (blurEvent = $.Event("blur"), blurEvent.target = blurEvent.currentTarget = this, that.close(blurEvent, !0)), parent.attr("title") && (parent.uniqueId(), that.parents[this.id] = {
                        element: this,
                        title: parent.attr("title")
                    }, parent.attr("title", ""))
                }), this._updateContent(target, event))
            },
            _updateContent: function (target, event) {
                var content, contentOption = this.options.content,
                    that = this,
                    eventType = event ? event.type : null;
                return "string" == typeof contentOption ? this._open(event, target, contentOption) : (content = contentOption.call(target[0], function (response) {
                    target.data("ui-tooltip-open") && that._delay(function () {
                        event && (event.type = eventType), this._open(event, target, response)
                    })
                }), void(content && this._open(event, target, content)))
            },
            _open: function (event, target, content) {
                function position(event) {
                    positionOption.of = event, tooltip.is(":hidden") || tooltip.position(positionOption)
                }
                var tooltip, events, delayedShow, positionOption = $.extend({}, this.options.position);
                if (content) {
                    if (tooltip = this._find(target), tooltip.length) return void tooltip.find(".ui-tooltip-content").html(content);
                    target.is("[title]") && (event && "mouseover" === event.type ? target.attr("title", "") : target.removeAttr("title")), tooltip = this._tooltip(target), addDescribedBy(target, tooltip.attr("id")), tooltip.find(".ui-tooltip-content").html(content), this.options.track && event && /^mouse/.test(event.type) ? (this._on(this.document, {
                        mousemove: position
                    }), position(event)) : tooltip.position($.extend({
                        of: target
                    }, this.options.position)), tooltip.hide(), this._show(tooltip, this.options.show), this.options.show && this.options.show.delay && (delayedShow = this.delayedShow = setInterval(function () {
                        tooltip.is(":visible") && (position(positionOption.of), clearInterval(delayedShow))
                    }, $.fx.interval)), this._trigger("open", event, {
                        tooltip: tooltip
                    }), events = {
                        keyup: function (event) {
                            if (event.keyCode === $.ui.keyCode.ESCAPE) {
                                var fakeEvent = $.Event(event);
                                fakeEvent.currentTarget = target[0], this.close(fakeEvent, !0)
                            }
                        },
                        remove: function () {
                            this._removeTooltip(tooltip)
                        }
                    }, event && "mouseover" !== event.type || (events.mouseleave = "close"), event && "focusin" !== event.type || (events.focusout = "close"), this._on(!0, target, events)
                }
            },
            close: function (event) {
                var that = this,
                    target = $(event ? event.currentTarget : this.element),
                    tooltip = this._find(target);
                this.closing || (clearInterval(this.delayedShow), target.data("ui-tooltip-title") && target.attr("title", target.data("ui-tooltip-title")), removeDescribedBy(target), tooltip.stop(!0), this._hide(tooltip, this.options.hide, function () {
                    that._removeTooltip($(this))
                }), target.removeData("ui-tooltip-open"), this._off(target, "mouseleave focusout keyup"), target[0] !== this.element[0] && this._off(target, "remove"), this._off(this.document, "mousemove"), event && "mouseleave" === event.type && $.each(this.parents, function (id, parent) {
                    $(parent.element).attr("title", parent.title), delete that.parents[id]
                }), this.closing = !0, this._trigger("close", event, {
                    tooltip: tooltip
                }), this.closing = !1)
            },
            _tooltip: function (element) {
                var id = "ui-tooltip-" + increments++,
                    tooltip = $("<div>").attr({
                        id: id,
                        role: "tooltip"
                    }).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || ""));
                return $("<div>").addClass("ui-tooltip-content").appendTo(tooltip), tooltip.appendTo(this.document[0].body), this.tooltips[id] = element, tooltip
            },
            _find: function (target) {
                var id = target.data("ui-tooltip-id");
                return id ? $("#" + id) : $()
            },
            _removeTooltip: function (tooltip) {
                tooltip.remove(), delete this.tooltips[tooltip.attr("id")]
            },
            _destroy: function () {
                var that = this;
                $.each(this.tooltips, function (id, element) {
                    var event = $.Event("blur");
                    event.target = event.currentTarget = element[0], that.close(event, !0), $("#" + id).remove(), element.data("ui-tooltip-title") && (element.attr("title", element.data("ui-tooltip-title")), element.removeData("ui-tooltip-title"))
                })
            }
        })
    }(jQuery),
    function ($, undefined) {
        $.rails !== undefined && $.error("jquery-ujs has already been loaded!");
        var rails, $document = $(document);
        $.rails = rails = {
            linkClickSelector: "a[data-confirm], a[data-method], a[data-remote], a[data-disable-with]",
            buttonClickSelector: "button[data-remote]",
            inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
            formSubmitSelector: "form",
            formInputClickSelector: "form input[type=submit], form input[type=image], form button[type=submit], form button:not([type])",
            disableSelector: "input[data-disable-with], button[data-disable-with], textarea[data-disable-with]",
            enableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled",
            requiredInputSelector: "input[name][required]:not([disabled]),textarea[name][required]:not([disabled])",
            fileInputSelector: "input[type=file]",
            linkDisableSelector: "a[data-disable-with]",
            CSRFProtection: function (xhr) {
                var token = $('meta[name="csrf-token"]').attr("content");
                token && xhr.setRequestHeader("X-CSRF-Token", token)
            },
            refreshCSRFTokens: function () {
                var csrfToken = $("meta[name=csrf-token]").attr("content"),
                    csrfParam = $("meta[name=csrf-param]").attr("content");
                $('form input[name="' + csrfParam + '"]').val(csrfToken)
            },
            fire: function (obj, name, data) {
                var event = $.Event(name);
                return obj.trigger(event, data), event.result !== !1
            },
            confirm: function (message) {
                return confirm(message)
            },
            ajax: function (options) {
                return $.ajax(options)
            },
            href: function (element) {
                return element.attr("href")
            },
            handleRemote: function (element) {
                var method, url, data, elCrossDomain, crossDomain, withCredentials, dataType, options;
                if (rails.fire(element, "ajax:before")) {
                    if (elCrossDomain = element.data("cross-domain"), crossDomain = elCrossDomain === undefined ? null : elCrossDomain, withCredentials = element.data("with-credentials") || null, dataType = element.data("type") || $.ajaxSettings && $.ajaxSettings.dataType, element.is("form")) {
                        method = element.attr("method"), url = element.attr("action"), data = element.serializeArray();
                        var button = element.data("ujs:submit-button");
                        button && (data.push(button), element.data("ujs:submit-button", null))
                    } else element.is(rails.inputChangeSelector) ? (method = element.data("method"), url = element.data("url"), data = element.serialize(), element.data("params") && (data = data + "&" + element.data("params"))) : element.is(rails.buttonClickSelector) ? (method = element.data("method") || "get", url = element.data("url"), data = element.serialize(), element.data("params") && (data = data + "&" + element.data("params"))) : (method = element.data("method"), url = rails.href(element), data = element.data("params") || null);
                    options = {
                        type: method || "GET",
                        data: data,
                        dataType: dataType,
                        beforeSend: function (xhr, settings) {
                            return settings.dataType === undefined && xhr.setRequestHeader("accept", "*/*;q=0.5, " + settings.accepts.script), rails.fire(element, "ajax:beforeSend", [xhr, settings])
                        },
                        success: function (data, status, xhr) {
                            element.trigger("ajax:success", [data, status, xhr])
                        },
                        complete: function (xhr, status) {
                            element.trigger("ajax:complete", [xhr, status])
                        },
                        error: function (xhr, status, error) {
                            element.trigger("ajax:error", [xhr, status, error])
                        },
                        crossDomain: crossDomain
                    }, withCredentials && (options.xhrFields = {
                        withCredentials: withCredentials
                    }), url && (options.url = url);
                    var jqxhr = rails.ajax(options);
                    return element.trigger("ajax:send", jqxhr), jqxhr
                }
                return !1
            },
            handleMethod: function (link) {
                var href = rails.href(link),
                    method = link.data("method"),
                    target = link.attr("target"),
                    csrfToken = $("meta[name=csrf-token]").attr("content"),
                    csrfParam = $("meta[name=csrf-param]").attr("content"),
                    form = $('<form method="post" action="' + href + '"></form>'),
                    metadataInput = '<input name="_method" value="' + method + '" type="hidden" />';
                csrfParam !== undefined && csrfToken !== undefined && (metadataInput += '<input name="' + csrfParam + '" value="' + csrfToken + '" type="hidden" />'), target && form.attr("target", target), form.hide().append(metadataInput).appendTo("body"), form.submit()
            },
            disableFormElements: function (form) {
                form.find(rails.disableSelector).each(function () {
                    var element = $(this),
                        method = element.is("button") ? "html" : "val";
                    element.data("ujs:enable-with", element[method]()), element[method](element.data("disable-with")), element.prop("disabled", !0)
                })
            },
            enableFormElements: function (form) {
                form.find(rails.enableSelector).each(function () {
                    var element = $(this),
                        method = element.is("button") ? "html" : "val";
                    element.data("ujs:enable-with") && element[method](element.data("ujs:enable-with")), element.prop("disabled", !1)
                })
            },
            allowAction: function (element) {
                var callback, message = element.data("confirm"),
                    answer = !1;
                return message ? (rails.fire(element, "confirm") && (answer = rails.confirm(message), callback = rails.fire(element, "confirm:complete", [answer])), answer && callback) : !0
            },
            blankInputs: function (form, specifiedSelector, nonBlank) {
                var input, valueToCheck, inputs = $(),
                    selector = specifiedSelector || "input,textarea",
                    allInputs = form.find(selector);
                return allInputs.each(function () {
                    if (input = $(this), valueToCheck = input.is("input[type=checkbox],input[type=radio]") ? input.is(":checked") : input.val(), !valueToCheck == !nonBlank) {
                        if (input.is("input[type=radio]") && allInputs.filter('input[type=radio]:checked[name="' + input.attr("name") + '"]').length) return !0;
                        inputs = inputs.add(input)
                    }
                }), inputs.length ? inputs : !1
            },
            nonBlankInputs: function (form, specifiedSelector) {
                return rails.blankInputs(form, specifiedSelector, !0)
            },
            stopEverything: function (e) {
                return $(e.target).trigger("ujs:everythingStopped"), e.stopImmediatePropagation(), !1
            },
            disableElement: function (element) {
                element.data("ujs:enable-with", element.html()), element.html(element.data("disable-with")), element.bind("click.railsDisable", function (e) {
                    return rails.stopEverything(e)
                })
            },
            enableElement: function (element) {
                element.data("ujs:enable-with") !== undefined && (element.html(element.data("ujs:enable-with")), element.removeData("ujs:enable-with")), element.unbind("click.railsDisable")
            }
        }, rails.fire($document, "rails:attachBindings") && ($.ajaxPrefilter(function (options, originalOptions, xhr) {
            options.crossDomain || rails.CSRFProtection(xhr)
        }), $document.delegate(rails.linkDisableSelector, "ajax:complete", function () {
            rails.enableElement($(this))
        }), $document.delegate(rails.linkClickSelector, "click.rails", function (e) {
            var link = $(this),
                method = link.data("method"),
                data = link.data("params"),
                metaClick = e.metaKey || e.ctrlKey;
            if (!rails.allowAction(link)) return rails.stopEverything(e);
            if (!metaClick && link.is(rails.linkDisableSelector) && rails.disableElement(link), link.data("remote") !== undefined) {
                if (metaClick && (!method || "GET" === method) && !data) return !0;
                var handleRemote = rails.handleRemote(link);
                return handleRemote === !1 ? rails.enableElement(link) : handleRemote.error(function () {
                    rails.enableElement(link)
                }), !1
            }
            return link.data("method") ? (rails.handleMethod(link), !1) : void 0
        }), $document.delegate(rails.buttonClickSelector, "click.rails", function (e) {
            var button = $(this);
            return rails.allowAction(button) ? (rails.handleRemote(button), !1) : rails.stopEverything(e)
        }), $document.delegate(rails.inputChangeSelector, "change.rails", function (e) {
            var link = $(this);
            return rails.allowAction(link) ? (rails.handleRemote(link), !1) : rails.stopEverything(e)
        }), $document.delegate(rails.formSubmitSelector, "submit.rails", function (e) {
            var form = $(this),
                remote = form.data("remote") !== undefined,
                blankRequiredInputs = rails.blankInputs(form, rails.requiredInputSelector),
                nonBlankFileInputs = rails.nonBlankInputs(form, rails.fileInputSelector);
            if (!rails.allowAction(form)) return rails.stopEverything(e);
            if (blankRequiredInputs && form.attr("novalidate") == undefined && rails.fire(form, "ajax:aborted:required", [blankRequiredInputs])) return rails.stopEverything(e);
            if (remote) {
                if (nonBlankFileInputs) {
                    setTimeout(function () {
                        rails.disableFormElements(form)
                    }, 13);
                    var aborted = rails.fire(form, "ajax:aborted:file", [nonBlankFileInputs]);
                    return aborted || setTimeout(function () {
                        rails.enableFormElements(form)
                    }, 13), aborted
                }
                return rails.handleRemote(form), !1
            }
            setTimeout(function () {
                rails.disableFormElements(form)
            }, 13)
        }), $document.delegate(rails.formInputClickSelector, "click.rails", function (event) {
            var button = $(this);
            if (!rails.allowAction(button)) return rails.stopEverything(event);
            var name = button.attr("name"),
                data = name ? {
                    name: name,
                    value: button.val()
                } : null;
            button.closest("form").data("ujs:submit-button", data)
        }), $document.delegate(rails.formSubmitSelector, "ajax:beforeSend.rails", function (event) {
            this == event.target && rails.disableFormElements($(this))
        }), $document.delegate(rails.formSubmitSelector, "ajax:complete.rails", function (event) {
            this == event.target && rails.enableFormElements($(this))
        }), $(function () {
            rails.refreshCSRFTokens()
        }))
    }(jQuery),
    function (window, document, undefined) {
        "use strict";

        function minErr(module) {
            return function () {
                var message, i, code = arguments[0],
                    prefix = "[" + (module ? module + ":" : "") + code + "] ",
                    template = arguments[1],
                    templateArgs = arguments,
                    stringify = function (obj) {
                        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? JSON.stringify(obj) : obj
                    };
                for (message = prefix + template.replace(/\{\d+\}/g, function (match) {
                    var arg, index = +match.slice(1, -1);
                    return index + 2 < templateArgs.length ? (arg = templateArgs[index + 2], "function" == typeof arg ? arg.toString().replace(/ ?\{[\s\S]*$/, "") : "undefined" == typeof arg ? "undefined" : "string" != typeof arg ? toJson(arg) : arg) : match
                }), message = message + "\nhttp://errors.angularjs.org/1.2.16/" + (module ? module + "/" : "") + code, i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
                return new Error(message)
            }
        }

        function isArrayLike(obj) {
            if (null == obj || isWindow(obj)) return !1;
            var length = obj.length;
            return 1 === obj.nodeType && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
        }

        function forEach(obj, iterator, context) {
            var key;
            if (obj)
                if (isFunction(obj))
                    for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key);
                else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context);
            else if (isArrayLike(obj))
                for (key = 0; key < obj.length; key++) iterator.call(context, obj[key], key);
            else
                for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
            return obj
        }

        function sortedKeys(obj) {
            var keys = [];
            for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
            return keys.sort()
        }

        function forEachSorted(obj, iterator, context) {
            for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
            return keys
        }

        function reverseParams(iteratorFn) {
            return function (value, key) {
                iteratorFn(key, value)
            }
        }

        function nextUid() {
            for (var digit, index = uid.length; index;) {
                if (index--, digit = uid[index].charCodeAt(0), 57 == digit) return uid[index] = "A", uid.join("");
                if (90 != digit) return uid[index] = String.fromCharCode(digit + 1), uid.join("");
                uid[index] = "0"
            }
            return uid.unshift("0"), uid.join("")
        }

        function setHashKey(obj, h) {
            h ? obj.$$hashKey = h : delete obj.$$hashKey
        }

        function extend(dst) {
            var h = dst.$$hashKey;
            return forEach(arguments, function (obj) {
                obj !== dst && forEach(obj, function (value, key) {
                    dst[key] = value
                })
            }), setHashKey(dst, h), dst
        }

        function int(str) {
            return parseInt(str, 10)
        }

        function inherit(parent, extra) {
            return extend(new(extend(function () {}, {
                prototype: parent
            })), extra)
        }

        function noop() {}

        function identity($) {
            return $
        }

        function valueFn(value) {
            return function () {
                return value
            }
        }

        function isUndefined(value) {
            return "undefined" == typeof value
        }

        function isDefined(value) {
            return "undefined" != typeof value
        }

        function isObject(value) {
            return null != value && "object" == typeof value
        }

        function isString(value) {
            return "string" == typeof value
        }

        function isNumber(value) {
            return "number" == typeof value
        }

        function isDate(value) {
            return "[object Date]" === toString.call(value)
        }

        function isArray(value) {
            return "[object Array]" === toString.call(value)
        }

        function isFunction(value) {
            return "function" == typeof value
        }

        function isRegExp(value) {
            return "[object RegExp]" === toString.call(value)
        }

        function isWindow(obj) {
            return obj && obj.document && obj.location && obj.alert && obj.setInterval
        }

        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch
        }

        function isFile(obj) {
            return "[object File]" === toString.call(obj)
        }

        function isBlob(obj) {
            return "[object Blob]" === toString.call(obj)
        }

        function isElement(node) {
            return !(!node || !(node.nodeName || node.prop && node.attr && node.find))
        }

        function map(obj, iterator, context) {
            var results = [];
            return forEach(obj, function (value, index, list) {
                results.push(iterator.call(context, value, index, list))
            }), results
        }

        function includes(array, obj) {
            return -1 != indexOf(array, obj)
        }

        function indexOf(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++)
                if (obj === array[i]) return i;
            return -1
        }

        function arrayRemove(array, value) {
            var index = indexOf(array, value);
            return index >= 0 && array.splice(index, 1), value
        }

        function copy(source, destination) {
            if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            if (destination) {
                if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                if (isArray(source)) {
                    destination.length = 0;
                    for (var i = 0; i < source.length; i++) destination.push(copy(source[i]))
                } else {
                    var h = destination.$$hashKey;
                    forEach(destination, function (value, key) {
                        delete destination[key]
                    });
                    for (var key in source) destination[key] = copy(source[key]);
                    setHashKey(destination, h)
                }
            } else destination = source, source && (isArray(source) ? destination = copy(source, []) : isDate(source) ? destination = new Date(source.getTime()) : isRegExp(source) ? destination = new RegExp(source.source) : isObject(source) && (destination = copy(source, {})));
            return destination
        }

        function shallowCopy(src, dst) {
            dst = dst || {};
            for (var key in src)!src.hasOwnProperty(key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
            return dst
        }

        function equals(o1, o2) {
            if (o1 === o2) return !0;
            if (null === o1 || null === o2) return !1;
            if (o1 !== o1 && o2 !== o2) return !0;
            var length, key, keySet, t1 = typeof o1,
                t2 = typeof o2;
            if (t1 == t2 && "object" == t1) {
                if (!isArray(o1)) {
                    if (isDate(o1)) return isDate(o2) && o1.getTime() == o2.getTime();
                    if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
                    keySet = {};
                    for (key in o1)
                        if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                            if (!equals(o1[key], o2[key])) return !1;
                            keySet[key] = !0
                        }
                    for (key in o2)
                        if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
                    return !0
                }
                if (!isArray(o2)) return !1;
                if ((length = o1.length) == o2.length) {
                    for (key = 0; length > key; key++)
                        if (!equals(o1[key], o2[key])) return !1;
                    return !0
                }
            }
            return !1
        }

        function csp() {
            return document.securityPolicy && document.securityPolicy.isActive || document.querySelector && !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"))
        }

        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index))
        }

        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0)
        }

        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function () {
                return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs)
            } : function () {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self)
            }
        }

        function toJsonReplacer(key, value) {
            var val = value;
            return "string" == typeof key && "$" === key.charAt(0) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), val
        }

        function toJson(obj, pretty) {
            return "undefined" == typeof obj ? undefined : JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null)
        }

        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json
        }

        function toBoolean(value) {
            if ("function" == typeof value) value = !0;
            else if (value && 0 !== value.length) {
                var v = lowercase("" + value);
                value = !("f" == v || "0" == v || "false" == v || "no" == v || "n" == v || "[]" == v)
            } else value = !1;
            return value
        }

        function startingTag(element) {
            element = jqLite(element).clone();
            try {
                element.empty()
            } catch (e) {}
            var TEXT_NODE = 3,
                elemHtml = jqLite("<div>").append(element).html();
            try {
                return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                    return "<" + lowercase(nodeName)
                })
            } catch (e) {
                return lowercase(elemHtml)
            }
        }

        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value)
            } catch (e) {}
        }

        function parseKeyValue(keyValue) {
            var key_value, key, obj = {};
            return forEach((keyValue || "").split("&"), function (keyValue) {
                if (keyValue && (key_value = keyValue.split("="), key = tryDecodeURIComponent(key_value[0]), isDefined(key))) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                    obj[key] ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val
                }
            }), obj
        }

        function toKeyValue(obj) {
            var parts = [];
            return forEach(obj, function (value, key) {
                isArray(value) ? forEach(value, function (arrayValue) {
                    parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)))
                }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)))
            }), parts.length ? parts.join("&") : ""
        }

        function encodeUriSegment(val) {
            return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
        }

        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
        }

        function angularInit(element, bootstrap) {
            function append(element) {
                element && elements.push(element)
            }
            var appElement, module, elements = [element],
                names = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"],
                NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
            forEach(names, function (name) {
                names[name] = !0, append(document.getElementById(name)), name = name.replace(":", "\\:"), element.querySelectorAll && (forEach(element.querySelectorAll("." + name), append), forEach(element.querySelectorAll("." + name + "\\:"), append), forEach(element.querySelectorAll("[" + name + "]"), append))
            }), forEach(elements, function (element) {
                if (!appElement) {
                    var className = " " + element.className + " ",
                        match = NG_APP_CLASS_REGEXP.exec(className);
                    match ? (appElement = element, module = (match[2] || "").replace(/\s+/g, ",")) : forEach(element.attributes, function (attr) {
                        !appElement && names[attr.name] && (appElement = element, module = attr.value)
                    })
                }
            }), appElement && bootstrap(appElement, module ? [module] : [])
        }

        function bootstrap(element, modules) {
            var doBootstrap = function () {
                    if (element = jqLite(element), element.injector()) {
                        var tag = element[0] === document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag)
                    }
                    modules = modules || [], modules.unshift(["$provide",
                        function ($provide) {
                            $provide.value("$rootElement", element)
                        }
                    ]), modules.unshift("ng");
                    var injector = createInjector(modules);
                    return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", "$animate",
                        function (scope, element, compile, injector) {
                            scope.$apply(function () {
                                element.data("$injector", injector), compile(element)(scope)
                            })
                        }
                    ]), injector
                },
                NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            return window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), void(angular.resumeBootstrap = function (extraModules) {
                forEach(extraModules, function (module) {
                    modules.push(module)
                }), doBootstrap()
            }))
        }

        function snake_case(name, separator) {
            return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase()
            })
        }

        function bindJQuery() {
            jQuery = window.jQuery, jQuery ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), jqLitePatchJQueryRemove("remove", !0, !0, !1), jqLitePatchJQueryRemove("empty", !1, !1, !1), jqLitePatchJQueryRemove("html", !1, !1, !0)) : jqLite = JQLite, angular.element = jqLite
        }

        function assertArg(arg, name, reason) {
            if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            return arg
        }

        function assertArgFn(arg, name, acceptArrayAnnotation) {
            return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), arg
        }

        function assertNotHasOwnProperty(name, context) {
            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
        }

        function getter(obj, path, bindFnToScope) {
            if (!path) return obj;
            for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], obj && (obj = (lastInstance = obj)[key]);
            return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
        }

        function getBlockElements(nodes) {
            var startNode = nodes[0],
                endNode = nodes[nodes.length - 1];
            if (startNode === endNode) return jqLite(startNode);
            var element = startNode,
                elements = [element];
            do {
                if (element = element.nextSibling, !element) break;
                elements.push(element)
            } while (element !== endNode);
            return jqLite(elements)
        }

        function setupModuleLoader(window) {
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory())
            }
            var $injectorMinErr = minErr("$injector"),
                ngMinErr = minErr("ng"),
                angular = ensure(window, "angular", Object);
            return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function () {
                var modules = {};
                return function (name, requires, configFn) {
                    var assertNotHasOwnProperty = function (name, context) {
                        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                    };
                    return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, function () {
                        function invokeLater(provider, method, insertMethod) {
                            return function () {
                                return invokeQueue[insertMethod || "push"]([provider, method, arguments]), moduleInstance
                            }
                        }
                        if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                        var invokeQueue = [],
                            runBlocks = [],
                            config = invokeLater("$injector", "invoke"),
                            moduleInstance = {
                                _invokeQueue: invokeQueue,
                                _runBlocks: runBlocks,
                                requires: requires,
                                name: name,
                                provider: invokeLater("$provide", "provider"),
                                factory: invokeLater("$provide", "factory"),
                                service: invokeLater("$provide", "service"),
                                value: invokeLater("$provide", "value"),
                                constant: invokeLater("$provide", "constant", "unshift"),
                                animation: invokeLater("$animateProvider", "register"),
                                filter: invokeLater("$filterProvider", "register"),
                                controller: invokeLater("$controllerProvider", "register"),
                                directive: invokeLater("$compileProvider", "directive"),
                                config: config,
                                run: function (block) {
                                    return runBlocks.push(block), this
                                }
                            };
                        return configFn && config(configFn), moduleInstance
                    })
                }
            })
        }

        function publishExternalAPI(angular) {
            extend(angular, {
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                lowercase: lowercase,
                uppercase: uppercase,
                callbacks: {
                    counter: 0
                },
                $$minErr: minErr,
                $$csp: csp
            }), angularModule = setupModuleLoader(window);
            try {
                angularModule("ngLocale")
            } catch (e) {
                angularModule("ngLocale", []).provider("$locale", $LocaleProvider)
            }
            angularModule("ng", ["ngLocale"], ["$provide",
                function ($provide) {
                    $provide.provider({
                        $$sanitizeUri: $$SanitizeUriProvider
                    }), $provide.provider("$compile", $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        ngValue: ngValueDirective
                    }).directive({
                        ngInclude: ngIncludeFillContentDirective
                    }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $http: $HttpProvider,
                        $httpBackend: $HttpBackendProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $templateCache: $TemplateCacheProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$asyncCallback: $$AsyncCallbackProvider
                    })
                }
            ])
        }

        function jqNextId() {
            return ++jqId
        }

        function camelCase(name) {
            return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter
            }).replace(MOZ_HACK_REGEXP, "Moz$1")
        }

        function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
            function removePatch(param) {
                var set, setIndex, setLength, element, childIndex, childLength, children, list = filterElems && param ? [this.filter(param)] : [this], fireEvent = dispatchThis;
                if (!getterIfNoArguments || null != param)
                    for (; list.length;)
                        for (set = list.shift(), setIndex = 0, setLength = set.length; setLength > setIndex; setIndex++)
                            for (element = jqLite(set [setIndex]), fireEvent ? element.triggerHandler("$destroy") : fireEvent = !fireEvent, childIndex = 0, childLength = (children = element.children()).length; childLength > childIndex; childIndex++) list.push(jQuery(children[childIndex]));
                return originalJqFn.apply(this, arguments)
            }
            var originalJqFn = jQuery.fn[name];
            originalJqFn = originalJqFn.$original || originalJqFn, removePatch.$original = originalJqFn, jQuery.fn[name] = removePatch
        }

        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html)
        }

        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, i, j, jj, fragment = context.createDocumentFragment(),
                nodes = [];
            if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html));
            else {
                for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], tmp.removeChild(tmp.firstChild), i = wrap[0]; i--;) tmp = tmp.lastChild;
                for (j = 0, jj = tmp.childNodes.length; jj > j; ++j) nodes.push(tmp.childNodes[j]);
                tmp = fragment.firstChild, tmp.textContent = ""
            }
            return fragment.textContent = "", fragment.innerHTML = "", nodes
        }

        function jqLiteParseHTML(html, context) {
            context = context || document;
            var parsed;
            return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : jqLiteBuildFragment(html, context)
        }

        function JQLite(element) {
            if (element instanceof JQLite) return element;
            if (isString(element) && (element = trim(element)), !(this instanceof JQLite)) {
                if (isString(element) && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                return new JQLite(element)
            }
            if (isString(element)) {
                jqLiteAddNodes(this, jqLiteParseHTML(element));
                var fragment = jqLite(document.createDocumentFragment());
                fragment.append(this)
            } else jqLiteAddNodes(this, element)
        }

        function jqLiteClone(element) {
            return element.cloneNode(!0)
        }

        function jqLiteDealoc(element) {
            jqLiteRemoveData(element);
            for (var i = 0, children = element.childNodes || []; i < children.length; i++) jqLiteDealoc(children[i])
        }

        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
            var events = jqLiteExpandoStore(element, "events"),
                handle = jqLiteExpandoStore(element, "handle");
            handle && (isUndefined(type) ? forEach(events, function (eventHandler, type) {
                removeEventListenerFn(element, type, eventHandler), delete events[type]
            }) : forEach(type.split(" "), function (type) {
                isUndefined(fn) ? (removeEventListenerFn(element, type, events[type]), delete events[type]) : arrayRemove(events[type] || [], fn)
            }))
        }

        function jqLiteRemoveData(element, name) {
            var expandoId = element[jqName],
                expandoStore = jqCache[expandoId];
            if (expandoStore) {
                if (name) return void delete jqCache[expandoId].data[name];
                expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), jqLiteOff(element)), delete jqCache[expandoId], element[jqName] = undefined
            }
        }

        function jqLiteExpandoStore(element, key, value) {
            var expandoId = element[jqName],
                expandoStore = jqCache[expandoId || -1];
            return isDefined(value) ? (expandoStore || (element[jqName] = expandoId = jqNextId(), expandoStore = jqCache[expandoId] = {}), void(expandoStore[key] = value)) : expandoStore && expandoStore[key]
        }

        function jqLiteData(element, key, value) {
            var data = jqLiteExpandoStore(element, "data"),
                isSetter = isDefined(value),
                keyDefined = !isSetter && isDefined(key),
                isSimpleGetter = keyDefined && !isObject(key);
            if (data || isSimpleGetter || jqLiteExpandoStore(element, "data", data = {}), isSetter) data[key] = value;
            else {
                if (!keyDefined) return data;
                if (isSimpleGetter) return data && data[key];
                extend(data, key)
            }
        }

        function jqLiteHasClass(element, selector) {
            return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1
        }

        function jqLiteRemoveClass(element, cssClasses) {
            cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function (cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
            })
        }

        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
                forEach(cssClasses.split(" "), function (cssClass) {
                    cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ")
                }), element.setAttribute("class", trim(existingClasses))
            }
        }

        function jqLiteAddNodes(root, elements) {
            if (elements) {
                elements = elements.nodeName || !isDefined(elements.length) || isWindow(elements) ? [elements] : elements;
                for (var i = 0; i < elements.length; i++) root.push(elements[i])
            }
        }

        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
        }

        function jqLiteInheritedData(element, name, value) {
            element = jqLite(element), 9 == element[0].nodeType && (element = element.find("html"));
            for (var names = isArray(name) ? name : [name]; element.length;) {
                for (var node = element[0], i = 0, ii = names.length; ii > i; i++)
                    if ((value = element.data(names[i])) !== undefined) return value;
                element = jqLite(node.parentNode || 11 === node.nodeType && node.host)
            }
        }

        function jqLiteEmpty(element) {
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
            for (; element.firstChild;) element.removeChild(element.firstChild)
        }

        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr
        }

        function createEventHandler(element, events) {
            var eventHandler = function (event, type) {
                if (event.preventDefault || (event.preventDefault = function () {
                    event.returnValue = !1
                }), event.stopPropagation || (event.stopPropagation = function () {
                    event.cancelBubble = !0
                }), event.target || (event.target = event.srcElement || document), isUndefined(event.defaultPrevented)) {
                    var prevent = event.preventDefault;
                    event.preventDefault = function () {
                        event.defaultPrevented = !0, prevent.call(event)
                    }, event.defaultPrevented = !1
                }
                event.isDefaultPrevented = function () {
                    return event.defaultPrevented || event.returnValue === !1
                };
                var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
                forEach(eventHandlersCopy, function (fn) {
                    fn.call(element, event)
                }), 8 >= msie ? (event.preventDefault = null, event.stopPropagation = null, event.isDefaultPrevented = null) : (delete event.preventDefault, delete event.stopPropagation, delete event.isDefaultPrevented)
            };
            return eventHandler.elem = element, eventHandler
        }

        function hashKey(obj) {
            var key, objType = typeof obj;
            return "object" == objType && null !== obj ? "function" == typeof (key = obj.$$hashKey) ? key = obj.$$hashKey() : key === undefined && (key = obj.$$hashKey = nextUid()) : key = obj, objType + ":" + key
        }

        function HashMap(array) {
            forEach(array, this.put, this)
        }

        function annotate(fn) {
            var $inject, fnText, argDecl, last;
            return "function" == typeof fn ? ($inject = fn.$inject) || ($inject = [], fn.length && (fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                arg.replace(FN_ARG, function (all, underscore, name) {
                    $inject.push(name)
                })
            })), fn.$inject = $inject) : isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0), $inject
        }

        function createInjector(modulesToLoad) {
            function supportObject(delegate) {
                return function (key, value) {
                    return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value)
                }
            }

            function provider(name, provider_) {
                if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                return providerCache[name + providerSuffix] = provider_
            }

            function factory(name, factoryFn) {
                return provider(name, {
                    $get: factoryFn
                })
            }

            function service(name, constructor) {
                return factory(name, ["$injector",
                    function ($injector) {
                        return $injector.instantiate(constructor)
                    }
                ])
            }

            function value(name, val) {
                return factory(name, valueFn(val))
            }

            function constant(name, value) {
                assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value
            }

            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix),
                    orig$get = origProvider.$get;
                origProvider.$get = function () {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, {
                        $delegate: origInstance
                    })
                }
            }

            function loadModules(modulesToLoad) {
                var moduleFn, invokeQueue, i, ii, runBlocks = [];
                return forEach(modulesToLoad, function (module) {
                    if (!loadedModules.get(module)) {
                        loadedModules.put(module, !0);
                        try {
                            if (isString(module))
                                for (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; ii > i; i++) {
                                    var invokeArgs = invokeQueue[i],
                                        provider = providerInjector.get(invokeArgs[0]);
                                    provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                                } else isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                        } catch (e) {
                            throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                        }
                    }
                }), runBlocks
            }

            function createInternalInjector(cache, factory) {
                function getService(serviceName) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", path.join(" <- "));
                        return cache[serviceName]
                    }
                    try {
                        return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName)
                    } catch (err) {
                        throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err
                    } finally {
                        path.shift()
                    }
                }

                function invoke(fn, self, locals) {
                    var length, i, key, args = [],
                        $inject = annotate(fn);
                    for (i = 0, length = $inject.length; length > i; i++) {
                        if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key))
                    }
                    return fn.$inject || (fn = fn[length]), fn.apply(self, args)
                }

                function instantiate(Type, locals) {
                    var instance, returnedValue, Constructor = function () {};
                    return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype, instance = new Constructor, returnedValue = invoke(Type, instance, locals), isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance
                }
                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: annotate,
                    has: function (name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                    }
                }
            }
            var INSTANTIATING = {},
                providerSuffix = "Provider",
                path = [],
                loadedModules = new HashMap,
                providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                },
                providerInjector = providerCache.$injector = createInternalInjector(providerCache, function () {
                    throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
                }),
                instanceCache = {},
                instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
                    var provider = providerInjector.get(servicename + providerSuffix);
                    return instanceInjector.invoke(provider.$get, provider)
                });
            return forEach(loadModules(modulesToLoad), function (fn) {
                instanceInjector.invoke(fn || noop)
            }), instanceInjector
        }

        function $AnchorScrollProvider() {
            var autoScrollingEnabled = !0;
            this.disableAutoScrolling = function () {
                autoScrollingEnabled = !1
            }, this.$get = ["$window", "$location", "$rootScope",
                function ($window, $location, $rootScope) {
                    function getFirstAnchor(list) {
                        var result = null;
                        return forEach(list, function (element) {
                            result || "a" !== lowercase(element.nodeName) || (result = element)
                        }), result
                    }

                    function scroll() {
                        var elm, hash = $location.hash();
                        hash ? (elm = document.getElementById(hash)) ? elm.scrollIntoView() : (elm = getFirstAnchor(document.getElementsByName(hash))) ? elm.scrollIntoView() : "top" === hash && $window.scrollTo(0, 0) : $window.scrollTo(0, 0)
                    }
                    var document = $window.document;
                    return autoScrollingEnabled && $rootScope.$watch(function () {
                        return $location.hash()
                    }, function () {
                        $rootScope.$evalAsync(scroll)
                    }), scroll
                }
            ]
        }

        function $$AsyncCallbackProvider() {
            this.$get = ["$$rAF", "$timeout",
                function ($$rAF, $timeout) {
                    return $$rAF.supported ? function (fn) {
                        return $$rAF(fn)
                    } : function (fn) {
                        return $timeout(fn, 0, !1)
                    }
                }
            ]
        }

        function Browser(window, document, $log, $sniffer) {
            function completeOutstandingRequest(fn) {
                try {
                    fn.apply(null, sliceArgs(arguments, 1))
                } finally {
                    if (outstandingRequestCount--, 0 === outstandingRequestCount)
                        for (; outstandingRequestCallbacks.length;) try {
                            outstandingRequestCallbacks.pop()()
                        } catch (e) {
                            $log.error(e)
                        }
                }
            }

            function startPoller(interval, setTimeout) {
                ! function check() {
                    forEach(pollFns, function (pollFn) {
                        pollFn()
                    }), pollTimeout = setTimeout(check, interval)
                }()
            }

            function fireUrlChange() {
                newLocation = null, lastBrowserUrl != self.url() && (lastBrowserUrl = self.url(), forEach(urlChangeListeners, function (listener) {
                    listener(self.url())
                }))
            }
            var self = this,
                rawDocument = document[0],
                location = window.location,
                history = window.history,
                setTimeout = window.setTimeout,
                clearTimeout = window.clearTimeout,
                pendingDeferIds = {};
            self.isMock = !1;
            var outstandingRequestCount = 0,
                outstandingRequestCallbacks = [];
            self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++
            }, self.notifyWhenNoOutstandingRequests = function (callback) {
                forEach(pollFns, function (pollFn) {
                    pollFn()
                }), 0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback)
            };
            var pollTimeout, pollFns = [];
            self.addPollFn = function (fn) {
                return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), fn
            };
            var lastBrowserUrl = location.href,
                baseElement = document.find("base"),
                newLocation = null;
            self.url = function (url, replace) {
                if (location !== window.location && (location = window.location), history !== window.history && (history = window.history), url) {
                    if (lastBrowserUrl == url) return;
                    return lastBrowserUrl = url, $sniffer.history ? replace ? history.replaceState(null, "", url) : (history.pushState(null, "", url), baseElement.attr("href", baseElement.attr("href"))) : (newLocation = url, replace ? location.replace(url) : location.href = url), self
                }
                return newLocation || location.href.replace(/%27/g, "'")
            };
            var urlChangeListeners = [],
                urlChangeInit = !1;
            self.onUrlChange = function (callback) {
                return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", fireUrlChange), $sniffer.hashchange ? jqLite(window).on("hashchange", fireUrlChange) : self.addPollFn(fireUrlChange), urlChangeInit = !0), urlChangeListeners.push(callback), callback
            }, self.baseHref = function () {
                var href = baseElement.attr("href");
                return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : ""
            };
            var lastCookies = {},
                lastCookieString = "",
                cookiePath = self.baseHref();
            self.cookies = function (name, value) {
                var cookieLength, cookieArray, cookie, i, index;
                if (!name) {
                    if (rawDocument.cookie !== lastCookieString)
                        for (lastCookieString = rawDocument.cookie, cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], index = cookie.indexOf("="), index > 0 && (name = unescape(cookie.substring(0, index)), lastCookies[name] === undefined && (lastCookies[name] = unescape(cookie.substring(index + 1))));
                    return lastCookies
                }
                value === undefined ? rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1, cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"))
            }, self.defer = function (fn, delay) {
                var timeoutId;
                return outstandingRequestCount++, timeoutId = setTimeout(function () {
                    delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn)
                }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId
            }, self.defer.cancel = function (deferId) {
                return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), completeOutstandingRequest(noop), !0) : !1
            }
        }

        function $BrowserProvider() {
            this.$get = ["$window", "$log", "$sniffer", "$document",
                function ($window, $log, $sniffer, $document) {
                    return new Browser($window, $document, $log, $sniffer)
                }
            ]
        }

        function $CacheFactoryProvider() {
            this.$get = function () {
                function cacheFactory(cacheId, options) {
                    function refresh(entry) {
                        entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null)
                    }

                    function link(nextEntry, prevEntry) {
                        nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                    }
                    if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                    var size = 0,
                        stats = extend({}, options, {
                            id: cacheId
                        }),
                        data = {},
                        capacity = options && options.capacity || Number.MAX_VALUE,
                        lruHash = {},
                        freshEnd = null,
                        staleEnd = null;
                    return caches[cacheId] = {
                        put: function (key, value) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = {
                                    key: key
                                });
                                refresh(lruEntry)
                            }
                            if (!isUndefined(value)) return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value
                        },
                        get: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                refresh(lruEntry)
                            }
                            return data[key]
                        },
                        remove: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key]
                            }
                            delete data[key], size--
                        },
                        removeAll: function () {
                            data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null
                        },
                        destroy: function () {
                            data = null, stats = null, lruHash = null, delete caches[cacheId]
                        },
                        info: function () {
                            return extend({}, stats, {
                                size: size
                            })
                        }
                    }
                }
                var caches = {};
                return cacheFactory.info = function () {
                    var info = {};
                    return forEach(caches, function (cache, cacheId) {
                        info[cacheId] = cache.info()
                    }), info
                }, cacheFactory.get = function (cacheId) {
                    return caches[cacheId]
                }, cacheFactory
            }
        }

        function $TemplateCacheProvider() {
            this.$get = ["$cacheFactory",
                function ($cacheFactory) {
                    return $cacheFactory("templates")
                }
            ]
        }

        function $CompileProvider($provide, $$sanitizeUriProvider) {
            var hasDirectives = {},
                Suffix = "Directive",
                COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
                CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
                EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
            this.directive = function registerDirective(name, directiveFactory) {
                return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, ["$injector", "$exceptionHandler",
                    function ($injector, $exceptionHandler) {
                        var directives = [];
                        return forEach(hasDirectives[name], function (directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                isFunction(directive) ? directive = {
                                    compile: valueFn(directive)
                                } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, directive.require = directive.require || directive.controller && directive.name, directive.restrict = directive.restrict || "A", directives.push(directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        }), directives
                    }
                ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), this
            }, this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
            }, this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
            }, this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri",
                function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function (node, index) {
                            3 == node.nodeType && node.nodeValue.match(/\S+/) && ($compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0])
                        });
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        return safeAddClass($compileNodes, "ng-scope"),
                            function (scope, cloneConnectFn, transcludeControllers) {
                                assertArg(scope, "scope");
                                var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
                                forEach(transcludeControllers, function (instance, name) {
                                    $linkNode.data("$" + name + "Controller", instance)
                                });
                                for (var i = 0, ii = $linkNode.length; ii > i; i++) {
                                    var node = $linkNode[i],
                                        nodeType = node.nodeType;
                                    (1 === nodeType || 9 === nodeType) && $linkNode.eq(i).data("$scope", scope)
                                }
                                return cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode), $linkNode
                            }
                    }

                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className)
                        } catch (e) {}
                    }

                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, $node, childScope, childTranscludeFn, i, ii, n, nodeListLength = nodeList.length,
                                stableNodeList = new Array(nodeListLength);
                            for (i = 0; nodeListLength > i; i++) stableNodeList[i] = nodeList[i];
                            for (i = 0, n = 0, ii = linkFns.length; ii > i; n++) node = stableNodeList[n], nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], $node = jqLite(node), nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), $node.data("$scope", childScope)) : childScope = scope, childTranscludeFn = nodeLinkFn.transclude, childTranscludeFn || !boundTranscludeFn && transcludeFn ? nodeLinkFn(childLinkFn, childScope, node, $rootElement, createBoundTranscludeFn(scope, childTranscludeFn || transcludeFn)) : nodeLinkFn(childLinkFn, childScope, node, $rootElement, boundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn)
                        }
                        for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes, directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, nodeLinkFn && nodeLinkFn.scope && safeAddClass(jqLite(nodeList[i]), "ng-scope"), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn), linkFns.push(nodeLinkFn, childLinkFn), linkFnFound = linkFnFound || nodeLinkFn || childLinkFn, previousCompileContext = null;
                        return linkFnFound ? compositeLinkFn : null
                    }

                    function createBoundTranscludeFn(scope, transcludeFn) {
                        return function (transcludedScope, cloneFn, controllers) {
                            var scopeCreated = !1;
                            transcludedScope || (transcludedScope = scope.$new(), transcludedScope.$$transcluded = !0, scopeCreated = !0);
                            var clone = transcludeFn(transcludedScope, cloneFn, controllers);
                            return scopeCreated && clone.on("$destroy", bind(transcludedScope, transcludedScope.$destroy)), clone
                        }
                    }

                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, className, nodeType = node.nodeType,
                            attrsMap = attrs.$attr;
                        switch (nodeType) {
                        case 1:
                            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                                var attrStartName = !1,
                                    attrEndName = !1;
                                if (attr = nAttrs[j], !msie || msie >= 8 || attr.specified) {
                                    name = attr.name, ngAttrName = directiveNormalize(name), NG_ATTR_BINDING.test(ngAttrName) && (name = snake_case(ngAttrName.substr(6), "-"));
                                    var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                                    ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, attrs[nName] = value = trim(attr.value), getBooleanAttrName(node, nName) && (attrs[nName] = !0), addAttrInterpolateDirective(node, directives, value, nName), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                                }
                            }
                            if (className = node.className, isString(className) && "" !== className)
                                for (; match = CLASS_DIRECTIVE_REGEXP.exec(className);) nName = directiveNormalize(match[2]), addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), className = className.substr(match.index + match[0].length);
                            break;
                        case 3:
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case 8:
                            try {
                                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])))
                            } catch (e) {}
                        }
                        return directives.sort(byPriority), directives
                    }

                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [],
                            depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                1 == node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                            } while (depth > 0)
                        } else nodes.push(node);
                        return jqLite(nodes)
                    }

                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function (scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn)
                        }
                    }

                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                isolateScope: !0
                            })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                isolateScope: !0
                            })), postLinkFns.push(post))
                        }

                        function getControllers(require, $element, elementControllers) {
                            var value, retrievalMethod = "data",
                                optional = !1;
                            if (isString(require)) {
                                for (;
                                    "^" == (value = require.charAt(0)) || "?" == value;) require = require.substr(1), "^" == value && (retrievalMethod = "inheritedData"), optional = optional || "?" == value;
                                if (value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]), value = value || $element[retrievalMethod]("$" + require + "Controller"), !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                                return value
                            }
                            return isArray(require) && (value = [], forEach(require, function (require) {
                                value.push(getControllers(require, $element, elementControllers))
                            })), value
                        }

                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            function controllersBoundTransclude(scope, cloneAttachFn) {
                                var transcludeControllers;
                                return arguments.length < 2 && (cloneAttachFn = scope, scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), boundTranscludeFn(scope, cloneAttachFn, transcludeControllers)
                            }
                            var attrs, $element, i, ii, linkFn, controller, isolateScope, transcludeFn, elementControllers = {};
                            if (attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr)), $element = attrs.$$element, newIsolateScopeDirective) {
                                var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/,
                                    $linkNode = jqLite(linkNode);
                                isolateScope = scope.$new(!0), templateDirective && templateDirective === newIsolateScopeDirective.$$originalDirective ? $linkNode.data("$isolateScope", isolateScope) : $linkNode.data("$isolateScopeNoTemplate", isolateScope), safeAddClass($linkNode, "ng-isolate-scope"), forEach(newIsolateScopeDirective.scope, function (definition, scopeName) {
                                    var lastValue, parentGet, parentSet, compare, match = definition.match(LOCAL_REGEXP) || [],
                                        attrName = match[3] || scopeName,
                                        optional = "?" == match[2],
                                        mode = match[1];
                                    switch (isolateScope.$$isolateBindings[scopeName] = mode + attrName, mode) {
                                    case "@":
                                        attrs.$observe(attrName, function (value) {
                                            isolateScope[scopeName] = value
                                        }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateScope[scopeName] = $interpolate(attrs[attrName])(scope));
                                        break;
                                    case "=":
                                        if (optional && !attrs[attrName]) return;
                                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function (a, b) {
                                            return a === b
                                        }, parentSet = parentGet.assign || function () {
                                            throw lastValue = isolateScope[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name)
                                        }, lastValue = isolateScope[scopeName] = parentGet(scope), isolateScope.$watch(function () {
                                            var parentValue = parentGet(scope);
                                            return compare(parentValue, isolateScope[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateScope[scopeName]) : isolateScope[scopeName] = parentValue), lastValue = parentValue
                                        }, null, parentGet.literal);
                                        break;
                                    case "&":
                                        parentGet = $parse(attrs[attrName]), isolateScope[scopeName] = function (locals) {
                                            return parentGet(scope, locals)
                                        };
                                        break;
                                    default:
                                        throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition)
                                    }
                                })
                            }
                            for (transcludeFn = boundTranscludeFn && controllersBoundTransclude, controllerDirectives && forEach(controllerDirectives, function (directive) {
                                var controllerInstance, locals = {
                                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                    $element: $element,
                                    $attrs: attrs,
                                    $transclude: transcludeFn
                                };
                                controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), controllerInstance = $controller(controller, locals), elementControllers[directive.name] = controllerInstance, hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance), directive.controllerAs && (locals.$scope[directive.controllerAs] = controllerInstance)
                            }), i = 0, ii = preLinkFns.length; ii > i; i++) try {
                                linkFn = preLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element))
                            }
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--) try {
                                linkFn = postLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element, elementControllers), transcludeFn)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($element))
                            }
                        }
                        previousCompileContext = previousCompileContext || {};
                        for (var newScopeDirective, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start,
                                attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, terminalPriority > directive.priority) break;
                            if ((directiveValue = directive.scope) && (newScopeDirective = newScopeDirective || directive, directive.templateUrl || (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode), isObject(directiveValue) && (newIsolateScopeDirective = directive))), directiveName = directive.name, !directive.templateUrl && directive.controller && (directiveValue = directive.controller, controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = groupScan(compileNode, attrStart, attrEnd), $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), compileNode = $compileNode[0], replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode), childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), childTranscludeFn = compile($template, transcludeFn))), directive.template)
                                if (assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                    if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : jqLite(directiveValue), compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = {
                                            $attr: {}
                                        },
                                        templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs),
                                        unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length
                                } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directive.replace && (replaceDirective = directive), nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, childTranscludeFn, preLinkFns, postLinkFns, {
                                controllerDirectives: controllerDirectives,
                                newIsolateScopeDirective: newIsolateScopeDirective,
                                templateDirective: templateDirective,
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            }), ii = directives.length;
                            else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode))
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                        }
                        return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transclude = hasTranscludeDirective && childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, nodeLinkFn
                    }

                    function markDirectivesAsIsolate(directives) {
                        for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: !0
                        })
                    }

                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                                directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                })), tDirectives.push(directive), match = directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        return match
                    }

                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr,
                            dstAttr = dst.$attr,
                            $element = dst.$$element;
                        forEach(dst, function (value, key) {
                            "$" != key.charAt(0) && (src[key] && (value += ("style" === key ? ";" : " ") + src[key]), dst.$set(key, value, !0, srcAttr[key]))
                        }), forEach(src, function (value, key) {
                            "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, dstAttr[key] = srcAttr[key])
                        })
                    }

                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [],
                            beforeTemplateCompileNode = $compileNode[0],
                            origAsyncDirective = directives.shift(),
                            derivedSyncDirective = extend({}, origAsyncDirective, {
                                templateUrl: null,
                                transclude: null,
                                replace: null,
                                $$originalDirective: origAsyncDirective
                            }),
                            templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
                        return $compileNode.empty(), $http.get($sce.getTrustedResourceUrl(templateUrl), {
                                cache: $templateCache
                            }).success(function (content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                    if ($template = jqLiteIsTextNode(content) ? [] : jqLite(content), compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                    tempTemplateAttrs = {
                                        $attr: {}
                                    }, replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                                } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                                for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement, function (node, i) {
                                    node == compileNode && ($rootElement[i] = $compileNode[0])
                                }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length;) {
                                    var scope = linkQueue.shift(),
                                        beforeTemplateLinkNode = linkQueue.shift(),
                                        linkRootElement = linkQueue.shift(),
                                        boundTranscludeFn = linkQueue.shift(),
                                        linkNode = $compileNode[0];
                                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                        var oldClasses = beforeTemplateLinkNode.className;
                                        previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)
                                    }
                                    childBoundTranscludeFn = afterTemplateNodeLinkFn.transclude ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude) : boundTranscludeFn, afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                                }
                                linkQueue = null
                            }).error(function (response, code, headers, config) {
                                throw $compileMinErr("tpload", "Failed to load template: {0}", config.url)
                            }),
                            function (ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                                linkQueue ? (linkQueue.push(scope), linkQueue.push(node), linkQueue.push(rootElement), linkQueue.push(boundTranscludeFn)) : afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, boundTranscludeFn)
                            }
                    }

                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                    }

                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element))
                    }

                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, !0);
                        interpolateFn && directives.push({
                            priority: 0,
                            compile: valueFn(function (scope, node) {
                                var parent = node.parent(),
                                    bindings = parent.data("$binding") || [];
                                bindings.push(interpolateFn), safeAddClass(parent.data("$binding", bindings), "ng-binding"), scope.$watch(interpolateFn, function (value) {
                                    node[0].nodeValue = value
                                })
                            })
                        })
                    }

                    function getTrustedContext(node, attrNormalizedName) {
                        if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                        var tag = nodeName_(node);
                        return "xlinkHref" == attrNormalizedName || "FORM" == tag && "action" == attrNormalizedName || "IMG" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0
                    }

                    function addAttrInterpolateDirective(node, directives, value, name) {
                        var interpolateFn = $interpolate(value, !0);
                        if (interpolateFn) {
                            if ("multiple" === name && "SELECT" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            directives.push({
                                priority: 100,
                                compile: function () {
                                    return {
                                        pre: function (scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = {});
                                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                            interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name)), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function (newValue, oldValue) {
                                                "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                            }))
                                        }
                                    }
                                }
                            })
                        }
                    }

                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0],
                            removeCount = elementsToRemove.length,
                            parent = firstElementToRemove.parentNode;
                        if ($rootElement)
                            for (i = 0, ii = $rootElement.length; ii > i; i++)
                                if ($rootElement[i] == firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                                    $rootElement.length -= removeCount - 1;
                                    break
                                }
                        parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = document.createDocumentFragment();
                        fragment.appendChild(firstElementToRemove), newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
                        for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                            var element = elementsToRemove[k];
                            jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k]
                        }
                        elementsToRemove[0] = newNode, elementsToRemove.length = 1
                    }

                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function () {
                            return fn.apply(null, arguments)
                        }, fn, annotation)
                    }
                    var Attributes = function (element, attr) {
                        this.$$element = element, this.$attr = attr || {}
                    };
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function (classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                        },
                        $removeClass: function (classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                        },
                        $updateClass: function (newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses),
                                toRemove = tokenDifference(oldClasses, newClasses);
                            0 === toAdd.length ? $animate.removeClass(this.$$element, toRemove) : 0 === toRemove.length ? $animate.addClass(this.$$element, toAdd) : $animate.setClass(this.$$element, toAdd, toRemove)
                        },
                        $set: function (key, value, writeAttr, attrName) {
                            var nodeName, booleanKey = getBooleanAttrName(this.$$element[0], key);
                            booleanKey && (this.$$element.prop(key, value), attrName = booleanKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), ("A" === nodeName && "href" === key || "IMG" === nodeName && "src" === key) && (this[key] = value = $$sanitizeUri(value, "src" === key)), writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[key], function (fn) {
                                try {
                                    fn(value)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                            })
                        },
                        $observe: function (key, fn) {
                            var attrs = this,
                                $$observers = attrs.$$observers || (attrs.$$observers = {}),
                                listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn), $rootScope.$evalAsync(function () {
                                listeners.$$inter || fn(attrs[key])
                            }), fn
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(),
                        endSymbol = $interpolate.endSymbol(),
                        denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function (template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                        },
                        NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    return compile
                }
            ]
        }

        function directiveNormalize(name) {
            return camelCase(name.replace(PREFIX_REGEXP, ""))
        }

        function tokenDifference(str1, str2) {
            var values = "",
                tokens1 = str1.split(/\s+/),
                tokens2 = str2.split(/\s+/);
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                    if (token == tokens2[j]) continue outer;
                values += (values.length > 0 ? " " : "") + token
            }
            return values
        }

        function $ControllerProvider() {
            var controllers = {},
                CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
            this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor
            }, this.$get = ["$injector", "$window",
                function ($injector, $window) {
                    return function (expression, locals) {
                        var instance, match, constructor, identifier;
                        if (isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], identifier = match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || getter($window, constructor, !0), assertArgFn(expression, constructor, !0)), instance = $injector.instantiate(expression, locals), identifier) {
                            if (!locals || "object" != typeof locals.$scope) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
                            locals.$scope[identifier] = instance
                        }
                        return instance
                    }
                }
            ]
        }

        function $DocumentProvider() {
            this.$get = ["$window",
                function (window) {
                    return jqLite(window.document)
                }
            ]
        }

        function $ExceptionHandlerProvider() {
            this.$get = ["$log",
                function ($log) {
                    return function () {
                        $log.error.apply($log, arguments)
                    }
                }
            ]
        }

        function parseHeaders(headers) {
            var key, val, i, parsed = {};
            return headers ? (forEach(headers.split("\n"), function (line) {
                i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), key && (parsed[key] ? parsed[key] += ", " + val : parsed[key] = val)
            }), parsed) : parsed
        }

        function headersGetter(headers) {
            var headersObj = isObject(headers) ? headers : undefined;
            return function (name) {
                return headersObj || (headersObj = parseHeaders(headers)), name ? headersObj[lowercase(name)] || null : headersObj
            }
        }

        function transformData(data, headers, fns) {
            return isFunction(fns) ? fns(data, headers) : (forEach(fns, function (fn) {
                data = fn(data, headers)
            }), data)
        }

        function isSuccess(status) {
            return status >= 200 && 300 > status
        }

        function $HttpProvider() {
            var JSON_START = /^\s*(\[|\{[^\{])/,
                JSON_END = /[\}\]]\s*$/,
                PROTECTION_PREFIX = /^\)\]\}',?\n/,
                CONTENT_TYPE_APPLICATION_JSON = {
                    "Content-Type": "application/json;charset=utf-8"
                },
                defaults = this.defaults = {
                    transformResponse: [
                        function (data) {
                            return isString(data) && (data = data.replace(PROTECTION_PREFIX, ""), JSON_START.test(data) && JSON_END.test(data) && (data = fromJson(data))), data
                        }
                    ],
                    transformRequest: [
                        function (d) {
                            return !isObject(d) || isFile(d) || isBlob(d) ? d : toJson(d)
                        }
                    ],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: copy(CONTENT_TYPE_APPLICATION_JSON),
                        put: copy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: copy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN"
                },
                interceptorFactories = this.interceptors = [],
                responseInterceptorFactories = this.responseInterceptors = [];
            this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector",
                function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
                    function $http(requestConfig) {
                        function transformResponse(response) {
                            var resp = extend({}, response, {
                                data: transformData(response.data, response.headers, config.transformResponse)
                            });
                            return isSuccess(response.status) ? resp : $q.reject(resp)
                        }

                        function mergeHeaders(config) {
                            function execHeaders(headers) {
                                var headerContent;
                                forEach(headers, function (headerFn, header) {
                                    isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent : delete headers[header])
                                })
                            }
                            var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers,
                                reqHeaders = extend({}, config.headers);
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]), execHeaders(defHeaders), execHeaders(reqHeaders);
                            defaultHeadersIteration: for (defHeaderName in defHeaders) {
                                lowercaseDefHeaderName = lowercase(defHeaderName);
                                for (reqHeaderName in reqHeaders)
                                    if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                                reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                            }
                            return reqHeaders
                        }
                        var config = {
                                method: "get",
                                transformRequest: defaults.transformRequest,
                                transformResponse: defaults.transformResponse
                            },
                            headers = mergeHeaders(requestConfig);
                        extend(config, requestConfig), config.headers = headers, config.method = uppercase(config.method);
                        var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                        xsrfValue && (headers[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue);
                        var serverRequest = function (config) {
                                headers = config.headers;
                                var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                                return isUndefined(config.data) && forEach(headers, function (value, header) {
                                    "content-type" === lowercase(header) && delete headers[header]
                                }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), sendReq(config, reqData, headers).then(transformResponse, transformResponse)
                            },
                            chain = [serverRequest, undefined],
                            promise = $q.when(config);
                        for (forEach(reversedInterceptors, function (interceptor) {
                            (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError)
                        }); chain.length;) {
                            var thenFn = chain.shift(),
                                rejectFn = chain.shift();
                            promise = promise.then(thenFn, rejectFn)
                        }
                        return promise.success = function (fn) {
                            return promise.then(function (response) {
                                fn(response.data, response.status, response.headers, config)
                            }), promise
                        }, promise.error = function (fn) {
                            return promise.then(null, function (response) {
                                fn(response.data, response.status, response.headers, config)
                            }), promise
                        }, promise
                    }

                    function createShortMethods() {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, config) {
                                return $http(extend(config || {}, {
                                    method: name,
                                    url: url
                                }))
                            }
                        })
                    }

                    function createShortMethodsWithData() {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, data, config) {
                                return $http(extend(config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }))
                            }
                        })
                    }

                    function sendReq(config, reqData, reqHeaders) {
                        function done(status, response, headersString, statusText) {
                            cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText]) : cache.remove(url)), resolvePromise(response, status, headersString, statusText), $rootScope.$$phase || $rootScope.$apply()
                        }

                        function resolvePromise(response, status, headers, statusText) {
                            status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText
                            })
                        }

                        function removePendingReq() {
                            var idx = indexOf($http.pendingRequests, config); - 1 !== idx && $http.pendingRequests.splice(idx, 1)
                        }
                        var cache, cachedResp, deferred = $q.defer(),
                            promise = deferred.promise,
                            url = buildUrl(config.url, config.params);
                        if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), (config.cache || defaults.cache) && config.cache !== !1 && "GET" == config.method && (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), cache)
                            if (cachedResp = cache.get(url), isDefined(cachedResp)) {
                                if (cachedResp.then) return cachedResp.then(removePendingReq, removePendingReq), cachedResp;
                                isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK")
                            } else cache.put(url, promise);
                        return isUndefined(cachedResp) && $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType), promise
                    }

                    function buildUrl(url, params) {
                        if (!params) return url;
                        var parts = [];
                        return forEachSorted(params, function (value, key) {
                            null === value || isUndefined(value) || (isArray(value) || (value = [value]), forEach(value, function (v) {
                                isObject(v) && (v = toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                            }))
                        }), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")), url
                    }
                    var defaultCache = $cacheFactory("$http"),
                        reversedInterceptors = [];
                    return forEach(interceptorFactories, function (interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                    }), forEach(responseInterceptorFactories, function (interceptorFactory, index) {
                        var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
                        reversedInterceptors.splice(index, 0, {
                            response: function (response) {
                                return responseFn($q.when(response))
                            },
                            responseError: function (response) {
                                return responseFn($q.reject(response))
                            }
                        })
                    }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), createShortMethodsWithData("post", "put"), $http.defaults = defaults, $http
                }
            ]
        }

        function createXhr(method) {
            if (8 >= msie && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) return new window.ActiveXObject("Microsoft.XMLHTTP");
            if (window.XMLHttpRequest) return new window.XMLHttpRequest;
            throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.")
        }

        function $HttpBackendProvider() {
            this.$get = ["$browser", "$window", "$document",
                function ($browser, $window, $document) {
                    return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0])
                }
            ]
        }

        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            function jsonpReq(url, done) {
                var script = rawDocument.createElement("script"),
                    doneWrapper = function () {
                        script.onreadystatechange = script.onload = script.onerror = null, rawDocument.body.removeChild(script), done && done()
                    };
                return script.type = "text/javascript", script.src = url, msie && 8 >= msie ? script.onreadystatechange = function () {
                    /loaded|complete/.test(script.readyState) && doneWrapper()
                } : script.onload = script.onerror = function () {
                    doneWrapper()
                }, rawDocument.body.appendChild(script), doneWrapper
            }
            var ABORTED = -1;
            return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
                function timeoutRequest() {
                    status = ABORTED, jsonpDone && jsonpDone(), xhr && xhr.abort()
                }

                function completeRequest(callback, status, response, headersString, statusText) {
                    timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), status = 1223 === status ? 204 : status, statusText = statusText || "", callback(status, response, headersString, statusText), $browser.$$completeOutstandingRequest(noop)
                }
                var status;
                if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                    var callbackId = "_" + (callbacks.counter++).toString(36);
                    callbacks[callbackId] = function (data) {
                        callbacks[callbackId].data = data
                    };
                    var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), function () {
                        callbacks[callbackId].data ? completeRequest(callback, 200, callbacks[callbackId].data) : completeRequest(callback, status || -2), callbacks[callbackId] = angular.noop
                    })
                } else {
                    var xhr = createXhr(method);
                    if (xhr.open(method, url, !0), forEach(headers, function (value, key) {
                        isDefined(value) && xhr.setRequestHeader(key, value)
                    }), xhr.onreadystatechange = function () {
                        if (xhr && 4 == xhr.readyState) {
                            var responseHeaders = null,
                                response = null;
                            status !== ABORTED && (responseHeaders = xhr.getAllResponseHeaders(), response = "response" in xhr ? xhr.response : xhr.responseText), completeRequest(callback, status || xhr.status, response, responseHeaders, xhr.statusText || "")
                        }
                    }, withCredentials && (xhr.withCredentials = !0), responseType) try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if ("json" !== responseType) throw e
                    }
                    xhr.send(post || null)
                } if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout);
                else timeout && timeout.then && timeout.then(timeoutRequest)
            }
        }

        function $InterpolateProvider() {
            var startSymbol = "{{",
                endSymbol = "}}";
            this.startSymbol = function (value) {
                return value ? (startSymbol = value, this) : startSymbol
            }, this.endSymbol = function (value) {
                return value ? (endSymbol = value, this) : endSymbol
            }, this.$get = ["$parse", "$exceptionHandler", "$sce",
                function ($parse, $exceptionHandler, $sce) {
                    function $interpolate(text, mustHaveExpression, trustedContext) {
                        for (var startIndex, endIndex, fn, exp, index = 0, parts = [], length = text.length, hasInterpolation = !1, concat = []; length > index;) - 1 != (startIndex = text.indexOf(startSymbol, index)) && -1 != (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) ? (index != startIndex && parts.push(text.substring(index, startIndex)), parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex))), fn.exp = exp, index = endIndex + endSymbolLength, hasInterpolation = !0) : (index != length && parts.push(text.substring(index)), index = length);
                        if ((length = parts.length) || (parts.push(""), length = 1), trustedContext && parts.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                        return !mustHaveExpression || hasInterpolation ? (concat.length = length, fn = function (context) {
                            try {
                                for (var part, i = 0, ii = length; ii > i; i++) "function" == typeof (part = parts[i]) && (part = part(context), part = trustedContext ? $sce.getTrusted(trustedContext, part) : $sce.valueOf(part), null === part || isUndefined(part) ? part = "" : "string" != typeof part && (part = toJson(part))), concat[i] = part;
                                return concat.join("")
                            } catch (err) {
                                var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                                $exceptionHandler(newErr)
                            }
                        }, fn.exp = text, fn.parts = parts, fn) : void 0
                    }
                    var startSymbolLength = startSymbol.length,
                        endSymbolLength = endSymbol.length;
                    return $interpolate.startSymbol = function () {
                        return startSymbol
                    }, $interpolate.endSymbol = function () {
                        return endSymbol
                    }, $interpolate
                }
            ]
        }

        function $IntervalProvider() {
            this.$get = ["$rootScope", "$window", "$q",
                function ($rootScope, $window, $q) {
                    function interval(fn, delay, count, invokeApply) {
                        var setInterval = $window.setInterval,
                            clearInterval = $window.clearInterval,
                            deferred = $q.defer(),
                            promise = deferred.promise,
                            iteration = 0,
                            skipApply = isDefined(invokeApply) && !invokeApply;
                        return count = isDefined(count) ? count : 0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function () {
                            deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply()
                        }, delay), intervals[promise.$$intervalId] = deferred, promise
                    }
                    var intervals = {};
                    return interval.cancel = function (promise) {
                        return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], !0) : !1
                    }, interval
                }
            ]
        }

        function $LocaleProvider() {
            this.$get = function () {
                return {
                    id: "en-us",
                    NUMBER_FORMATS: {
                        DECIMAL_SEP: ".",
                        GROUP_SEP: ",",
                        PATTERNS: [{
                            minInt: 1,
                            minFrac: 0,
                            maxFrac: 3,
                            posPre: "",
                            posSuf: "",
                            negPre: "-",
                            negSuf: "",
                            gSize: 3,
                            lgSize: 3
                        }, {
                            minInt: 1,
                            minFrac: 2,
                            maxFrac: 2,
                            posPre: "\xa4",
                            posSuf: "",
                            negPre: "(\xa4",
                            negSuf: ")",
                            gSize: 3,
                            lgSize: 3
                        }],
                        CURRENCY_SYM: "$"
                    },
                    DATETIME_FORMATS: {
                        MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                        SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                        DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                        SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                        AMPMS: ["AM", "PM"],
                        medium: "MMM d, y h:mm:ss a",
                        "short": "M/d/yy h:mm a",
                        fullDate: "EEEE, MMMM d, y",
                        longDate: "MMMM d, y",
                        mediumDate: "MMM d, y",
                        shortDate: "M/d/yy",
                        mediumTime: "h:mm:ss a",
                        shortTime: "h:mm a"
                    },
                    pluralCat: function (num) {
                        return 1 === num ? "one" : "other"
                    }
                }
            }
        }

        function encodePath(path) {
            for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = encodeUriSegment(segments[i]);
            return segments.join("/")
        }

        function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
            var parsedUrl = urlResolve(absoluteUrl, appBase);
            locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
        }

        function parseAppUrl(relativeUrl, locationObj, appBase) {
            var prefixed = "/" !== relativeUrl.charAt(0);
            prefixed && (relativeUrl = "/" + relativeUrl);
            var match = urlResolve(relativeUrl, appBase);
            locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
        }

        function beginsWith(begin, whole) {
            return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0
        }

        function stripHash(url) {
            var index = url.indexOf("#");
            return -1 == index ? url : url.substr(0, index)
        }

        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
        }

        function serverBase(url) {
            return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
        }

        function LocationHtml5Url(appBase, basePrefix) {
            this.$$html5 = !0, basePrefix = basePrefix || "";
            var appBaseNoFile = stripFile(appBase);
            parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function (url) {
                var pathUrl = beginsWith(appBaseNoFile, url);
                if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                parseAppUrl(pathUrl, this, appBase), this.$$path || (this.$$path = "/"), this.$$compose()
            }, this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
            }, this.$$rewrite = function (url) {
                var appUrl, prevAppUrl;
                return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? appBaseNoFile + appUrl : appBaseNoFile == url + "/" ? appBaseNoFile : void 0
            }
        }

        function LocationHashbangUrl(appBase, hashPrefix) {
            var appBaseNoFile = stripFile(appBase);
            parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function (url) {
                function removeWindowsDriveName(path, url, base) {
                    var firstPathSegmentMatch, windowsFilePathExp = /^\/?.*?:(\/.*)/;
                    return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
                }
                var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url),
                    withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
                if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
                parseAppUrl(withoutHashUrl, this, appBase), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose()
            }, this.$$compose = function () {
                var search = toKeyValue(this.$$search),
                    hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
            }, this.$$rewrite = function (url) {
                return stripHash(appBase) == stripHash(url) ? url : void 0
            }
        }

        function LocationHashbangInHtml5Url(appBase, hashPrefix) {
            this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
            var appBaseNoFile = stripFile(appBase);
            this.$$rewrite = function (url) {
                var appUrl;
                return appBase == stripHash(url) ? url : (appUrl = beginsWith(appBaseNoFile, url)) ? appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" ? appBaseNoFile : void 0
            }
        }

        function locationGetter(property) {
            return function () {
                return this[property]
            }
        }

        function locationGetterSetter(property, preprocess) {
            return function (value) {
                return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
            }
        }

        function $LocationProvider() {
            var hashPrefix = "",
                html5Mode = !1;
            this.hashPrefix = function (prefix) {
                return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
            }, this.html5Mode = function (mode) {
                return isDefined(mode) ? (html5Mode = mode, this) : html5Mode
            }, this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement",
                function ($rootScope, $browser, $sniffer, $rootElement) {
                    function afterLocationChange(oldUrl) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl)
                    }
                    var $location, LocationMode, appBase, baseHref = $browser.baseHref(),
                        initialUrl = $browser.url();
                    html5Mode ? (appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url) : (appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl), $location = new LocationMode(appBase, "#" + hashPrefix), $location.$$parse($location.$$rewrite(initialUrl)), $rootElement.on("click", function (event) {
                        if (!event.ctrlKey && !event.metaKey && 2 != event.which) {
                            for (var elm = jqLite(event.target);
                                "a" !== lowercase(elm[0].nodeName);)
                                if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                            var absHref = elm.prop("href");
                            isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href);
                            var rewrittenUrl = $location.$$rewrite(absHref);
                            absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented() && (event.preventDefault(), rewrittenUrl != $browser.url() && ($location.$$parse(rewrittenUrl), $rootScope.$apply(), window.angular["ff-684208-preventDefault"] = !0))
                        }
                    }), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0), $browser.onUrlChange(function (newUrl) {
                        $location.absUrl() != newUrl && ($rootScope.$evalAsync(function () {
                            var oldUrl = $location.absUrl();
                            $location.$$parse(newUrl), $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented ? ($location.$$parse(oldUrl), $browser.url(oldUrl)) : afterLocationChange(oldUrl)
                        }), $rootScope.$$phase || $rootScope.$digest())
                    });
                    var changeCounter = 0;
                    return $rootScope.$watch(function () {
                        var oldUrl = $browser.url(),
                            currentReplace = $location.$$replace;
                        return changeCounter && oldUrl == $location.absUrl() || (changeCounter++, $rootScope.$evalAsync(function () {
                            $rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented ? $location.$$parse(oldUrl) : ($browser.url($location.absUrl(), currentReplace), afterLocationChange(oldUrl))
                        })), $location.$$replace = !1, changeCounter
                    }), $location
                }
            ]
        }

        function $LogProvider() {
            var debug = !0,
                self = this;
            this.debugEnabled = function (flag) {
                return isDefined(flag) ? (debug = flag, this) : debug
            }, this.$get = ["$window",
                function ($window) {
                    function formatError(arg) {
                        return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), arg
                    }

                    function consoleLog(type) {
                        var console = $window.console || {},
                            logFn = console[type] || console.log || noop,
                            hasApply = !1;
                        try {
                            hasApply = !!logFn.apply
                        } catch (e) {}
                        return hasApply ? function () {
                            var args = [];
                            return forEach(arguments, function (arg) {
                                args.push(formatError(arg))
                            }), logFn.apply(console, args)
                        } : function (arg1, arg2) {
                            logFn(arg1, null == arg2 ? "" : arg2)
                        }
                    }
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: function () {
                            var fn = consoleLog("debug");
                            return function () {
                                debug && fn.apply(self, arguments)
                            }
                        }()
                    }
                }
            ]
        }

        function ensureSafeMemberName(name, fullExpression) {
            if ("constructor" === name) throw $parseMinErr("isecfld", 'Referencing "constructor" field in Angular expressions is disallowed! Expression: {0}', fullExpression);
            return name
        }

        function ensureSafeObject(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj.document && obj.location && obj.alert && obj.setInterval) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression)
            }
            return obj
        }

        function setter(obj, path, setValue, fullExp, options) {
            options = options || {};
            for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
                key = ensureSafeMemberName(element.shift(), fullExp);
                var propertyObj = obj[key];
                propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj, obj.then && options.unwrapPromises && (promiseWarning(fullExp), "$$v" in obj || ! function (promise) {
                    promise.then(function (val) {
                        promise.$$v = val
                    })
                }(obj), obj.$$v === undefined && (obj.$$v = {}), obj = obj.$$v)
            }
            return key = ensureSafeMemberName(element.shift(), fullExp), obj[key] = setValue, setValue
        }

        function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
            return ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), ensureSafeMemberName(key2, fullExp), ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp), options.unwrapPromises ? function (scope, locals) {
                var promise, pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
                return null == pathVal ? pathVal : (pathVal = pathVal[key0], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), key4 ? null == pathVal ? undefined : (pathVal = pathVal[key4], pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function (val) {
                    promise.$$v = val
                })), pathVal = pathVal.$$v), pathVal) : pathVal) : pathVal) : pathVal) : pathVal)
            } : function (scope, locals) {
                var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
                return null == pathVal ? pathVal : (pathVal = pathVal[key0], key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], key4 ? null == pathVal ? undefined : pathVal = pathVal[key4] : pathVal) : pathVal) : pathVal) : pathVal)
            }
        }

        function simpleGetterFn1(key0, fullExp) {
            return ensureSafeMemberName(key0, fullExp),
                function (scope, locals) {
                    return null == scope ? undefined : (locals && locals.hasOwnProperty(key0) ? locals : scope)[key0]
                }
        }

        function simpleGetterFn2(key0, key1, fullExp) {
            return ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp),
                function (scope, locals) {
                    return null == scope ? undefined : (scope = (locals && locals.hasOwnProperty(key0) ? locals : scope)[key0], null == scope ? undefined : scope[key1])
                }
        }

        function getterFn(path, options, fullExp) {
            if (getterFnCache.hasOwnProperty(path)) return getterFnCache[path];
            var fn, pathKeys = path.split("."),
                pathKeysLength = pathKeys.length;
            if (options.unwrapPromises || 1 !== pathKeysLength)
                if (options.unwrapPromises || 2 !== pathKeysLength)
                    if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options) : function (scope, locals) {
                        var val, i = 0;
                        do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals), locals = undefined, scope = val; while (pathKeysLength > i);
                        return val
                    };
                    else {
                        var code = "var p;\n";
                        forEach(pathKeys, function (key, index) {
                            ensureSafeMemberName(key, fullExp), code += "if(s == null) return undefined;\ns=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"];\n' + (options.unwrapPromises ? 'if (s && s.then) {\n pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n' : "")
                        }), code += "return s;";
                        var evaledFnGetter = new Function("s", "k", "pw", code);
                        evaledFnGetter.toString = valueFn(code), fn = options.unwrapPromises ? function (scope, locals) {
                            return evaledFnGetter(scope, locals, promiseWarning)
                        } : evaledFnGetter
                    } else fn = simpleGetterFn2(pathKeys[0], pathKeys[1], fullExp);
            else fn = simpleGetterFn1(pathKeys[0], fullExp);
            return "hasOwnProperty" !== path && (getterFnCache[path] = fn), fn
        }

        function $ParseProvider() {
            var cache = {},
                $parseOptions = {
                    csp: !1,
                    unwrapPromises: !1,
                    logPromiseWarnings: !0
                };
            this.unwrapPromises = function (value) {
                return isDefined(value) ? ($parseOptions.unwrapPromises = !!value, this) : $parseOptions.unwrapPromises
            }, this.logPromiseWarnings = function (value) {
                return isDefined(value) ? ($parseOptions.logPromiseWarnings = value, this) : $parseOptions.logPromiseWarnings
            }, this.$get = ["$filter", "$sniffer", "$log",
                function ($filter, $sniffer, $log) {
                    return $parseOptions.csp = $sniffer.csp, promiseWarning = function (fullExp) {
                            $parseOptions.logPromiseWarnings && !promiseWarningCache.hasOwnProperty(fullExp) && (promiseWarningCache[fullExp] = !0, $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. Automatic unwrapping of promises in Angular expressions is deprecated."))
                        },
                        function (exp) {
                            var parsedExpression;
                            switch (typeof exp) {
                            case "string":
                                if (cache.hasOwnProperty(exp)) return cache[exp];
                                var lexer = new Lexer($parseOptions),
                                    parser = new Parser(lexer, $filter, $parseOptions);
                                return parsedExpression = parser.parse(exp, !1), "hasOwnProperty" !== exp && (cache[exp] = parsedExpression), parsedExpression;
                            case "function":
                                return exp;
                            default:
                                return noop
                            }
                        }
                }
            ]
        }

        function $QProvider() {
            this.$get = ["$rootScope", "$exceptionHandler",
                function ($rootScope, $exceptionHandler) {
                    return qFactory(function (callback) {
                        $rootScope.$evalAsync(callback)
                    }, $exceptionHandler)
                }
            ]
        }

        function qFactory(nextTick, exceptionHandler) {
            function defaultCallback(value) {
                return value
            }

            function defaultErrback(reason) {
                return reject(reason)
            }

            function all(promises) {
                var deferred = defer(),
                    counter = 0,
                    results = isArray(promises) ? [] : {};
                return forEach(promises, function (promise, key) {
                    counter++, ref(promise).then(function (value) {
                        results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results))
                    }, function (reason) {
                        results.hasOwnProperty(key) || deferred.reject(reason)
                    })
                }), 0 === counter && deferred.resolve(results), deferred.promise
            }
            var defer = function () {
                    var value, deferred, pending = [];
                    return deferred = {
                        resolve: function (val) {
                            if (pending) {
                                var callbacks = pending;
                                pending = undefined, value = ref(val), callbacks.length && nextTick(function () {
                                    for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], value.then(callback[0], callback[1], callback[2])
                                })
                            }
                        },
                        reject: function (reason) {
                            deferred.resolve(createInternalRejectedPromise(reason))
                        },
                        notify: function (progress) {
                            if (pending) {
                                var callbacks = pending;
                                pending.length && nextTick(function () {
                                    for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], callback[2](progress)
                                })
                            }
                        },
                        promise: {
                            then: function (callback, errback, progressback) {
                                var result = defer(),
                                    wrappedCallback = function (value) {
                                        try {
                                            result.resolve((isFunction(callback) ? callback : defaultCallback)(value))
                                        } catch (e) {
                                            result.reject(e), exceptionHandler(e)
                                        }
                                    },
                                    wrappedErrback = function (reason) {
                                        try {
                                            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                                        } catch (e) {
                                            result.reject(e), exceptionHandler(e)
                                        }
                                    },
                                    wrappedProgressback = function (progress) {
                                        try {
                                            result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress))
                                        } catch (e) {
                                            exceptionHandler(e)
                                        }
                                    };
                                return pending ? pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]) : value.then(wrappedCallback, wrappedErrback, wrappedProgressback), result.promise
                            },
                            "catch": function (callback) {
                                return this.then(null, callback)
                            },
                            "finally": function (callback) {
                                function makePromise(value, resolved) {
                                    var result = defer();
                                    return resolved ? result.resolve(value) : result.reject(value), result.promise
                                }

                                function handleCallback(value, isResolved) {
                                    var callbackOutput = null;
                                    try {
                                        callbackOutput = (callback || defaultCallback)()
                                    } catch (e) {
                                        return makePromise(e, !1)
                                    }
                                    return callbackOutput && isFunction(callbackOutput.then) ? callbackOutput.then(function () {
                                        return makePromise(value, isResolved)
                                    }, function (error) {
                                        return makePromise(error, !1)
                                    }) : makePromise(value, isResolved)
                                }
                                return this.then(function (value) {
                                    return handleCallback(value, !0)
                                }, function (error) {
                                    return handleCallback(error, !1)
                                })
                            }
                        }
                    }
                },
                ref = function (value) {
                    return value && isFunction(value.then) ? value : {
                        then: function (callback) {
                            var result = defer();
                            return nextTick(function () {
                                result.resolve(callback(value))
                            }), result.promise
                        }
                    }
                },
                reject = function (reason) {
                    var result = defer();
                    return result.reject(reason), result.promise
                },
                createInternalRejectedPromise = function (reason) {
                    return {
                        then: function (callback, errback) {
                            var result = defer();
                            return nextTick(function () {
                                try {
                                    result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                                } catch (e) {
                                    result.reject(e), exceptionHandler(e)
                                }
                            }), result.promise
                        }
                    }
                },
                when = function (value, callback, errback, progressback) {
                    var done, result = defer(),
                        wrappedCallback = function (value) {
                            try {
                                return (isFunction(callback) ? callback : defaultCallback)(value)
                            } catch (e) {
                                return exceptionHandler(e), reject(e)
                            }
                        },
                        wrappedErrback = function (reason) {
                            try {
                                return (isFunction(errback) ? errback : defaultErrback)(reason)
                            } catch (e) {
                                return exceptionHandler(e), reject(e)
                            }
                        },
                        wrappedProgressback = function (progress) {
                            try {
                                return (isFunction(progressback) ? progressback : defaultCallback)(progress)
                            } catch (e) {
                                exceptionHandler(e)
                            }
                        };
                    return nextTick(function () {
                        ref(value).then(function (value) {
                            done || (done = !0, result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback)))
                        }, function (reason) {
                            done || (done = !0, result.resolve(wrappedErrback(reason)))
                        }, function (progress) {
                            done || result.notify(wrappedProgressback(progress))
                        })
                    }), result.promise
                };
            return {
                defer: defer,
                reject: reject,
                when: when,
                all: all
            }
        }

        function $$RAFProvider() {
            this.$get = ["$window", "$timeout",
                function ($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame,
                        cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame,
                        rafSupported = !!requestAnimationFrame,
                        raf = rafSupported ? function (fn) {
                            var id = requestAnimationFrame(fn);
                            return function () {
                                cancelAnimationFrame(id)
                            }
                        } : function (fn) {
                            var timer = $timeout(fn, 16.66, !1);
                            return function () {
                                $timeout.cancel(timer)
                            }
                        };
                    return raf.supported = rafSupported, raf
                }
            ]
        }

        function $RootScopeProvider() {
            var TTL = 10,
                $rootScopeMinErr = minErr("$rootScope"),
                lastDirtyWatch = null;
            this.digestTtl = function (value) {
                return arguments.length && (TTL = value), TTL
            }, this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser",
                function ($injector, $exceptionHandler, $parse, $browser) {
                    function Scope() {
                        this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this["this"] = this.$root = this, this.$$destroyed = !1, this.$$asyncQueue = [], this.$$postDigestQueue = [], this.$$listeners = {}, this.$$listenerCount = {}, this.$$isolateBindings = {}
                    }

                    function beginPhase(phase) {
                        if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        $rootScope.$$phase = phase
                    }

                    function clearPhase() {
                        $rootScope.$$phase = null
                    }

                    function compileToFn(exp, name) {
                        var fn = $parse(exp);
                        return assertArgFn(fn, name), fn
                    }

                    function decrementListenerCount(current, count, name) {
                        do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent)
                    }

                    function initWatchVal() {}
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function (isolate) {
                            var ChildScope, child;
                            return isolate ? (child = new Scope, child.$root = this.$root, child.$$asyncQueue = this.$$asyncQueue, child.$$postDigestQueue = this.$$postDigestQueue) : (ChildScope = function () {}, ChildScope.prototype = this, child = new ChildScope, child.$id = nextUid()), child["this"] = child, child.$$listeners = {}, child.$$listenerCount = {}, child.$parent = this, child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null, child.$$prevSibling = this.$$childTail, this.$$childHead ? (this.$$childTail.$$nextSibling = child, this.$$childTail = child) : this.$$childHead = this.$$childTail = child, child
                        },
                        $watch: function (watchExp, listener, objectEquality) {
                            var scope = this,
                                get = compileToFn(watchExp, "watch"),
                                array = scope.$$watchers,
                                watcher = {
                                    fn: listener,
                                    last: initWatchVal,
                                    get: get,
                                    exp: watchExp,
                                    eq: !!objectEquality
                                };
                            if (lastDirtyWatch = null, !isFunction(listener)) {
                                var listenFn = compileToFn(listener || noop, "listener");
                                watcher.fn = function (newVal, oldVal, scope) {
                                    listenFn(scope)
                                }
                            }
                            if ("string" == typeof watchExp && get.constant) {
                                var originalFn = watcher.fn;
                                watcher.fn = function (newVal, oldVal, scope) {
                                    originalFn.call(this, newVal, oldVal, scope), arrayRemove(array, watcher)
                                }
                            }
                            return array || (array = scope.$$watchers = []), array.unshift(watcher),
                                function () {
                                    arrayRemove(array, watcher), lastDirtyWatch = null
                                }
                        },
                        $watchCollection: function (obj, listener) {
                            function $watchCollectionWatch() {
                                newValue = objGetter(self);
                                var newLength, key;
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                        for (var i = 0; newLength > i; i++) {
                                            var bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i];
                                            bothNaN || oldValue[i] === newValue[i] || (changeDetected++, oldValue[i] = newValue[i])
                                        }
                                    } else {
                                        oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), newLength = 0;
                                        for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, oldValue.hasOwnProperty(key) ? oldValue[key] !== newValue[key] && (changeDetected++, oldValue[key] = newValue[key]) : (oldLength++, oldValue[key] = newValue[key], changeDetected++));
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue) oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key) && (oldLength--, delete oldValue[key])
                                        }
                                    } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }

                            function $watchCollectionAction() {
                                if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), trackVeryOldValue)
                                    if (isObject(newValue))
                                        if (isArrayLike(newValue)) {
                                            veryOldValue = new Array(newValue.length);
                                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i]
                                        } else {
                                            veryOldValue = {};
                                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key])
                                        } else veryOldValue = newValue
                            }
                            var newValue, oldValue, veryOldValue, self = this,
                                trackVeryOldValue = listener.length > 1,
                                changeDetected = 0,
                                objGetter = $parse(obj),
                                internalArray = [],
                                internalObject = {},
                                initRun = !0,
                                oldLength = 0;
                            return this.$watch($watchCollectionWatch, $watchCollectionAction)
                        },
                        $digest: function () {
                            var watch, value, last, watchers, length, dirty, next, current, logIdx, logMsg, asyncTask, asyncQueue = this.$$asyncQueue,
                                postDigestQueue = this.$$postDigestQueue,
                                ttl = TTL,
                                target = this,
                                watchLog = [];
                            beginPhase("$digest"), lastDirtyWatch = null;
                            do {
                                for (dirty = !1, current = target; asyncQueue.length;) {
                                    try {
                                        asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression)
                                    } catch (e) {
                                        clearPhase(), $exceptionHandler(e)
                                    }
                                    lastDirtyWatch = null
                                }
                                traverseScopesLoop: do {
                                    if (watchers = current.$$watchers)
                                        for (length = watchers.length; length--;) try {
                                            if (watch = watchers[length])
                                                if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                                    if (watch === lastDirtyWatch) {
                                                        dirty = !1;
                                                        break traverseScopesLoop
                                                    }
                                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value) : value, watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, watchLog[logIdx] || (watchLog[logIdx] = []), logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last), watchLog[logIdx].push(logMsg))
                                        } catch (e) {
                                            clearPhase(), $exceptionHandler(e)
                                        }
                                    if (!(next = current.$$childHead || current !== target && current.$$nextSibling))
                                        for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                                } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog))
                            } while (dirty || asyncQueue.length);
                            for (clearPhase(); postDigestQueue.length;) try {
                                postDigestQueue.shift()()
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        },
                        $destroy: function () {
                            if (!this.$$destroyed) {
                                var parent = this.$parent;
                                this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope && (forEach(this.$$listenerCount, bind(null, decrementListenerCount, this)), parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null, this.$$listeners = {}, this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [], this.$destroy = this.$digest = this.$apply = noop, this.$on = this.$watch = function () {
                                    return noop
                                })
                            }
                        },
                        $eval: function (expr, locals) {
                            return $parse(expr)(this, locals)
                        },
                        $evalAsync: function (expr) {
                            $rootScope.$$phase || $rootScope.$$asyncQueue.length || $browser.defer(function () {
                                $rootScope.$$asyncQueue.length && $rootScope.$digest()
                            }), this.$$asyncQueue.push({
                                scope: this,
                                expression: expr
                            })
                        },
                        $$postDigest: function (fn) {
                            this.$$postDigestQueue.push(fn)
                        },
                        $apply: function (expr) {
                            try {
                                return beginPhase("$apply"), this.$eval(expr)
                            } catch (e) {
                                $exceptionHandler(e)
                            } finally {
                                clearPhase();
                                try {
                                    $rootScope.$digest()
                                } catch (e) {
                                    throw $exceptionHandler(e), e
                                }
                            }
                        },
                        $on: function (name, listener) {
                            var namedListeners = this.$$listeners[name];
                            namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                            var current = this;
                            do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                            var self = this;
                            return function () {
                                namedListeners[indexOf(namedListeners, listener)] = null, decrementListenerCount(self, 1, name)
                            }
                        },
                        $emit: function (name) {
                            var namedListeners, i, length, empty = [],
                                scope = this,
                                stopPropagation = !1,
                                event = {
                                    name: name,
                                    targetScope: scope,
                                    stopPropagation: function () {
                                        stopPropagation = !0
                                    },
                                    preventDefault: function () {
                                        event.defaultPrevented = !0
                                    },
                                    defaultPrevented: !1
                                },
                                listenerArgs = concat([event], arguments, 1);
                            do {
                                for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; length > i; i++)
                                    if (namedListeners[i]) try {
                                        namedListeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    } else namedListeners.splice(i, 1), i--, length--;
                                if (stopPropagation) return event;
                                scope = scope.$parent
                            } while (scope);
                            return event
                        },
                        $broadcast: function (name) {
                            for (var listeners, i, length, target = this, current = target, next = target, event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function () {
                                    event.defaultPrevented = !0
                                },
                                defaultPrevented: !1
                            }, listenerArgs = concat([event], arguments, 1); current = next;) {
                                for (event.currentScope = current, listeners = current.$$listeners[name] || [], i = 0, length = listeners.length; length > i; i++)
                                    if (listeners[i]) try {
                                        listeners[i].apply(null, listenerArgs)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    } else listeners.splice(i, 1), i--, length--;
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))
                                    for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                            }
                            return event
                        }
                    };
                    var $rootScope = new Scope;
                    return $rootScope
                }
            ]
        }

        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
                imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;
            this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist
            }, this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist
            }, this.$get = function () {
                return function (uri, isImage) {
                    var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    return msie && !(msie >= 8) || (normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex)) ? uri : "unsafe:" + normalizedVal
                }
            }
        }

        function escapeForRegexp(s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
        }

        function adjustMatcher(matcher) {
            if ("self" === matcher) return matcher;
            if (isString(matcher)) {
                if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), new RegExp("^" + matcher + "$")
            }
            if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
        }

        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            return isDefined(matchers) && forEach(matchers, function (matcher) {
                adjustedMatchers.push(adjustMatcher(matcher))
            }), adjustedMatchers
        }

        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ["self"],
                resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function (value) {
                return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist
            }, this.resourceUrlBlacklist = function (value) {
                return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist
            }, this.$get = ["$injector",
                function ($injector) {
                    function matchUrl(matcher, parsedUrl) {
                        return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href)
                    }

                    function isResourceUrlAllowedByPolicy(url) {
                        var i, n, parsedUrl = urlResolve(url.toString()),
                            allowed = !1;
                        for (i = 0, n = resourceUrlWhitelist.length; n > i; i++)
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = !0;
                                break
                            }
                        if (allowed)
                            for (i = 0, n = resourceUrlBlacklist.length; n > i; i++)
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = !1;
                                    break
                                }
                        return allowed
                    }

                    function generateHolderType(Base) {
                        var holderType = function (trustedValue) {
                            this.$$unwrapTrustedValue = function () {
                                return trustedValue
                            }
                        };
                        return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function () {
                            return this.$$unwrapTrustedValue()
                        }, holderType.prototype.toString = function () {
                            return this.$$unwrapTrustedValue().toString()
                        }, holderType
                    }

                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                        if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        return new Constructor(trustedValue)
                    }

                    function valueOf(maybeTrusted) {
                        return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                    }

                    function getTrusted(type, maybeTrusted) {
                        if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                            throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                        }
                        if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                    }
                    var htmlSanitizer = function () {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                    };
                    $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                    var trustedValueHolderBase = generateHolderType(),
                        byType = {};
                    return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {
                        trustAs: trustAs,
                        getTrusted: getTrusted,
                        valueOf: valueOf
                    }
                }
            ]
        }

        function $SceProvider() {
            var enabled = !0;
            this.enabled = function (value) {
                return arguments.length && (enabled = !!value), enabled
            }, this.$get = ["$parse", "$sniffer", "$sceDelegate",
                function ($parse, $sniffer, $sceDelegate) {
                    if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                    var sce = copy(SCE_CONTEXTS);
                    sce.isEnabled = function () {
                        return enabled
                    }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function (type, value) {
                        return value
                    }, sce.valueOf = identity), sce.parseAs = function (type, expr) {
                        var parsed = $parse(expr);
                        return parsed.literal && parsed.constant ? parsed : function (self, locals) {
                            return sce.getTrusted(type, parsed(self, locals))
                        }
                    };
                    var parse = sce.parseAs,
                        getTrusted = sce.getTrusted,
                        trustAs = sce.trustAs;
                    return forEach(SCE_CONTEXTS, function (enumValue, name) {
                        var lName = lowercase(name);
                        sce[camelCase("parse_as_" + lName)] = function (expr) {
                            return parse(enumValue, expr)
                        }, sce[camelCase("get_trusted_" + lName)] = function (value) {
                            return getTrusted(enumValue, value)
                        }, sce[camelCase("trust_as_" + lName)] = function (value) {
                            return trustAs(enumValue, value)
                        }
                    }), sce
                }
            ]
        }

        function $SnifferProvider() {
            this.$get = ["$window", "$document",
                function ($window, $document) {
                    var vendorPrefix, match, eventSupport = {},
                        android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
                        document = $document[0] || {},
                        documentMode = document.documentMode,
                        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
                        bodyStyle = document.body && document.body.style,
                        transitions = !1,
                        animations = !1;
                    if (bodyStyle) {
                        for (var prop in bodyStyle)
                            if (match = vendorRegex.exec(prop)) {
                                vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                                break
                            }
                        vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), animations = isString(document.body.style.webkitAnimation))
                    }
                    return {
                        history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                        hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                        hasEvent: function (event) {
                            if ("input" == event && 9 == msie) return !1;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement("div");
                                eventSupport[event] = "on" + event in divElm
                            }
                            return eventSupport[event]
                        },
                        csp: csp(),
                        vendorPrefix: vendorPrefix,
                        transitions: transitions,
                        animations: animations,
                        android: android,
                        msie: msie,
                        msieDocumentMode: documentMode
                    }
                }
            ]
        }

        function $TimeoutProvider() {
            this.$get = ["$rootScope", "$browser", "$q", "$exceptionHandler",
                function ($rootScope, $browser, $q, $exceptionHandler) {
                    function timeout(fn, delay, invokeApply) {
                        var timeoutId, deferred = $q.defer(),
                            promise = deferred.promise,
                            skipApply = isDefined(invokeApply) && !invokeApply;
                        return timeoutId = $browser.defer(function () {
                            try {
                                deferred.resolve(fn())
                            } catch (e) {
                                deferred.reject(e), $exceptionHandler(e)
                            } finally {
                                delete deferreds[promise.$$timeoutId]
                            }
                            skipApply || $rootScope.$apply()
                        }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise
                    }
                    var deferreds = {};
                    return timeout.cancel = function (promise) {
                        return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1
                    }, timeout
                }
            ]
        }

        function urlResolve(url) {
            var href = url;
            return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href), {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }
        }

        function urlIsSameOrigin(requestUrl) {
            var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
        }

        function $WindowProvider() {
            this.$get = valueFn(window)
        }

        function $FilterProvider($provide) {
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    return forEach(name, function (filter, key) {
                        filters[key] = register(key, filter)
                    }), filters
                }
                return $provide.factory(name + suffix, factory)
            }
            var suffix = "Filter";
            this.register = register, this.$get = ["$injector",
                function ($injector) {
                    return function (name) {
                        return $injector.get(name + suffix)
                    }
                }
            ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter)
        }

        function filterFilter() {
            return function (array, expression, comparator) {
                if (!isArray(array)) return array;
                var comparatorType = typeof comparator,
                    predicates = [];
                predicates.check = function (value) {
                    for (var j = 0; j < predicates.length; j++)
                        if (!predicates[j](value)) return !1;
                    return !0
                }, "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ? function (obj, text) {
                    return angular.equals(obj, text)
                } : function (obj, text) {
                    if (obj && text && "object" == typeof obj && "object" == typeof text) {
                        for (var objKey in obj)
                            if ("$" !== objKey.charAt(0) && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) return !0;
                        return !1
                    }
                    return text = ("" + text).toLowerCase(), ("" + obj).toLowerCase().indexOf(text) > -1
                });
                var search = function (obj, text) {
                    if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
                    switch (typeof obj) {
                    case "boolean":
                    case "number":
                    case "string":
                        return comparator(obj, text);
                    case "object":
                        switch (typeof text) {
                        case "object":
                            return comparator(obj, text);
                        default:
                            for (var objKey in obj)
                                if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0
                        }
                        return !1;
                    case "array":
                        for (var i = 0; i < obj.length; i++)
                            if (search(obj[i], text)) return !0;
                        return !1;
                    default:
                        return !1
                    }
                };
                switch (typeof expression) {
                case "boolean":
                case "number":
                case "string":
                    expression = {
                        $: expression
                    };
                case "object":
                    for (var key in expression)! function (path) {
                        "undefined" != typeof expression[path] && predicates.push(function (value) {
                            return search("$" == path ? value : value && value[path], expression[path])
                        })
                    }(key);
                    break;
                case "function":
                    predicates.push(expression);
                    break;
                default:
                    return array
                }
                for (var filtered = [], j = 0; j < array.length; j++) {
                    var value = array[j];
                    predicates.check(value) && filtered.push(value)
                }
                return filtered
            }
        }

        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (amount, currencySymbol) {
                return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol)
            }
        }

        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (number, fractionSize) {
                return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
            }
        }

        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (null == number || !isFinite(number) || isObject(number)) return "";
            var isNegative = 0 > number;
            number = Math.abs(number);
            var numStr = number + "",
                formatedText = "",
                parts = [],
                hasExponent = !1;
            if (-1 !== numStr.indexOf("e")) {
                var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
                match && "-" == match[2] && match[3] > fractionSize + 1 ? numStr = "0" : (formatedText = numStr, hasExponent = !0)
            }
            if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize));
            else {
                var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
                isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac));
                var pow = Math.pow(10, fractionSize);
                number = Math.round(number * pow) / pow;
                var fraction = ("" + number).split(DECIMAL_SEP),
                    whole = fraction[0];
                fraction = fraction[1] || "";
                var i, pos = 0,
                    lgroup = pattern.lgSize,
                    group = pattern.gSize;
                if (whole.length >= lgroup + group)
                    for (pos = whole.length - lgroup, i = 0; pos > i; i++)(pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), formatedText += whole.charAt(i);
                for (i = pos; i < whole.length; i++)(whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), formatedText += whole.charAt(i);
                for (; fraction.length < fractionSize;) fraction += "0";
                fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize))
            }
            return parts.push(isNegative ? pattern.negPre : pattern.posPre), parts.push(formatedText), parts.push(isNegative ? pattern.negSuf : pattern.posSuf), parts.join("")
        }

        function padNumber(num, digits, trim) {
            var neg = "";
            for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits;) num = "0" + num;
            return trim && (num = num.substr(num.length - digits)), neg + num
        }

        function dateGetter(name, size, offset, trim) {
            return offset = offset || 0,
                function (date) {
                    var value = date["get" + name]();
                    return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), padNumber(value, size, trim)
                }
        }

        function dateStrGetter(name, shortForm) {
            return function (date, formats) {
                var value = date["get" + name](),
                    get = uppercase(shortForm ? "SHORT" + name : name);
                return formats[get][value]
            }
        }

        function timeZoneGetter(date) {
            var zone = -1 * date.getTimezoneOffset(),
                paddedZone = zone >= 0 ? "+" : "";
            return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
        }

        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
        }

        function dateFilter($locale) {
            function jsonStringToDate(string) {
                var match;
                if (match = string.match(R_ISO8601_STR)) {
                    var date = new Date(0),
                        tzHour = 0,
                        tzMin = 0,
                        dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                        timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                    var h = int(match[4] || 0) - tzHour,
                        m = int(match[5] || 0) - tzMin,
                        s = int(match[6] || 0),
                        ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                    return timeSetter.call(date, h, m, s, ms), date
                }
                return string
            }
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            return function (date, format) {
                var fn, match, text = "",
                    parts = [];
                if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
                for (; format;) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), format = parts.pop()) : (parts.push(format), format = null);
                return forEach(parts, function (value) {
                    fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), text
            }
        }

        function jsonFilter() {
            return function (object) {
                return toJson(object, !0)
            }
        }

        function limitToFilter() {
            return function (input, limit) {
                if (!isArray(input) && !isString(input)) return input;
                if (limit = int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length) : "";
                var i, n, out = [];
                for (limit > input.length ? limit = input.length : limit < -input.length && (limit = -input.length), limit > 0 ? (i = 0, n = limit) : (i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
                return out
            }
        }

        function orderByFilter($parse) {
            return function (array, sortPredicate, reverseOrder) {
                function comparator(o1, o2) {
                    for (var i = 0; i < sortPredicate.length; i++) {
                        var comp = sortPredicate[i](o1, o2);
                        if (0 !== comp) return comp
                    }
                    return 0
                }

                function reverseComparator(comp, descending) {
                    return toBoolean(descending) ? function (a, b) {
                        return comp(b, a)
                    } : comp
                }

                function compare(v1, v2) {
                    var t1 = typeof v1,
                        t2 = typeof v2;
                    return t1 == t2 ? ("string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1
                }
                if (!isArray(array)) return array;
                if (!sortPredicate) return array;
                sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate], sortPredicate = map(sortPredicate, function (predicate) {
                    var descending = !1,
                        get = predicate || identity;
                    if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), predicate = predicate.substring(1)), get = $parse(predicate), get.constant)) {
                        var key = get();
                        return reverseComparator(function (a, b) {
                            return compare(a[key], b[key])
                        }, descending)
                    }
                    return reverseComparator(function (a, b) {
                        return compare(get(a), get(b))
                    }, descending)
                });
                for (var arrayCopy = [], i = 0; i < array.length; i++) arrayCopy.push(array[i]);
                return arrayCopy.sort(reverseComparator(comparator, reverseOrder))
            }
        }

        function ngDirective(directive) {
            return isFunction(directive) && (directive = {
                link: directive
            }), directive.restrict = directive.restrict || "AC", valueFn(directive)
        }

        function FormController(element, attrs, $scope, $animate) {
            function toggleValidCss(isValid, validationErrorKey) {
                validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", $animate.removeClass(element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), $animate.addClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey)
            }
            var form = this,
                parentForm = element.parent().controller("form") || nullFormCtrl,
                invalidCount = 0,
                errors = form.$error = {},
                controls = [];
            form.$name = attrs.name || attrs.ngForm, form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, parentForm.$addControl(form), element.addClass(PRISTINE_CLASS), toggleValidCss(!0), form.$addControl = function (control) {
                assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control)
            }, form.$removeControl = function (control) {
                control.$name && form[control.$name] === control && delete form[control.$name], forEach(errors, function (queue, validationToken) {
                    form.$setValidity(validationToken, !0, control)
                }), arrayRemove(controls, control)
            }, form.$setValidity = function (validationToken, isValid, control) {
                var queue = errors[validationToken];
                if (isValid) queue && (arrayRemove(queue, control), queue.length || (invalidCount--, invalidCount || (toggleValidCss(isValid), form.$valid = !0, form.$invalid = !1), errors[validationToken] = !1, toggleValidCss(!0, validationToken), parentForm.$setValidity(validationToken, !0, form)));
                else {
                    if (invalidCount || toggleValidCss(isValid), queue) {
                        if (includes(queue, control)) return
                    } else errors[validationToken] = queue = [], invalidCount++, toggleValidCss(!1, validationToken), parentForm.$setValidity(validationToken, !1, form);
                    queue.push(control), form.$valid = !1, form.$invalid = !0
                }
            }, form.$setDirty = function () {
                $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty()
            }, form.$setPristine = function () {
                $animate.removeClass(element, DIRTY_CLASS), $animate.addClass(element, PRISTINE_CLASS), form.$dirty = !1, form.$pristine = !0, forEach(controls, function (control) {
                    control.$setPristine()
                })
            }
        }

        function validate(ctrl, validatorName, validity, value) {
            return ctrl.$setValidity(validatorName, validity), validity ? value : undefined
        }

        function addNativeHtml5Validators(ctrl, validatorName, element) {
            var validity = element.prop("validity");
            if (isObject(validity)) {
                var validator = function (value) {
                    return ctrl.$error[validatorName] || !(validity.badInput || validity.customError || validity.typeMismatch) || validity.valueMissing ? value : void ctrl.$setValidity(validatorName, !1)
                };
                ctrl.$parsers.push(validator)
            }
        }

        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var validity = element.prop("validity");
            if (!$sniffer.android) {
                var composing = !1;
                element.on("compositionstart", function () {
                    composing = !0
                }), element.on("compositionend", function () {
                    composing = !1, listener()
                })
            }
            var listener = function () {
                if (!composing) {
                    var value = element.val();
                    toBoolean(attr.ngTrim || "T") && (value = trim(value)), (ctrl.$viewValue !== value || validity && "" === value && !validity.valueMissing) && (scope.$$phase ? ctrl.$setViewValue(value) : scope.$apply(function () {
                        ctrl.$setViewValue(value)
                    }))
                }
            };
            if ($sniffer.hasEvent("input")) element.on("input", listener);
            else {
                var timeout, deferListener = function () {
                    timeout || (timeout = $browser.defer(function () {
                        listener(), timeout = null
                    }))
                };
                element.on("keydown", function (event) {
                    var key = event.keyCode;
                    91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener()
                }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener)
            }
            element.on("change", listener), ctrl.$render = function () {
                element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue)
            };
            var patternValidator, match, pattern = attr.ngPattern;
            if (pattern) {
                var validateRegex = function (regexp, value) {
                    return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value)
                };
                match = pattern.match(/^\/(.*)\/([gim]*)$/), match ? (pattern = new RegExp(match[1], match[2]), patternValidator = function (value) {
                    return validateRegex(pattern, value)
                }) : patternValidator = function (value) {
                    var patternObj = scope.$eval(pattern);
                    if (!patternObj || !patternObj.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
                    return validateRegex(patternObj, value)
                }, ctrl.$formatters.push(patternValidator), ctrl.$parsers.push(patternValidator)
            }
            if (attr.ngMinlength) {
                var minlength = int(attr.ngMinlength),
                    minLengthValidator = function (value) {
                        return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value)
                    };
                ctrl.$parsers.push(minLengthValidator), ctrl.$formatters.push(minLengthValidator)
            }
            if (attr.ngMaxlength) {
                var maxlength = int(attr.ngMaxlength),
                    maxLengthValidator = function (value) {
                        return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value)
                    };
                ctrl.$parsers.push(maxLengthValidator), ctrl.$formatters.push(maxLengthValidator)
            }
        }

        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            if (textInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$parsers.push(function (value) {
                var empty = ctrl.$isEmpty(value);
                return empty || NUMBER_REGEXP.test(value) ? (ctrl.$setValidity("number", !0), "" === value ? null : empty ? value : parseFloat(value)) : (ctrl.$setValidity("number", !1), undefined)
            }), addNativeHtml5Validators(ctrl, "number", element), ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? "" : "" + value
            }), attr.min) {
                var minValidator = function (value) {
                    var min = parseFloat(attr.min);
                    return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value)
                };
                ctrl.$parsers.push(minValidator), ctrl.$formatters.push(minValidator)
            }
            if (attr.max) {
                var maxValidator = function (value) {
                    var max = parseFloat(attr.max);
                    return validate(ctrl, "max", ctrl.$isEmpty(value) || max >= value, value)
                };
                ctrl.$parsers.push(maxValidator), ctrl.$formatters.push(maxValidator)
            }
            ctrl.$formatters.push(function (value) {
                return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value)
            })
        }

        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            textInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var urlValidator = function (value) {
                return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value)
            };
            ctrl.$formatters.push(urlValidator), ctrl.$parsers.push(urlValidator)
        }

        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            textInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var emailValidator = function (value) {
                return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value)
            };
            ctrl.$formatters.push(emailValidator), ctrl.$parsers.push(emailValidator)
        }

        function radioInputType(scope, element, attr, ctrl) {
            isUndefined(attr.name) && element.attr("name", nextUid()), element.on("click", function () {
                element[0].checked && scope.$apply(function () {
                    ctrl.$setViewValue(attr.value)
                })
            }), ctrl.$render = function () {
                var value = attr.value;
                element[0].checked = value == ctrl.$viewValue
            }, attr.$observe("value", ctrl.$render)
        }

        function checkboxInputType(scope, element, attr, ctrl) {
            var trueValue = attr.ngTrueValue,
                falseValue = attr.ngFalseValue;
            isString(trueValue) || (trueValue = !0), isString(falseValue) || (falseValue = !1), element.on("click", function () {
                scope.$apply(function () {
                    ctrl.$setViewValue(element[0].checked)
                })
            }), ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue
            }, ctrl.$isEmpty = function (value) {
                return value !== trueValue
            }, ctrl.$formatters.push(function (value) {
                return value === trueValue
            }), ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue
            })
        }

        function classDirective(name, selector) {
            return name = "ngClass" + name, ["$animate",
                function ($animate) {
                    function arrayDifference(tokens1, tokens2) {
                        var values = [];
                        outer: for (var i = 0; i < tokens1.length; i++) {
                            for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                                if (token == tokens2[j]) continue outer;
                            values.push(token)
                        }
                        return values
                    }

                    function arrayClasses(classVal) {
                        if (isArray(classVal)) return classVal;
                        if (isString(classVal)) return classVal.split(" ");
                        if (isObject(classVal)) {
                            var classes = [];
                            return forEach(classVal, function (v, k) {
                                v && classes.push(k)
                            }), classes
                        }
                        return classVal
                    }
                    return {
                        restrict: "AC",
                        link: function (scope, element, attr) {
                            function addClasses(classes) {
                                var newClasses = digestClassCounts(classes, 1);
                                attr.$addClass(newClasses)
                            }

                            function removeClasses(classes) {
                                var newClasses = digestClassCounts(classes, -1);
                                attr.$removeClass(newClasses)
                            }

                            function digestClassCounts(classes, count) {
                                var classCounts = element.data("$classCounts") || {},
                                    classesToUpdate = [];
                                return forEach(classes, function (className) {
                                    (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                                }), element.data("$classCounts", classCounts), classesToUpdate.join(" ")
                            }

                            function updateClasses(oldClasses, newClasses) {
                                var toAdd = arrayDifference(newClasses, oldClasses),
                                    toRemove = arrayDifference(oldClasses, newClasses);
                                toRemove = digestClassCounts(toRemove, -1), toAdd = digestClassCounts(toAdd, 1), 0 === toAdd.length ? $animate.removeClass(element, toRemove) : 0 === toRemove.length ? $animate.addClass(element, toAdd) : $animate.setClass(element, toAdd, toRemove)
                            }

                            function ngClassWatchAction(newVal) {
                                if (selector === !0 || scope.$index % 2 === selector) {
                                    var newClasses = arrayClasses(newVal || []);
                                    if (oldVal) {
                                        if (!equals(newVal, oldVal)) {
                                            var oldClasses = arrayClasses(oldVal);
                                            updateClasses(oldClasses, newClasses)
                                        }
                                    } else addClasses(newClasses)
                                }
                                oldVal = copy(newVal)
                            }
                            var oldVal;
                            scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function () {
                                ngClassWatchAction(scope.$eval(attr[name]))
                            }), "ngClass" !== name && scope.$watch("$index", function ($index, old$index) {
                                var mod = 1 & $index;
                                if (mod !== old$index & 1) {
                                    var classes = arrayClasses(scope.$eval(attr[name]));
                                    mod === selector ? addClasses(classes) : removeClasses(classes)
                                }
                            })
                        }
                    }
                }
            ]
        }
        var lowercase = function (string) {
                return isString(string) ? string.toLowerCase() : string
            },
            hasOwnProperty = Object.prototype.hasOwnProperty,
            uppercase = function (string) {
                return isString(string) ? string.toUpperCase() : string
            },
            manualLowercase = function (s) {
                return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
                    return String.fromCharCode(32 | ch.charCodeAt(0))
                }) : s
            },
            manualUppercase = function (s) {
                return isString(s) ? s.replace(/[a-z]/g, function (ch) {
                    return String.fromCharCode(-33 & ch.charCodeAt(0))
                }) : s
            };
        "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
        var msie, jqLite, jQuery, angularModule, nodeName_, slice = [].slice,
            push = [].push,
            toString = Object.prototype.toString,
            ngMinErr = minErr("ng"),
            angular = (window.angular, window.angular || (window.angular = {})),
            uid = ["0", "0", "0"];
        msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), isNaN(msie) && (msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])), noop.$inject = [], identity.$inject = [];
        var trim = function () {
            return String.prototype.trim ? function (value) {
                return isString(value) ? value.trim() : value
            } : function (value) {
                return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value
            }
        }();
        nodeName_ = 9 > msie ? function (element) {
            return element = element.nodeName ? element : element[0], element.scopeName && "HTML" != element.scopeName ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName
        } : function (element) {
            return element.nodeName ? element.nodeName : element[0].nodeName
        };
        var SNAKE_CASE_REGEXP = /[A-Z]/g,
            version = {
                full: "1.2.16",
                major: 1,
                minor: 2,
                dot: 16,
                codeName: "badger-enumeration"
            },
            jqCache = JQLite.cache = {},
            jqName = JQLite.expando = "ng-" + (new Date).getTime(),
            jqId = 1,
            addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
                element.addEventListener(type, fn, !1)
            } : function (element, type, fn) {
                element.attachEvent("on" + type, fn)
            },
            removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
                element.removeEventListener(type, fn, !1)
            } : function (element, type, fn) {
                element.detachEvent("on" + type, fn)
            },
            SPECIAL_CHARS_REGEXP = (JQLite._data = function (node) {
                return this.cache[node[this.expando]] || {}
            }, /([\:\-\_]+(.))/g),
            MOZ_HACK_REGEXP = /^moz([A-Z])/,
            jqLiteMinErr = minErr("jqLite"),
            SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
            HTML_REGEXP = /<|&#?\w+;/,
            TAG_NAME_REGEXP = /<([\w:]+)/,
            XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
            wrapMap = {
                option: [1, '<select multiple="multiple">', "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
        var JQLitePrototype = JQLite.prototype = {
                ready: function (fn) {
                    function trigger() {
                        fired || (fired = !0, fn())
                    }
                    var fired = !1;
                    "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), JQLite(window).on("load", trigger))
                },
                toString: function () {
                    var value = [];
                    return forEach(this, function (e) {
                        value.push("" + e)
                    }), "[" + value.join(", ") + "]"
                },
                eq: function (index) {
                    return jqLite(index >= 0 ? this[index] : this[this.length + index])
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            },
            BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value
        });
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), function (value) {
            BOOLEAN_ELEMENTS[uppercase(value)] = !0
        }), forEach({
            data: jqLiteData,
            inheritedData: jqLiteInheritedData,
            scope: function (element) {
                return jqLite(element).data("$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
            },
            isolateScope: function (element) {
                return jqLite(element).data("$isolateScope") || jqLite(element).data("$isolateScopeNoTemplate")
            },
            controller: jqLiteController,
            injector: function (element) {
                return jqLiteInheritedData(element, "$injector")
            },
            removeAttr: function (element, name) {
                element.removeAttribute(name)
            },
            hasClass: jqLiteHasClass,
            css: function (element, name, value) {
                if (name = camelCase(name), !isDefined(value)) {
                    var val;
                    return 8 >= msie && (val = element.currentStyle && element.currentStyle[name], "" === val && (val = "auto")), val = val || element.style[name], 8 >= msie && (val = "" === val ? undefined : val), val
                }
                element.style[name] = value
            },
            attr: function (element, name, value) {
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, element.removeAttribute(lowercasedName))
                } else if (isDefined(value)) element.setAttribute(name, value);
                else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return null === ret ? undefined : ret
                }
            },
            prop: function (element, name, value) {
                return isDefined(value) ? void(element[name] = value) : element[name]
            },
            text: function () {
                function getText(element, value) {
                    var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
                    return isUndefined(value) ? textProp ? element[textProp] : "" : void(element[textProp] = value)
                }
                var NODE_TYPE_TEXT_PROPERTY = [];
                return 9 > msie ? (NODE_TYPE_TEXT_PROPERTY[1] = "innerText", NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue") : NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent", getText.$dv = "", getText
            }(),
            val: function (element, value) {
                if (isUndefined(value)) {
                    if ("SELECT" === nodeName_(element) && element.multiple) {
                        var result = [];
                        return forEach(element.options, function (option) {
                            option.selected && result.push(option.value || option.text)
                        }), 0 === result.length ? null : result
                    }
                    return element.value
                }
                element.value = value
            },
            html: function (element, value) {
                if (isUndefined(value)) return element.innerHTML;
                for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
                element.innerHTML = value
            },
            empty: jqLiteEmpty
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2) {
                var i, key;
                if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                    if (isObject(arg1)) {
                        for (i = 0; i < this.length; i++)
                            if (fn === jqLiteData) fn(this[i], arg1);
                            else
                                for (key in arg1) fn(this[i], key, arg1[key]);
                        return this
                    }
                    for (var value = fn.$dv, jj = value === undefined ? Math.min(this.length, 1) : this.length, j = 0; jj > j; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue
                    }
                    return value
                }
                for (i = 0; i < this.length; i++) fn(this[i], arg1, arg2);
                return this
            }
        }), forEach({
            removeData: jqLiteRemoveData,
            dealoc: jqLiteDealoc,
            on: function onFn(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                var events = jqLiteExpandoStore(element, "events"),
                    handle = jqLiteExpandoStore(element, "handle");
                events || jqLiteExpandoStore(element, "events", events = {}), handle || jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events)), forEach(type.split(" "), function (type) {
                    var eventFns = events[type];
                    if (!eventFns) {
                        if ("mouseenter" == type || "mouseleave" == type) {
                            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                                var adown = 9 === a.nodeType ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                            } : function (a, b) {
                                if (b)
                                    for (; b = b.parentNode;)
                                        if (b === a) return !0;
                                return !1
                            };
                            events[type] = [];
                            var eventmap = {
                                mouseleave: "mouseout",
                                mouseenter: "mouseover"
                            };
                            onFn(element, eventmap[type], function (event) {
                                var target = this,
                                    related = event.relatedTarget;
                                (!related || related !== target && !contains(target, related)) && handle(event, type)
                            })
                        } else addEventListenerFn(element, type, handle), events[type] = [];
                        eventFns = events[type]
                    }
                    eventFns.push(fn)
                })
            },
            off: jqLiteOff,
            one: function (element, type, fn) {
                element = jqLite(element), element.on(type, function onFn() {
                    element.off(type, fn), element.off(type, onFn)
                }), element.on(type, fn)
            },
            replaceWith: function (element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element), forEach(new JQLite(replaceNode), function (node) {
                    index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), index = node
                })
            },
            children: function (element) {
                var children = [];
                return forEach(element.childNodes, function (element) {
                    1 === element.nodeType && children.push(element)
                }), children
            },
            contents: function (element) {
                return element.contentDocument || element.childNodes || []
            },
            append: function (element, node) {
                forEach(new JQLite(node), function (child) {
                    (1 === element.nodeType || 11 === element.nodeType) && element.appendChild(child)
                })
            },
            prepend: function (element, node) {
                if (1 === element.nodeType) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), function (child) {
                        element.insertBefore(child, index)
                    })
                }
            },
            wrap: function (element, wrapNode) {
                wrapNode = jqLite(wrapNode)[0];
                var parent = element.parentNode;
                parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element)
            },
            remove: function (element) {
                jqLiteDealoc(element);
                var parent = element.parentNode;
                parent && parent.removeChild(element)
            },
            after: function (element, newElement) {
                var index = element,
                    parent = element.parentNode;
                forEach(new JQLite(newElement), function (node) {
                    parent.insertBefore(node, index.nextSibling), index = node
                })
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function (element, selector, condition) {
                selector && forEach(selector.split(" "), function (className) {
                    var classCondition = condition;
                    isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
                })
            },
            parent: function (element) {
                var parent = element.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            },
            next: function (element) {
                if (element.nextElementSibling) return element.nextElementSibling;
                for (var elm = element.nextSibling; null != elm && 1 !== elm.nodeType;) elm = elm.nextSibling;
                return elm
            },
            find: function (element, selector) {
                return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
            },
            clone: jqLiteClone,
            triggerHandler: function (element, eventName, eventData) {
                var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
                eventData = eventData || [];
                var event = [{
                    preventDefault: noop,
                    stopPropagation: noop
                }];
                forEach(eventFns, function (fn) {
                    fn.apply(element, event.concat(eventData))
                })
            }
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2, arg3) {
                for (var value, i = 0; i < this.length; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                return isDefined(value) ? value : this
            }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off
        }), HashMap.prototype = {
            put: function (key, value) {
                this[hashKey(key)] = value
            },
            get: function (key) {
                return this[hashKey(key)]
            },
            remove: function (key) {
                var value = this[key = hashKey(key)];
                return delete this[key], value
            }
        };
        var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
            FN_ARG_SPLIT = /,/,
            FN_ARG = /^\s*(_?)(\S+?)\1\s*$/,
            STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
            $injectorMinErr = minErr("$injector"),
            $animateMinErr = minErr("$animate"),
            $AnimateProvider = ["$provide",
                function ($provide) {
                    this.$$selectors = {}, this.register = function (name, factory) {
                        var key = name + "-animation";
                        if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                        this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory)
                    }, this.classNameFilter = function (expression) {
                        return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null), this.$$classNameFilter
                    }, this.$get = ["$timeout", "$$asyncCallback",
                        function ($timeout, $$asyncCallback) {
                            function async(fn) {
                                fn && $$asyncCallback(fn)
                            }
                            return {
                                enter: function (element, parent, after, done) {
                                    after ? after.after(element) : (parent && parent[0] || (parent = after.parent()), parent.append(element)), async(done)
                                },
                                leave: function (element, done) {
                                    element.remove(), async(done)
                                },
                                move: function (element, parent, after, done) {
                                    this.enter(element, parent, after, done)
                                },
                                addClass: function (element, className, done) {
                                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", forEach(element, function (element) {
                                        jqLiteAddClass(element, className)
                                    }), async(done)
                                },
                                removeClass: function (element, className, done) {
                                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", forEach(element, function (element) {
                                        jqLiteRemoveClass(element, className)
                                    }), async(done)
                                },
                                setClass: function (element, add, remove, done) {
                                    forEach(element, function (element) {
                                        jqLiteAddClass(element, add), jqLiteRemoveClass(element, remove)
                                    }), async(done)
                                },
                                enabled: noop
                            }
                        }
                    ]
                }
            ],
            $compileMinErr = minErr("$compile");
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"];
        var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i,
            $interpolateMinErr = minErr("$interpolate"),
            PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
            DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            },
            $locationMinErr = minErr("$location");
        LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
            $$html5: !1,
            $$replace: !1,
            absUrl: locationGetter("$$absUrl"),
            url: function (url, replace) {
                if (isUndefined(url)) return this.$$url;
                var match = PATH_MATCH.exec(url);
                return match[1] && this.path(decodeURIComponent(match[1])), (match[2] || match[1]) && this.search(match[3] || ""), this.hash(match[5] || "", replace), this
            },
            protocol: locationGetter("$$protocol"),
            host: locationGetter("$$host"),
            port: locationGetter("$$port"),
            path: locationGetterSetter("$$path", function (path) {
                return "/" == path.charAt(0) ? path : "/" + path
            }),
            search: function (search, paramValue) {
                switch (arguments.length) {
                case 0:
                    return this.$$search;
                case 1:
                    if (isString(search)) this.$$search = parseKeyValue(search);
                    else {
                        if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                        this.$$search = search
                    }
                    break;
                default:
                    isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
                }
                return this.$$compose(), this
            },
            hash: locationGetterSetter("$$hash", identity),
            replace: function () {
                return this.$$replace = !0, this
            }
        };
        var promiseWarning, $parseMinErr = minErr("$parse"),
            promiseWarningCache = {},
            OPERATORS = {
                "null": function () {
                    return null
                },
                "true": function () {
                    return !0
                },
                "false": function () {
                    return !1
                },
                undefined: noop,
                "+": function (self, locals, a, b) {
                    return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined
                },
                "-": function (self, locals, a, b) {
                    return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0)
                },
                "*": function (self, locals, a, b) {
                    return a(self, locals) * b(self, locals)
                },
                "/": function (self, locals, a, b) {
                    return a(self, locals) / b(self, locals)
                },
                "%": function (self, locals, a, b) {
                    return a(self, locals) % b(self, locals)
                },
                "^": function (self, locals, a, b) {
                    return a(self, locals) ^ b(self, locals)
                },
                "=": noop,
                "===": function (self, locals, a, b) {
                    return a(self, locals) === b(self, locals)
                },
                "!==": function (self, locals, a, b) {
                    return a(self, locals) !== b(self, locals)
                },
                "==": function (self, locals, a, b) {
                    return a(self, locals) == b(self, locals)
                },
                "!=": function (self, locals, a, b) {
                    return a(self, locals) != b(self, locals)
                },
                "<": function (self, locals, a, b) {
                    return a(self, locals) < b(self, locals)
                },
                ">": function (self, locals, a, b) {
                    return a(self, locals) > b(self, locals)
                },
                "<=": function (self, locals, a, b) {
                    return a(self, locals) <= b(self, locals)
                },
                ">=": function (self, locals, a, b) {
                    return a(self, locals) >= b(self, locals)
                },
                "&&": function (self, locals, a, b) {
                    return a(self, locals) && b(self, locals)
                },
                "||": function (self, locals, a, b) {
                    return a(self, locals) || b(self, locals)
                },
                "&": function (self, locals, a, b) {
                    return a(self, locals) & b(self, locals)
                },
                "|": function (self, locals, a, b) {
                    return b(self, locals)(self, locals, a(self, locals))
                },
                "!": function (self, locals, a) {
                    return !a(self, locals)
                }
            },
            ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "	",
                v: "",
                "'": "'",
                '"': '"'
            },
            Lexer = function (options) {
                this.options = options
            };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function (text) {
                this.text = text, this.index = 0, this.ch = undefined, this.lastCh = ":", this.tokens = [];
                for (var token, json = []; this.index < this.text.length;) {
                    if (this.ch = this.text.charAt(this.index), this.is("\"'")) this.readString(this.ch);
                    else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) this.readNumber();
                    else if (this.isIdent(this.ch)) this.readIdent(), this.was("{,") && "{" === json[0] && (token = this.tokens[this.tokens.length - 1]) && (token.json = -1 === token.text.indexOf("."));
                    else if (this.is("(){}[].,;:?")) this.tokens.push({
                        index: this.index,
                        text: this.ch,
                        json: this.was(":[,") && this.is("{[") || this.is("}]:,")
                    }), this.is("{[") && json.unshift(this.ch), this.is("}]") && json.shift(), this.index++;
                    else {
                        if (this.isWhitespace(this.ch)) {
                            this.index++;
                            continue
                        }
                        var ch2 = this.ch + this.peek(),
                            ch3 = ch2 + this.peek(2),
                            fn = OPERATORS[this.ch],
                            fn2 = OPERATORS[ch2],
                            fn3 = OPERATORS[ch3];
                        fn3 ? (this.tokens.push({
                            index: this.index,
                            text: ch3,
                            fn: fn3
                        }), this.index += 3) : fn2 ? (this.tokens.push({
                            index: this.index,
                            text: ch2,
                            fn: fn2
                        }), this.index += 2) : fn ? (this.tokens.push({
                            index: this.index,
                            text: this.ch,
                            fn: fn,
                            json: this.was("[,:") && this.is("+-")
                        }), this.index += 1) : this.throwError("Unexpected next character ", this.index, this.index + 1)
                    }
                    this.lastCh = this.ch
                }
                return this.tokens
            },
            is: function (chars) {
                return -1 !== chars.indexOf(this.ch)
            },
            was: function (chars) {
                return -1 !== chars.indexOf(this.lastCh)
            },
            peek: function (i) {
                var num = i || 1;
                return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1
            },
            isNumber: function (ch) {
                return ch >= "0" && "9" >= ch
            },
            isWhitespace: function (ch) {
                return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "\xa0" === ch
            },
            isIdent: function (ch) {
                return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch
            },
            isExpOperator: function (ch) {
                return "-" === ch || "+" === ch || this.isNumber(ch)
            },
            throwError: function (error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
            },
            readNumber: function () {
                for (var number = "", start = this.index; this.index < this.text.length;) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if ("." == ch || this.isNumber(ch)) number += ch;
                    else {
                        var peekCh = this.peek();
                        if ("e" == ch && this.isExpOperator(peekCh)) number += ch;
                        else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch;
                        else {
                            if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                            this.throwError("Invalid exponent")
                        }
                    }
                    this.index++
                }
                number = 1 * number, this.tokens.push({
                    index: start,
                    text: number,
                    json: !0,
                    fn: function () {
                        return number
                    }
                })
            },
            readIdent: function () {
                for (var lastDot, peekIndex, methodName, ch, parser = this, ident = "", start = this.index; this.index < this.text.length && (ch = this.text.charAt(this.index), "." === ch || this.isIdent(ch) || this.isNumber(ch));) "." === ch && (lastDot = this.index), ident += ch, this.index++;
                if (lastDot)
                    for (peekIndex = this.index; peekIndex < this.text.length;) {
                        if (ch = this.text.charAt(peekIndex), "(" === ch) {
                            methodName = ident.substr(lastDot - start + 1), ident = ident.substr(0, lastDot - start), this.index = peekIndex;
                            break
                        }
                        if (!this.isWhitespace(ch)) break;
                        peekIndex++
                    }
                var token = {
                    index: start,
                    text: ident
                };
                if (OPERATORS.hasOwnProperty(ident)) token.fn = OPERATORS[ident], token.json = OPERATORS[ident];
                else {
                    var getter = getterFn(ident, this.options, this.text);
                    token.fn = extend(function (self, locals) {
                        return getter(self, locals)
                    }, {
                        assign: function (self, value) {
                            return setter(self, ident, value, parser.text, parser.options)
                        }
                    })
                }
                this.tokens.push(token), methodName && (this.tokens.push({
                    index: lastDot,
                    text: ".",
                    json: !1
                }), this.tokens.push({
                    index: lastDot + 1,
                    text: methodName,
                    json: !1
                }))
            },
            readString: function (quote) {
                var start = this.index;
                this.index++;
                for (var string = "", rawString = quote, escape = !1; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if (rawString += ch, escape) {
                        if ("u" === ch) {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), this.index += 4, string += String.fromCharCode(parseInt(hex, 16))
                        } else {
                            var rep = ESCAPE[ch];
                            string += rep ? rep : ch
                        }
                        escape = !1
                    } else if ("\\" === ch) escape = !0;
                    else {
                        if (ch === quote) return this.index++, void this.tokens.push({
                            index: start,
                            text: rawString,
                            string: string,
                            json: !0,
                            fn: function () {
                                return string
                            }
                        });
                        string += ch
                    }
                    this.index++
                }
                this.throwError("Unterminated quote", start)
            }
        };
        var Parser = function (lexer, $filter, options) {
            this.lexer = lexer, this.$filter = $filter, this.options = options
        };
        Parser.ZERO = extend(function () {
            return 0
        }, {
            constant: !0
        }), Parser.prototype = {
            constructor: Parser,
            parse: function (text, json) {
                this.text = text, this.json = json, this.tokens = this.lexer.lex(text), json && (this.assignment = this.logicalOR, this.functionCall = this.fieldAccess = this.objectIndex = this.filterChain = function () {
                    this.throwError("is not valid json", {
                        text: text,
                        index: 0
                    })
                });
                var value = json ? this.primary() : this.statements();
                return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), value.literal = !!value.literal, value.constant = !!value.constant, value
            },
            primary: function () {
                var primary;
                if (this.expect("(")) primary = this.filterChain(), this.consume(")");
                else if (this.expect("[")) primary = this.arrayDeclaration();
                else if (this.expect("{")) primary = this.object();
                else {
                    var token = this.expect();
                    primary = token.fn, primary || this.throwError("not a primary expression", token), token.json && (primary.constant = !0, primary.literal = !0)
                }
                for (var next, context; next = this.expect("(", "[", ".");) "(" === next.text ? (primary = this.functionCall(primary, context), context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
                return primary
            },
            throwError: function (msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
            },
            peekToken: function () {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                return this.tokens[0]
            },
            peek: function (e1, e2, e3, e4) {
                if (this.tokens.length > 0) {
                    var token = this.tokens[0],
                        t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token
                }
                return !1
            },
            expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                return token ? (this.json && !token.json && this.throwError("is not valid json", token), this.tokens.shift(), token) : !1
            },
            consume: function (e1) {
                this.expect(e1) || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek())
            },
            unaryFn: function (fn, right) {
                return extend(function (self, locals) {
                    return fn(self, locals, right)
                }, {
                    constant: right.constant
                })
            },
            ternaryFn: function (left, middle, right) {
                return extend(function (self, locals) {
                    return left(self, locals) ? middle(self, locals) : right(self, locals)
                }, {
                    constant: left.constant && middle.constant && right.constant
                })
            },
            binaryFn: function (left, fn, right) {
                return extend(function (self, locals) {
                    return fn(self, locals, left, right)
                }, {
                    constant: left.constant && right.constant
                })
            },
            statements: function () {
                for (var statements = [];;)
                    if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), !this.expect(";")) return 1 === statements.length ? statements[0] : function (self, locals) {
                        for (var value, i = 0; i < statements.length; i++) {
                            var statement = statements[i];
                            statement && (value = statement(self, locals))
                        }
                        return value
                    }
            },
            filterChain: function () {
                for (var token, left = this.expression();;) {
                    if (!(token = this.expect("|"))) return left;
                    left = this.binaryFn(left, token.fn, this.filter())
                }
            },
            filter: function () {
                for (var token = this.expect(), fn = this.$filter(token.text), argsFn = [];;) {
                    if (!(token = this.expect(":"))) {
                        var fnInvoke = function (self, locals, input) {
                            for (var args = [input], i = 0; i < argsFn.length; i++) args.push(argsFn[i](self, locals));
                            return fn.apply(self, args)
                        };
                        return function () {
                            return fnInvoke
                        }
                    }
                    argsFn.push(this.expression())
                }
            },
            expression: function () {
                return this.assignment()
            },
            assignment: function () {
                var right, token, left = this.ternary();
                return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), right = this.ternary(), function (scope, locals) {
                    return left.assign(scope, right(scope, locals), locals)
                }) : left
            },
            ternary: function () {
                var middle, token, left = this.logicalOR();
                return (token = this.expect("?")) ? (middle = this.ternary(), (token = this.expect(":")) ? this.ternaryFn(left, middle, this.ternary()) : void this.throwError("expected :", token)) : left
            },
            logicalOR: function () {
                for (var token, left = this.logicalAND();;) {
                    if (!(token = this.expect("||"))) return left;
                    left = this.binaryFn(left, token.fn, this.logicalAND())
                }
            },
            logicalAND: function () {
                var token, left = this.equality();
                return (token = this.expect("&&")) && (left = this.binaryFn(left, token.fn, this.logicalAND())), left
            },
            equality: function () {
                var token, left = this.relational();
                return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.fn, this.equality())), left
            },
            relational: function () {
                var token, left = this.additive();
                return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.fn, this.relational())), left
            },
            additive: function () {
                for (var token, left = this.multiplicative(); token = this.expect("+", "-");) left = this.binaryFn(left, token.fn, this.multiplicative());
                return left
            },
            multiplicative: function () {
                for (var token, left = this.unary(); token = this.expect("*", "/", "%");) left = this.binaryFn(left, token.fn, this.unary());
                return left
            },
            unary: function () {
                var token;
                return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.fn, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.fn, this.unary()) : this.primary()
            },
            fieldAccess: function (object) {
                var parser = this,
                    field = this.expect().text,
                    getter = getterFn(field, this.options, this.text);
                return extend(function (scope, locals, self) {
                    return getter(self || object(scope, locals))
                }, {
                    assign: function (scope, value, locals) {
                        return setter(object(scope, locals), field, value, parser.text, parser.options)
                    }
                })
            },
            objectIndex: function (obj) {
                var parser = this,
                    indexFn = this.expression();
                return this.consume("]"), extend(function (self, locals) {
                    var v, p, o = obj(self, locals),
                        i = indexFn(self, locals);
                    return o ? (v = ensureSafeObject(o[i], parser.text), v && v.then && parser.options.unwrapPromises && (p = v, "$$v" in v || (p.$$v = undefined, p.then(function (val) {
                        p.$$v = val
                    })), v = v.$$v), v) : undefined
                }, {
                    assign: function (self, value, locals) {
                        var key = indexFn(self, locals),
                            safe = ensureSafeObject(obj(self, locals), parser.text);
                        return safe[key] = value
                    }
                })
            },
            functionCall: function (fn, contextGetter) {
                var argsFn = [];
                if (")" !== this.peekToken().text)
                    do argsFn.push(this.expression()); while (this.expect(","));
                this.consume(")");
                var parser = this;
                return function (scope, locals) {
                    for (var args = [], context = contextGetter ? contextGetter(scope, locals) : scope, i = 0; i < argsFn.length; i++) args.push(argsFn[i](scope, locals));
                    var fnPtr = fn(scope, locals, context) || noop;
                    ensureSafeObject(context, parser.text), ensureSafeObject(fnPtr, parser.text);
                    var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
                    return ensureSafeObject(v, parser.text)
                }
            },
            arrayDeclaration: function () {
                var elementFns = [],
                    allConstant = !0;
                if ("]" !== this.peekToken().text)
                    do {
                        if (this.peek("]")) break;
                        var elementFn = this.expression();
                        elementFns.push(elementFn), elementFn.constant || (allConstant = !1)
                    } while (this.expect(","));
                return this.consume("]"), extend(function (self, locals) {
                    for (var array = [], i = 0; i < elementFns.length; i++) array.push(elementFns[i](self, locals));
                    return array
                }, {
                    literal: !0,
                    constant: allConstant
                })
            },
            object: function () {
                var keyValues = [],
                    allConstant = !0;
                if ("}" !== this.peekToken().text)
                    do {
                        if (this.peek("}")) break;
                        var token = this.expect(),
                            key = token.string || token.text;
                        this.consume(":");
                        var value = this.expression();
                        keyValues.push({
                            key: key,
                            value: value
                        }), value.constant || (allConstant = !1)
                    } while (this.expect(","));
                return this.consume("}"), extend(function (self, locals) {
                    for (var object = {}, i = 0; i < keyValues.length; i++) {
                        var keyValue = keyValues[i];
                        object[keyValue.key] = keyValue.value(self, locals)
                    }
                    return object
                }, {
                    literal: !0,
                    constant: allConstant
                })
            }
        };
        var getterFnCache = {},
            $sceMinErr = minErr("$sce"),
            SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            },
            urlParsingNode = document.createElement("a"),
            originUrl = urlResolve(window.location.href, !0);
        $FilterProvider.$inject = ["$provide"], currencyFilter.$inject = ["$locale"], numberFilter.$inject = ["$locale"];
        var DECIMAL_SEP = ".",
            DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4),
                yy: dateGetter("FullYear", 2, 0, !0),
                y: dateGetter("FullYear", 1),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", !0),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", !0),
                a: ampmGetter,
                Z: timeZoneGetter
            },
            DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
            NUMBER_STRING = /^\-?\d+$/;
        dateFilter.$inject = ["$locale"];
        var lowercaseFilter = valueFn(lowercase),
            uppercaseFilter = valueFn(uppercase);
        orderByFilter.$inject = ["$parse"];
        var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function (element, attr) {
                    return 8 >= msie && (attr.href || attr.name || attr.$set("href", ""), element.append(document.createComment("IE fix"))), attr.href || attr.xlinkHref || attr.name ? void 0 : function (scope, element) {
                        var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                        element.on("click", function (event) {
                            element.attr(href) || event.preventDefault()
                        })
                    }
                }
            }),
            ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function (propName, attrName) {
            if ("multiple" != propName) {
                var normalized = directiveNormalize("ng-" + attrName);
                ngAttributeAliasDirectives[normalized] = function () {
                    return {
                        priority: 100,
                        link: function (scope, element, attr) {
                            scope.$watch(attr[normalized], function (value) {
                                attr.$set(attrName, !!value)
                            })
                        }
                    }
                }
            }
        }), forEach(["src", "srcset", "href"], function (attrName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    priority: 99,
                    link: function (scope, element, attr) {
                        var propName = attrName,
                            name = attrName;
                        "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function (value) {
                            value && (attr.$set(name, value), msie && propName && element.prop(propName, attr[name]))
                        })
                    }
                }
            }
        });
        var nullFormCtrl = {
            $addControl: noop,
            $removeControl: noop,
            $setValidity: noop,
            $setDirty: noop,
            $setPristine: noop
        };
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate"];
        var formDirectiveFactory = function (isNgForm) {
                return ["$timeout",
                    function ($timeout) {
                        var formDirective = {
                            name: "form",
                            restrict: isNgForm ? "EAC" : "E",
                            controller: FormController,
                            compile: function () {
                                return {
                                    pre: function (scope, formElement, attr, controller) {
                                        if (!attr.action) {
                                            var preventDefaultListener = function (event) {
                                                event.preventDefault ? event.preventDefault() : event.returnValue = !1
                                            };
                                            addEventListenerFn(formElement[0], "submit", preventDefaultListener), formElement.on("$destroy", function () {
                                                $timeout(function () {
                                                    removeEventListenerFn(formElement[0], "submit", preventDefaultListener)
                                                }, 0, !1)
                                            })
                                        }
                                        var parentFormCtrl = formElement.parent().controller("form"),
                                            alias = attr.name || attr.ngForm;
                                        alias && setter(scope, alias, controller, alias), parentFormCtrl && formElement.on("$destroy", function () {
                                            parentFormCtrl.$removeControl(controller), alias && setter(scope, alias, undefined, alias), extend(controller, nullFormCtrl)
                                        })
                                    }
                                }
                            }
                        };
                        return formDirective
                    }
                ]
            },
            formDirective = formDirectiveFactory(),
            ngFormDirective = formDirectiveFactory(!0),
            URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/,
            EMAIL_REGEXP = /^[a-z0-9!#$%&'*+/=?^_`{|}~.-]+@[a-z0-9-]+(\.[a-z0-9-]+)*$/i,
            NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/,
            inputType = {
                text: textInputType,
                number: numberInputType,
                url: urlInputType,
                email: emailInputType,
                radio: radioInputType,
                checkbox: checkboxInputType,
                hidden: noop,
                button: noop,
                submit: noop,
                reset: noop,
                file: noop
            },
            inputDirective = ["$browser", "$sniffer",
                function ($browser, $sniffer) {
                    return {
                        restrict: "E",
                        require: "?ngModel",
                        link: function (scope, element, attr, ctrl) {
                            ctrl && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser)
                        }
                    }
                }
            ],
            VALID_CLASS = "ng-valid",
            INVALID_CLASS = "ng-invalid",
            PRISTINE_CLASS = "ng-pristine",
            DIRTY_CLASS = "ng-dirty",
            NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate",
                function ($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
                    function toggleValidCss(isValid, validationErrorKey) {
                        validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey)
                    }
                    this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$name = $attr.name;
                    var ngModelGet = $parse($attr.ngModel),
                        ngModelSet = ngModelGet.assign;
                    if (!ngModelSet) throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
                    this.$render = noop, this.$isEmpty = function (value) {
                        return isUndefined(value) || "" === value || null === value || value !== value
                    };
                    var parentForm = $element.inheritedData("$formController") || nullFormCtrl,
                        invalidCount = 0,
                        $error = this.$error = {};
                    $element.addClass(PRISTINE_CLASS), toggleValidCss(!0), this.$setValidity = function (validationErrorKey, isValid) {
                        $error[validationErrorKey] !== !isValid && (isValid ? ($error[validationErrorKey] && invalidCount--, invalidCount || (toggleValidCss(!0), this.$valid = !0, this.$invalid = !1)) : (toggleValidCss(!1), this.$invalid = !0, this.$valid = !1, invalidCount++), $error[validationErrorKey] = !isValid, toggleValidCss(isValid, validationErrorKey), parentForm.$setValidity(validationErrorKey, isValid, this))
                    }, this.$setPristine = function () {
                        this.$dirty = !1, this.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), $animate.addClass($element, PRISTINE_CLASS)
                    }, this.$setViewValue = function (value) {
                        this.$viewValue = value, this.$pristine && (this.$dirty = !0, this.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), parentForm.$setDirty()), forEach(this.$parsers, function (fn) {
                            value = fn(value)
                        }), this.$modelValue !== value && (this.$modelValue = value, ngModelSet($scope, value), forEach(this.$viewChangeListeners, function (listener) {
                            try {
                                listener()
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        }))
                    };
                    var ctrl = this;
                    $scope.$watch(function () {
                        var value = ngModelGet($scope);
                        if (ctrl.$modelValue !== value) {
                            var formatters = ctrl.$formatters,
                                idx = formatters.length;
                            for (ctrl.$modelValue = value; idx--;) value = formatters[idx](value);
                            ctrl.$viewValue !== value && (ctrl.$viewValue = value, ctrl.$render())
                        }
                        return value
                    })
                }
            ],
            ngModelDirective = function () {
                return {
                    require: ["ngModel", "^?form"],
                    controller: NgModelController,
                    link: function (scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0],
                            formCtrl = ctrls[1] || nullFormCtrl;
                        formCtrl.$addControl(modelCtrl), scope.$on("$destroy", function () {
                            formCtrl.$removeControl(modelCtrl)
                        })
                    }
                }
            },
            ngChangeDirective = valueFn({
                require: "ngModel",
                link: function (scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push(function () {
                        scope.$eval(attr.ngChange)
                    })
                }
            }),
            requiredDirective = function () {
                return {
                    require: "?ngModel",
                    link: function (scope, elm, attr, ctrl) {
                        if (ctrl) {
                            attr.required = !0;
                            var validator = function (value) {
                                return attr.required && ctrl.$isEmpty(value) ? void ctrl.$setValidity("required", !1) : (ctrl.$setValidity("required", !0), value)
                            };
                            ctrl.$formatters.push(validator), ctrl.$parsers.unshift(validator), attr.$observe("required", function () {
                                validator(ctrl.$viewValue)
                            })
                        }
                    }
                }
            },
            ngListDirective = function () {
                return {
                    require: "ngModel",
                    link: function (scope, element, attr, ctrl) {
                        var match = /\/(.*)\//.exec(attr.ngList),
                            separator = match && new RegExp(match[1]) || attr.ngList || ",",
                            parse = function (viewValue) {
                                if (!isUndefined(viewValue)) {
                                    var list = [];
                                    return viewValue && forEach(viewValue.split(separator), function (value) {
                                        value && list.push(trim(value))
                                    }), list
                                }
                            };
                        ctrl.$parsers.push(parse), ctrl.$formatters.push(function (value) {
                            return isArray(value) ? value.join(", ") : undefined
                        }), ctrl.$isEmpty = function (value) {
                            return !value || !value.length
                        }
                    }
                }
            },
            CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/,
            ngValueDirective = function () {
                return {
                    priority: 100,
                    compile: function (tpl, tplAttr) {
                        return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function (scope, elm, attr) {
                            attr.$set("value", scope.$eval(attr.ngValue))
                        } : function (scope, elm, attr) {
                            scope.$watch(attr.ngValue, function (value) {
                                attr.$set("value", value)
                            })
                        }
                    }
                }
            },
            ngBindDirective = ngDirective(function (scope, element, attr) {
                element.addClass("ng-binding").data("$binding", attr.ngBind), scope.$watch(attr.ngBind, function (value) {
                    element.text(value == undefined ? "" : value)
                })
            }),
            ngBindTemplateDirective = ["$interpolate",
                function ($interpolate) {
                    return function (scope, element, attr) {
                        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                        element.addClass("ng-binding").data("$binding", interpolateFn), attr.$observe("ngBindTemplate", function (value) {
                            element.text(value)
                        })
                    }
                }
            ],
            ngBindHtmlDirective = ["$sce", "$parse",
                function ($sce, $parse) {
                    return function (scope, element, attr) {
                        function getStringValue() {
                            return (parsed(scope) || "").toString()
                        }
                        element.addClass("ng-binding").data("$binding", attr.ngBindHtml);
                        var parsed = $parse(attr.ngBindHtml);
                        scope.$watch(getStringValue, function () {
                            element.html($sce.getTrustedHtml(parsed(scope)) || "")
                        })
                    }
                }
            ],
            ngClassDirective = classDirective("", !0),
            ngClassOddDirective = classDirective("Odd", 0),
            ngClassEvenDirective = classDirective("Even", 1),
            ngCloakDirective = ngDirective({
                compile: function (element, attr) {
                    attr.$set("ngCloak", undefined), element.removeClass("ng-cloak")
                }
            }),
            ngControllerDirective = [
                function () {
                    return {
                        scope: !0,
                        controller: "@",
                        priority: 500
                    }
                }
            ],
            ngEventDirectives = {};
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (name) {
            var directiveName = directiveNormalize("ng-" + name);
            ngEventDirectives[directiveName] = ["$parse",
                function ($parse) {
                    return {
                        compile: function ($element, attr) {
                            var fn = $parse(attr[directiveName]);
                            return function (scope, element) {
                                element.on(lowercase(name), function (event) {
                                    scope.$apply(function () {
                                        fn(scope, {
                                            $event: event
                                        })
                                    })
                                })
                            }
                        }
                    }
                }
            ]
        });
        var ngIfDirective = ["$animate",
                function ($animate) {
                    return {
                        transclude: "element",
                        priority: 600,
                        terminal: !0,
                        restrict: "A",
                        $$tlb: !0,
                        link: function ($scope, $element, $attr, ctrl, $transclude) {
                            var block, childScope, previousElements;
                            $scope.$watch($attr.ngIf, function (value) {
                                toBoolean(value) ? childScope || (childScope = $scope.$new(), $transclude(childScope, function (clone) {
                                    clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), block = {
                                        clone: clone
                                    }, $animate.enter(clone, $element.parent(), $element)
                                })) : (previousElements && (previousElements.remove(), previousElements = null), childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockElements(block.clone), $animate.leave(previousElements, function () {
                                    previousElements = null
                                }), block = null))
                            })
                        }
                    }
                }
            ],
            ngIncludeDirective = ["$http", "$templateCache", "$anchorScroll", "$animate", "$sce",
                function ($http, $templateCache, $anchorScroll, $animate, $sce) {
                    return {
                        restrict: "ECA",
                        priority: 400,
                        terminal: !0,
                        transclude: "element",
                        controller: angular.noop,
                        compile: function (element, attr) {
                            var srcExp = attr.ngInclude || attr.src,
                                onloadExp = attr.onload || "",
                                autoScrollExp = attr.autoscroll;
                            return function (scope, $element, $attr, ctrl, $transclude) {
                                var currentScope, previousElement, currentElement, changeCounter = 0,
                                    cleanupLastIncludeContent = function () {
                                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement, function () {
                                            previousElement = null
                                        }), previousElement = currentElement, currentElement = null)
                                    };
                                scope.$watch($sce.parseAsResourceUrl(srcExp), function (src) {
                                    var afterAnimation = function () {
                                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                                        },
                                        thisChangeId = ++changeCounter;
                                    src ? ($http.get(src, {
                                        cache: $templateCache
                                    }).success(function (response) {
                                        if (thisChangeId === changeCounter) {
                                            var newScope = scope.$new();
                                            ctrl.template = response;
                                            var clone = $transclude(newScope, function (clone) {
                                                cleanupLastIncludeContent(), $animate.enter(clone, null, $element, afterAnimation)
                                            });
                                            currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded"), scope.$eval(onloadExp)
                                        }
                                    }).error(function () {
                                        thisChangeId === changeCounter && cleanupLastIncludeContent()
                                    }), scope.$emit("$includeContentRequested")) : (cleanupLastIncludeContent(), ctrl.template = null)
                                })
                            }
                        }
                    }
                }
            ],
            ngIncludeFillContentDirective = ["$compile",
                function ($compile) {
                    return {
                        restrict: "ECA",
                        priority: -400,
                        require: "ngInclude",
                        link: function (scope, $element, $attr, ctrl) {
                            $element.html(ctrl.template), $compile($element.contents())(scope)
                        }
                    }
                }
            ],
            ngInitDirective = ngDirective({
                priority: 450,
                compile: function () {
                    return {
                        pre: function (scope, element, attrs) {
                            scope.$eval(attrs.ngInit)
                        }
                    }
                }
            }),
            ngNonBindableDirective = ngDirective({
                terminal: !0,
                priority: 1e3
            }),
            ngPluralizeDirective = ["$locale", "$interpolate",
                function ($locale, $interpolate) {
                    var BRACE = /{}/g;
                    return {
                        restrict: "EA",
                        link: function (scope, element, attr) {
                            var numberExp = attr.count,
                                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                                offset = attr.offset || 0,
                                whens = scope.$eval(whenExp) || {},
                                whensExpFns = {},
                                startSymbol = $interpolate.startSymbol(),
                                endSymbol = $interpolate.endSymbol(),
                                isWhen = /^when(Minus)?(.+)$/;
                            forEach(attr, function (expression, attributeName) {
                                isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]))
                            }), forEach(whens, function (expression, key) {
                                whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol))
                            }), scope.$watch(function () {
                                var value = parseFloat(scope.$eval(numberExp));
                                return isNaN(value) ? "" : (value in whens || (value = $locale.pluralCat(value - offset)), whensExpFns[value](scope, element, !0))
                            }, function (newVal) {
                                element.text(newVal)
                            })
                        }
                    }
                }
            ],
            ngRepeatDirective = ["$parse", "$animate",
                function ($parse, $animate) {
                    function getBlockStart(block) {
                        return block.clone[0]
                    }

                    function getBlockEnd(block) {
                        return block.clone[block.clone.length - 1]
                    }
                    var NG_REMOVED = "$$NG_REMOVED",
                        ngRepeatMinErr = minErr("ngRepeat");
                    return {
                        transclude: "element",
                        priority: 1e3,
                        terminal: !0,
                        $$tlb: !0,
                        link: function ($scope, $element, $attr, ctrl, $transclude) {
                            var trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, expression = $attr.ngRepeat,
                                match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/),
                                hashFnLocals = {
                                    $id: hashKey
                                };
                            if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                            if (lhs = match[1], rhs = match[2], trackByExp = match[3], trackByExp ? (trackByExpGetter = $parse(trackByExp), trackByIdExpFn = function (key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals)
                            }) : (trackByIdArrayFn = function (key, value) {
                                return hashKey(value)
                            }, trackByIdObjFn = function (key) {
                                return key
                            }), match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                            valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                            var lastBlockMap = {};
                            $scope.$watchCollection(rhs, function (collection) {
                                var index, length, nextNode, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, elementsToRemove, previousNode = $element[0],
                                    nextBlockMap = {},
                                    nextBlockOrder = [];
                                if (isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                                    for (key in collection) collection.hasOwnProperty(key) && "$" != key.charAt(0) && collectionKeys.push(key);
                                    collectionKeys.sort()
                                }
                                for (arrayLength = collectionKeys.length, length = nextBlockOrder.length = collectionKeys.length, index = 0; length > index; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn(key, value, index), assertNotHasOwnProperty(trackById, "`track by` id"), lastBlockMap.hasOwnProperty(trackById)) block = lastBlockMap[trackById], delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block;
                                    else {
                                        if (nextBlockMap.hasOwnProperty(trackById)) throw forEach(nextBlockOrder, function (block) {
                                            block && block.scope && (lastBlockMap[block.id] = block)
                                        }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                                        nextBlockOrder[index] = {
                                            id: trackById
                                        }, nextBlockMap[trackById] = !1
                                    }
                                for (key in lastBlockMap) lastBlockMap.hasOwnProperty(key) && (block = lastBlockMap[key], elementsToRemove = getBlockElements(block.clone), $animate.leave(elementsToRemove), forEach(elementsToRemove, function (element) {
                                    element[NG_REMOVED] = !0
                                }), block.scope.$destroy());
                                for (index = 0, length = collectionKeys.length; length > index; index++) {
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], block = nextBlockOrder[index], nextBlockOrder[index - 1] && (previousNode = getBlockEnd(nextBlockOrder[index - 1])), block.scope) {
                                        childScope = block.scope, nextNode = previousNode;
                                        do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                                        getBlockStart(block) != nextNode && $animate.move(getBlockElements(block.clone), null, jqLite(previousNode)), previousNode = getBlockEnd(block)
                                    } else childScope = $scope.$new();
                                    childScope[valueIdentifier] = value, keyIdentifier && (childScope[keyIdentifier] = key), childScope.$index = index, childScope.$first = 0 === index, childScope.$last = index === arrayLength - 1, childScope.$middle = !(childScope.$first || childScope.$last), childScope.$odd = !(childScope.$even = 0 === (1 & index)), block.scope || $transclude(childScope, function (clone) {
                                        clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " "), $animate.enter(clone, null, jqLite(previousNode)), previousNode = clone, block.scope = childScope, block.clone = clone, nextBlockMap[block.id] = block
                                    })
                                }
                                lastBlockMap = nextBlockMap
                            })
                        }
                    }
                }
            ],
            ngShowDirective = ["$animate",
                function ($animate) {
                    return function (scope, element, attr) {
                        scope.$watch(attr.ngShow, function (value) {
                            $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide")
                        })
                    }
                }
            ],
            ngHideDirective = ["$animate",
                function ($animate) {
                    return function (scope, element, attr) {
                        scope.$watch(attr.ngHide, function (value) {
                            $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide")
                        })
                    }
                }
            ],
            ngStyleDirective = ngDirective(function (scope, element, attr) {
                scope.$watch(attr.ngStyle, function (newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles, function (val, style) {
                        element.css(style, "")
                    }), newStyles && element.css(newStyles)
                }, !0)
            }),
            ngSwitchDirective = ["$animate",
                function ($animate) {
                    return {
                        restrict: "EA",
                        require: "ngSwitch",
                        controller: ["$scope",
                            function () {
                                this.cases = {}
                            }
                        ],
                        link: function (scope, element, attr, ngSwitchController) {
                            var selectedTranscludes, selectedElements, previousElements, watchExpr = attr.ngSwitch || attr.on,
                                selectedScopes = [];
                            scope.$watch(watchExpr, function (value) {
                                var i, ii = selectedScopes.length;
                                if (ii > 0) {
                                    if (previousElements) {
                                        for (i = 0; ii > i; i++) previousElements[i].remove();
                                        previousElements = null
                                    }
                                    for (previousElements = [], i = 0; ii > i; i++) {
                                        var selected = selectedElements[i];
                                        selectedScopes[i].$destroy(), previousElements[i] = selected, $animate.leave(selected, function () {
                                            previousElements.splice(i, 1), 0 === previousElements.length && (previousElements = null)
                                        })
                                    }
                                }
                                selectedElements = [], selectedScopes = [], (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && (scope.$eval(attr.change), forEach(selectedTranscludes, function (selectedTransclude) {
                                    var selectedScope = scope.$new();
                                    selectedScopes.push(selectedScope), selectedTransclude.transclude(selectedScope, function (caseElement) {
                                        var anchor = selectedTransclude.element;
                                        selectedElements.push(caseElement), $animate.enter(caseElement, anchor.parent(), anchor)
                                    })
                                }))
                            })
                        }
                    }
                }
            ],
            ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 800,
                require: "^ngSwitch",
                link: function (scope, element, attrs, ctrl, $transclude) {
                    ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], ctrl.cases["!" + attrs.ngSwitchWhen].push({
                        transclude: $transclude,
                        element: element
                    })
                }
            }),
            ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 800,
                require: "^ngSwitch",
                link: function (scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    })
                }
            }),
            ngTranscludeDirective = ngDirective({
                link: function ($scope, $element, $attrs, controller, $transclude) {
                    if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    $transclude(function (clone) {
                        $element.empty(), $element.append(clone)
                    })
                }
            }),
            scriptDirective = ["$templateCache",
                function ($templateCache) {
                    return {
                        restrict: "E",
                        terminal: !0,
                        compile: function (element, attr) {
                            if ("text/ng-template" == attr.type) {
                                var templateUrl = attr.id,
                                    text = element[0].text;
                                $templateCache.put(templateUrl, text)
                            }
                        }
                    }
                }
            ],
            ngOptionsMinErr = minErr("ngOptions"),
            ngOptionsDirective = valueFn({
                terminal: !0
            }),
            selectDirective = ["$compile", "$parse",
                function ($compile, $parse) {
                    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
                        nullModelCtrl = {
                            $setViewValue: noop
                        };
                    return {
                        restrict: "E",
                        require: ["select", "?ngModel"],
                        controller: ["$element", "$scope", "$attrs",
                            function ($element, $scope, $attrs) {
                                var nullOption, unknownOption, self = this,
                                    optionsMap = {},
                                    ngModelCtrl = nullModelCtrl;
                                self.databound = $attrs.ngModel, self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                                    ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_
                                }, self.addOption = function (value) {
                                    assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), unknownOption.parent() && unknownOption.remove())
                                }, self.removeOption = function (value) {
                                    this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value))
                                }, self.renderUnknownOption = function (val) {
                                    var unknownVal = "? " + hashKey(val) + " ?";
                                    unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), unknownOption.prop("selected", !0)
                                }, self.hasOption = function (value) {
                                    return optionsMap.hasOwnProperty(value)
                                }, $scope.$on("$destroy", function () {
                                    self.renderUnknownOption = noop
                                })
                            }
                        ],
                        link: function (scope, element, attr, ctrls) {
                            function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                                ngModelCtrl.$render = function () {
                                    var viewValue = ngModelCtrl.$viewValue;
                                    selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue)
                                }, selectElement.on("change", function () {
                                    scope.$apply(function () {
                                        unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val())
                                    })
                                })
                            }

                            function setupAsMultiple(scope, selectElement, ctrl) {
                                var lastView;
                                ctrl.$render = function () {
                                    var items = new HashMap(ctrl.$viewValue);
                                    forEach(selectElement.find("option"), function (option) {
                                        option.selected = isDefined(items.get(option.value))
                                    })
                                }, scope.$watch(function () {
                                    equals(lastView, ctrl.$viewValue) || (lastView = copy(ctrl.$viewValue), ctrl.$render())
                                }), selectElement.on("change", function () {
                                    scope.$apply(function () {
                                        var array = [];
                                        forEach(selectElement.find("option"), function (option) {
                                            option.selected && array.push(option.value)
                                        }), ctrl.$setViewValue(array)
                                    })
                                })
                            }

                            function setupAsOptions(scope, selectElement, ctrl) {
                                function render() {
                                    var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionGroups = {
                                            "": []
                                        },
                                        optionGroupNames = [""],
                                        modelValue = ctrl.$modelValue,
                                        values = valuesFn(scope) || [],
                                        keys = keyName ? sortedKeys(values) : values,
                                        locals = {},
                                        selectedSet = !1;
                                    if (multiple)
                                        if (trackFn && isArray(modelValue)) {
                                            selectedSet = new HashMap([]);
                                            for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) locals[valueName] = modelValue[trackIndex], selectedSet.put(trackFn(scope, locals), modelValue[trackIndex])
                                        } else selectedSet = new HashMap(modelValue);
                                    for (index = 0; length = keys.length, length > index; index++) {
                                        if (key = index, keyName) {
                                            if (key = keys[index], "$" === key.charAt(0)) continue;
                                            locals[keyName] = key
                                        }
                                        if (locals[valueName] = values[key], optionGroupName = groupByFn(scope, locals) || "", (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], optionGroupNames.push(optionGroupName)), multiple) selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)));
                                        else {
                                            if (trackFn) {
                                                var modelCast = {};
                                                modelCast[valueName] = modelValue, selected = trackFn(scope, modelCast) === trackFn(scope, locals)
                                            } else selected = modelValue === valueFn(scope, locals);
                                            selectedSet = selectedSet || selected
                                        }
                                        label = displayFn(scope, locals), label = isDefined(label) ? label : "", optionGroup.push({
                                            id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                            label: label,
                                            selected: selected
                                        })
                                    }
                                    for (multiple || (nullOption || null === modelValue ? optionGroups[""].unshift({
                                        id: "",
                                        label: "",
                                        selected: !selectedSet
                                    }) : selectedSet || optionGroups[""].unshift({
                                        id: "?",
                                        label: "",
                                        selected: !0
                                    })), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                                        for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], optionGroupsCache.length <= groupIndex ? (existingParent = {
                                            element: optGroupTemplate.clone().attr("label", optionGroupName),
                                            label: optionGroup.label
                                        }, existingOptions = [existingParent], optionGroupsCache.push(existingOptions), selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex], existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index], (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, existingOption.label !== option.label && lastElement.text(existingOption.label = option.label), existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), existingOption.selected !== option.selected && lastElement.prop("selected", existingOption.selected = option.selected)) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).attr("selected", option.selected).text(option.label), existingOptions.push(existingOption = {
                                            element: element,
                                            label: option.label,
                                            id: option.id,
                                            selected: option.selected
                                        }), lastElement ? lastElement.after(element) : existingParent.element.append(element), lastElement = element);
                                        for (index++; existingOptions.length > index;) existingOptions.pop().element.remove()
                                    }
                                    for (; optionGroupsCache.length > groupIndex;) optionGroupsCache.pop()[0].element.remove()
                                }
                                var match;
                                if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                                var displayFn = $parse(match[2] || match[1]),
                                    valueName = match[4] || match[6],
                                    keyName = match[5],
                                    groupByFn = $parse(match[3] || ""),
                                    valueFn = $parse(match[2] ? match[1] : valueName),
                                    valuesFn = $parse(match[7]),
                                    track = match[8],
                                    trackFn = track ? $parse(match[8]) : null,
                                    optionGroupsCache = [
                                        [{
                                            element: selectElement,
                                            label: ""
                                        }]
                                    ];
                                nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), nullOption.remove()), selectElement.empty(), selectElement.on("change", function () {
                                    scope.$apply(function () {
                                        var optionGroup, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex, collection = valuesFn(scope) || [],
                                            locals = {};
                                        if (multiple) {
                                            for (value = [], groupIndex = 0, groupLength = optionGroupsCache.length; groupLength > groupIndex; groupIndex++)
                                                for (optionGroup = optionGroupsCache[groupIndex], index = 1, length = optionGroup.length; length > index; index++)
                                                    if ((optionElement = optionGroup[index].element)[0].selected) {
                                                        if (key = optionElement.val(), keyName && (locals[keyName] = key), trackFn)
                                                            for (trackIndex = 0; trackIndex < collection.length && (locals[valueName] = collection[trackIndex], trackFn(scope, locals) != key); trackIndex++);
                                                        else locals[valueName] = collection[key];
                                                        value.push(valueFn(scope, locals))
                                                    }
                                        } else {
                                            if (key = selectElement.val(), "?" == key) value = undefined;
                                            else if ("" === key) value = null;
                                            else if (trackFn) {
                                                for (trackIndex = 0; trackIndex < collection.length; trackIndex++)
                                                    if (locals[valueName] = collection[trackIndex], trackFn(scope, locals) == key) {
                                                        value = valueFn(scope, locals);
                                                        break
                                                    }
                                            } else locals[valueName] = collection[key], keyName && (locals[keyName] = key), value = valueFn(scope, locals);
                                            optionGroupsCache[0].length > 1 && optionGroupsCache[0][1].id !== key && (optionGroupsCache[0][1].selected = !1)
                                        }
                                        ctrl.$setViewValue(value)
                                    })
                                }), ctrl.$render = render, scope.$watch(render)
                            }
                            if (ctrls[1]) {
                                for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++)
                                    if ("" === children[i].value) {
                                        emptyOption = nullOption = children.eq(i);
                                        break
                                    }
                                selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function (value) {
                                    return !value || 0 === value.length
                                }), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl)
                            }
                        }
                    }
                }
            ],
            optionDirective = ["$interpolate",
                function ($interpolate) {
                    var nullSelectCtrl = {
                        addOption: noop,
                        removeOption: noop
                    };
                    return {
                        restrict: "E",
                        priority: 100,
                        compile: function (element, attr) {
                            if (isUndefined(attr.value)) {
                                var interpolateFn = $interpolate(element.text(), !0);
                                interpolateFn || attr.$set("value", element.text())
                            }
                            return function (scope, element, attr) {
                                var selectCtrlName = "$selectController",
                                    parent = element.parent(),
                                    selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                                selectCtrl && selectCtrl.databound ? element.prop("selected", !1) : selectCtrl = nullSelectCtrl, interpolateFn ? scope.$watch(interpolateFn, function (newVal, oldVal) {
                                    attr.$set("value", newVal), newVal !== oldVal && selectCtrl.removeOption(oldVal), selectCtrl.addOption(newVal)
                                }) : selectCtrl.addOption(attr.value), element.on("$destroy", function () {
                                    selectCtrl.removeOption(attr.value)
                                })
                            }
                        }
                    }
                }
            ],
            styleDirective = valueFn({
                restrict: "E",
                terminal: !0
            });
        return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), publishExternalAPI(angular), void jqLite(document).ready(function () {
            angularInit(document, bootstrap)
        }))
    }(window, document), !angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}</style>'),
    function (window, angular) {
        "use strict";

        function $RouteProvider() {
            function inherit(parent, extra) {
                return angular.extend(new(angular.extend(function () {}, {
                    prototype: parent
                })), extra)
            }

            function pathRegExp(path, opts) {
                var insensitive = opts.caseInsensitiveMatch,
                    ret = {
                        originalPath: path,
                        regexp: path
                    },
                    keys = ret.keys = [];
                return path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)([\?\*])?/g, function (_, slash, key, option) {
                    var optional = "?" === option ? option : null,
                        star = "*" === option ? option : null;
                    return keys.push({
                        name: key,
                        optional: !!optional
                    }), slash = slash || "", "" + (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "")
                }).replace(/([\/$\*])/g, "\\$1"), ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : ""), ret
            }
            var routes = {};
            this.when = function (path, route) {
                if (routes[path] = angular.extend({
                    reloadOnSearch: !0
                }, route, path && pathRegExp(path, route)), path) {
                    var redirectPath = "/" == path[path.length - 1] ? path.substr(0, path.length - 1) : path + "/";
                    routes[redirectPath] = angular.extend({
                        redirectTo: path
                    }, pathRegExp(redirectPath, route))
                }
                return this
            }, this.otherwise = function (params) {
                return this.when(null, params), this
            }, this.$get = ["$rootScope", "$location", "$routeParams", "$q", "$injector", "$http", "$templateCache", "$sce",
                function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache, $sce) {
                    function switchRouteMatcher(on, route) {
                        var keys = route.keys,
                            params = {};
                        if (!route.regexp) return null;
                        var m = route.regexp.exec(on);
                        if (!m) return null;
                        for (var i = 1, len = m.length; len > i; ++i) {
                            var key = keys[i - 1],
                                val = "string" == typeof m[i] ? decodeURIComponent(m[i]) : m[i];
                            key && val && (params[key.name] = val)
                        }
                        return params
                    }

                    function updateRoute() {
                        var next = parseRoute(),
                            last = $route.current;
                        next && last && next.$$route === last.$$route && angular.equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload ? (last.params = next.params, angular.copy(last.params, $routeParams), $rootScope.$broadcast("$routeUpdate", last)) : (next || last) && (forceReload = !1, $rootScope.$broadcast("$routeChangeStart", next, last), $route.current = next, next && next.redirectTo && (angular.isString(next.redirectTo) ? $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace() : $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace()), $q.when(next).then(function () {
                            if (next) {
                                var template, templateUrl, locals = angular.extend({}, next.resolve);
                                return angular.forEach(locals, function (value, key) {
                                    locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value)
                                }), angular.isDefined(template = next.template) ? angular.isFunction(template) && (template = template(next.params)) : angular.isDefined(templateUrl = next.templateUrl) && (angular.isFunction(templateUrl) && (templateUrl = templateUrl(next.params)), templateUrl = $sce.getTrustedResourceUrl(templateUrl), angular.isDefined(templateUrl) && (next.loadedTemplateUrl = templateUrl, template = $http.get(templateUrl, {
                                    cache: $templateCache
                                }).then(function (response) {
                                    return response.data
                                }))), angular.isDefined(template) && (locals.$template = template), $q.all(locals)
                            }
                        }).then(function (locals) {
                            next == $route.current && (next && (next.locals = locals, angular.copy(next.params, $routeParams)), $rootScope.$broadcast("$routeChangeSuccess", next, last))
                        }, function (error) {
                            next == $route.current && $rootScope.$broadcast("$routeChangeError", next, last, error)
                        }))
                    }

                    function parseRoute() {
                        var params, match;
                        return angular.forEach(routes, function (route) {
                            !match && (params = switchRouteMatcher($location.path(), route)) && (match = inherit(route, {
                                params: angular.extend({}, $location.search(), params),
                                pathParams: params
                            }), match.$$route = route)
                        }), match || routes[null] && inherit(routes[null], {
                            params: {},
                            pathParams: {}
                        })
                    }

                    function interpolate(string, params) {
                        var result = [];
                        return angular.forEach((string || "").split(":"), function (segment, i) {
                            if (0 === i) result.push(segment);
                            else {
                                var segmentMatch = segment.match(/(\w+)(.*)/),
                                    key = segmentMatch[1];
                                result.push(params[key]), result.push(segmentMatch[2] || ""), delete params[key]
                            }
                        }), result.join("")
                    }
                    var forceReload = !1,
                        $route = {
                            routes: routes,
                            reload: function () {
                                forceReload = !0, $rootScope.$evalAsync(updateRoute)
                            }
                        };
                    return $rootScope.$on("$locationChangeSuccess", updateRoute), $route
                }
            ]
        }

        function $RouteParamsProvider() {
            this.$get = function () {
                return {}
            }
        }

        function ngViewFactory($route, $anchorScroll, $animate) {
            return {
                restrict: "ECA",
                terminal: !0,
                priority: 400,
                transclude: "element",
                link: function (scope, $element, attr, ctrl, $transclude) {
                    function cleanupLastView() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement, function () {
                            previousElement = null
                        }), previousElement = currentElement, currentElement = null)
                    }

                    function update() {
                        var locals = $route.current && $route.current.locals,
                            template = locals && locals.$template;
                        if (angular.isDefined(template)) {
                            var newScope = scope.$new(),
                                current = $route.current,
                                clone = $transclude(newScope, function (clone) {
                                    $animate.enter(clone, null, currentElement || $element, function () {
                                        !angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                                    }), cleanupLastView()
                                });
                            currentElement = clone, currentScope = current.scope = newScope, currentScope.$emit("$viewContentLoaded"), currentScope.$eval(onloadExp)
                        } else cleanupLastView()
                    }
                    var currentScope, currentElement, previousElement, autoScrollExp = attr.autoscroll,
                        onloadExp = attr.onload || "";
                    scope.$on("$routeChangeSuccess", update), update()
                }
            }
        }

        function ngViewFillContentFactory($compile, $controller, $route) {
            return {
                restrict: "ECA",
                priority: -400,
                link: function (scope, $element) {
                    var current = $route.current,
                        locals = current.locals;
                    $element.html(locals.$template);
                    var link = $compile($element.contents());
                    if (current.controller) {
                        locals.$scope = scope;
                        var controller = $controller(current.controller, locals);
                        current.controllerAs && (scope[current.controllerAs] = controller), $element.data("$ngControllerController", controller), $element.children().data("$ngControllerController", controller)
                    }
                    link(scope)
                }
            }
        }
        var ngRouteModule = angular.module("ngRoute", ["ng"]).provider("$route", $RouteProvider);
        ngRouteModule.provider("$routeParams", $RouteParamsProvider), ngRouteModule.directive("ngView", ngViewFactory), ngRouteModule.directive("ngView", ngViewFillContentFactory), ngViewFactory.$inject = ["$route", "$anchorScroll", "$animate"], ngViewFillContentFactory.$inject = ["$compile", "$controller", "$route"]
    }(window, window.angular); /*!*/

/* ********************************************************************************************************************** */
/* ********************************************************************************************************************** */
/* ********************************************************************************************************************** */

var paper = new function (undefined) {
    var Base = new function () {
        function inject(dest, src, enumerable, beans, preserve) {
            function field(name, val) {
                val = val || (val = describe(src, name)) && (val.get ? val : val.value), "string" == typeof val && "#" === val[0] && (val = dest[val.substring(1)] || val);
                var bean, isFunc = "function" == typeof val,
                    res = val,
                    prev = preserve || isFunc ? val && val.get ? name in dest : dest[name] : null;
                preserve && prev || (isFunc && prev && (val.base = prev), isFunc && beans !== !1 && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)) && (beansNames[bean[3].toLowerCase() + bean[4]] = bean[2]), res && !isFunc && res.get && "function" == typeof res.get && Base.isPlainObject(res) || (res = {
                    value: res,
                    writable: !0
                }), (describe(dest, name) || {
                    configurable: !0
                }).configurable && (res.configurable = !0, res.enumerable = enumerable), define(dest, name, res))
            }
            var beansNames = {};
            if (src) {
                for (var name in src) src.hasOwnProperty(name) && !hidden.test(name) && field(name);
                for (var name in beansNames) {
                    var part = beansNames[name],
                        set = dest["set" + part],
                        get = dest["get" + part] || set && dest["is" + part];
                    !get || beans !== !0 && 0 !== get.length || field(name, {
                        get: get,
                        set: set
                    })
                }
            }
            return dest
        }

        function each(obj, iter, bind) {
            return obj && ("length" in obj && !obj.getLength && "number" == typeof obj.length ? forEach : forIn).call(obj, iter, bind = bind || obj), bind
        }

        function set(obj, props) {
            for (var i in props) props.hasOwnProperty(i) && (obj[i] = props[i]);
            return obj
        }
        var hidden = /^(statics|enumerable|beans|preserve)$/,
            forEach = [].forEach || function (iter, bind) {
                for (var i = 0, l = this.length; l > i; i++) iter.call(bind, this[i], i, this)
            },
            forIn = function (iter, bind) {
                for (var i in this) this.hasOwnProperty(i) && iter.call(bind, this[i], i, this)
            },
            create = Object.create || function (proto) {
                return {
                    __proto__: proto
                }
            },
            describe = Object.getOwnPropertyDescriptor || function (obj, name) {
                var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
                return get ? {
                    get: get,
                    set: obj.__lookupSetter__(name),
                    enumerable: !0,
                    configurable: !0
                } : obj.hasOwnProperty(name) ? {
                    value: obj[name],
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                } : null
            },
            _define = Object.defineProperty || function (obj, name, desc) {
                return (desc.get || desc.set) && obj.__defineGetter__ ? (desc.get && obj.__defineGetter__(name, desc.get), desc.set && obj.__defineSetter__(name, desc.set)) : obj[name] = desc.value, obj
            },
            define = function (obj, name, desc) {
                return delete obj[name], _define(obj, name, desc)
            };
        return inject(function () {
            for (var i = 0, l = arguments.length; l > i; i++) set(this, arguments[i])
        }, {
            inject: function (src) {
                if (src) {
                    var statics = src.statics === !0 ? src : src.statics,
                        beans = src.beans,
                        preserve = src.preserve;
                    statics !== src && inject(this.prototype, src, src.enumerable, beans, preserve), inject(this, statics, !0, beans, preserve)
                }
                for (var i = 1, l = arguments.length; l > i; i++) this.inject(arguments[i]);
                return this
            },
            extend: function () {
                for (var ctor, base = this, i = 0, l = arguments.length; l > i && !(ctor = arguments[i].initialize); i++);
                return ctor = ctor || function () {
                    base.apply(this, arguments)
                }, ctor.prototype = create(this.prototype), ctor.base = base, define(ctor.prototype, "constructor", {
                    value: ctor,
                    writable: !0,
                    configurable: !0
                }), inject(ctor, this, !0), arguments.length ? this.inject.apply(ctor, arguments) : ctor
            }
        }, !0).inject({
            inject: function () {
                for (var i = 0, l = arguments.length; l > i; i++) {
                    var src = arguments[i];
                    src && inject(this, src, src.enumerable, src.beans, src.preserve)
                }
                return this
            },
            extend: function () {
                var res = create(this);
                return res.inject.apply(res, arguments)
            },
            each: function (iter, bind) {
                return each(this, iter, bind)
            },
            clone: function () {
                return new this.constructor(this)
            },
            statics: {
                each: each,
                create: create,
                define: define,
                describe: describe,
                set: set,
                clone: function (obj) {
                    return set(new obj.constructor, obj)
                },
                isPlainObject: function (obj) {
                    var ctor = null != obj && obj.constructor;
                    return ctor && (ctor === Object || ctor === Base || "Object" === ctor.name)
                },
                pick: function () {
                    for (var i = 0, l = arguments.length; l > i; i++)
                        if (arguments[i] !== undefined) return arguments[i]
                }
            }
        })
    };
    "undefined" != typeof module && (module.exports = Base), Array.isArray || (Array.isArray = function (obj) {
        return "[object Array]" === Object.prototype.toString.call(obj)
    }), document.head || (document.head = document.getElementsByTagName("head")[0]), Base.inject({
        toString: function () {
            return null != this._id ? (this._class || "Object") + (this._name ? " '" + this._name + "'" : " @" + this._id) : "{ " + Base.each(this, function (value, key) {
                if (!/^_/.test(key)) {
                    var type = typeof value;
                    this.push(key + ": " + ("number" === type ? Formatter.instance.number(value) : "string" === type ? "'" + value + "'" : value))
                }
            }, []).join(", ") + " }"
        },
        exportJSON: function (options) {
            return Base.exportJSON(this, options)
        },
        toJSON: function () {
            return Base.serialize(this)
        },
        _set: function (props, exclude) {
            if (props && Base.isPlainObject(props)) {
                var orig = props._filtering || props;
                for (var key in orig)
                    if (key in this && orig.hasOwnProperty(key) && (!exclude || !exclude[key])) {
                        var value = props[key];
                        value !== undefined && (this[key] = value)
                    }
                return !0
            }
        },
        statics: {
            exports: {
                enumerable: !0
            },
            extend: function extend() {
                var res = extend.base.apply(this, arguments),
                    name = res.prototype._class;
                return name && !Base.exports[name] && (Base.exports[name] = res), res
            },
            equals: function (obj1, obj2) {
                function checkKeys(o1, o2) {
                    for (var i in o1)
                        if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i)) return !1;
                    return !0
                }
                if (obj1 === obj2) return !0;
                if (obj1 && obj1.equals) return obj1.equals(obj2);
                if (obj2 && obj2.equals) return obj2.equals(obj1);
                if (Array.isArray(obj1) && Array.isArray(obj2)) {
                    if (obj1.length !== obj2.length) return !1;
                    for (var i = 0, l = obj1.length; l > i; i++)
                        if (!Base.equals(obj1[i], obj2[i])) return !1;
                    return !0
                }
                if (obj1 && "object" == typeof obj1 && obj2 && "object" == typeof obj2) {
                    if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1)) return !1;
                    for (var i in obj1)
                        if (obj1.hasOwnProperty(i) && !Base.equals(obj1[i], obj2[i])) return !1;
                    return !0
                }
                return !1
            },
            read: function (list, start, options, length) {
                if (this === Base) {
                    var value = this.peek(list, start);
                    return list.__index++, value
                }
                var proto = this.prototype,
                    readIndex = proto._readIndex,
                    index = start || readIndex && list.__index || 0;
                length || (length = list.length - index);
                var obj = list[index];
                return obj instanceof this || options && options.readNull && null == obj && 1 >= length ? (readIndex && (list.__index = index + 1), obj && options && options.clone ? obj.clone() : obj) : (obj = Base.create(this.prototype), readIndex && (obj.__read = !0), obj = obj.initialize.apply(obj, index > 0 || length < list.length ? Array.prototype.slice.call(list, index, index + length) : list) || obj, readIndex && (list.__index = index + obj.__read, obj.__read = undefined), obj)
            },
            peek: function (list, start) {
                return list[list.__index = start || list.__index || 0]
            },
            remain: function (list) {
                return list.length - (list.__index || 0)
            },
            readAll: function (list, start, options) {
                for (var entry, res = [], i = start || 0, l = list.length; l > i; i++) res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
                return res
            },
            readNamed: function (list, name, start, options, length) {
                var value = this.getNamed(list, name),
                    hasObject = value !== undefined;
                if (hasObject) {
                    var filtered = list._filtered;
                    filtered || (filtered = list._filtered = Base.create(list[0]), filtered._filtering = list[0]), filtered[name] = undefined
                }
                return this.read(hasObject ? [value] : list, start, options, length)
            },
            getNamed: function (list, name) {
                var arg = list[0];
                return list._hasObject === undefined && (list._hasObject = 1 === list.length && Base.isPlainObject(arg)), list._hasObject ? name ? arg[name] : list._filtered || arg : void 0
            },
            hasNamed: function (list, name) {
                return !!this.getNamed(list, name)
            },
            isPlainValue: function (obj) {
                return this.isPlainObject(obj) || Array.isArray(obj)
            },
            serialize: function (obj, options, compact, dictionary) {
                options = options || {};
                var res, root = !dictionary;
                if (root && (options.formatter = new Formatter(options.precision), dictionary = {
                    length: 0,
                    definitions: {},
                    references: {},
                    add: function (item, create) {
                        var id = "#" + item._id,
                            ref = this.references[id];
                        if (!ref) {
                            this.length++;
                            var res = create.call(item),
                                name = item._class;
                            name && res[0] !== name && res.unshift(name), this.definitions[id] = res, ref = this.references[id] = [id]
                        }
                        return ref
                    }
                }), obj && obj._serialize) {
                    res = obj._serialize(options, dictionary);
                    var name = obj._class;
                    !name || compact || res._compact || res[0] === name || res.unshift(name)
                } else if (Array.isArray(obj)) {
                    res = [];
                    for (var i = 0, l = obj.length; l > i; i++) res[i] = Base.serialize(obj[i], options, compact, dictionary);
                    compact && (res._compact = !0)
                } else if (Base.isPlainObject(obj)) {
                    res = {};
                    for (var i in obj) obj.hasOwnProperty(i) && (res[i] = Base.serialize(obj[i], options, compact, dictionary))
                } else res = "number" == typeof obj ? options.formatter.number(obj, options.precision) : obj;
                return root && dictionary.length > 0 ? [
                    ["dictionary", dictionary.definitions], res
                ] : res
            },
            deserialize: function (json, create, _data) {
                var res = json,
                    isRoot = !_data;
                if (_data = _data || {}, Array.isArray(json)) {
                    var type = json[0],
                        isDictionary = "dictionary" === type;
                    if (!isDictionary) {
                        if (_data.dictionary && 1 == json.length && /^#/.test(type)) return _data.dictionary[type];
                        type = Base.exports[type]
                    }
                    res = [];
                    for (var i = type ? 1 : 0, l = json.length; l > i; i++) res.push(Base.deserialize(json[i], create, _data));
                    if (isDictionary) _data.dictionary = res[0];
                    else if (type) {
                        var args = res;
                        create ? res = create(type, args, isRoot) : (res = Base.create(type.prototype), type.apply(res, args))
                    }
                } else if (Base.isPlainObject(json)) {
                    res = {};
                    for (var key in json) res[key] = Base.deserialize(json[key], create, _data)
                }
                return res
            },
            exportJSON: function (obj, options) {
                var json = Base.serialize(obj, options);
                return options && options.asString === !1 ? json : JSON.stringify(json)
            },
            importJSON: function (json, target) {
                return Base.deserialize("string" == typeof json ? JSON.parse(json) : json, function (type, args, isRoot) {
                    var obj = target && target.constructor === type ? target : Base.create(type.prototype),
                        isTarget = obj === target;
                    if (!isRoot && 1 === args.length && obj instanceof Item && (!(obj instanceof Layer) || isTarget)) {
                        var arg = args[0];
                        Base.isPlainObject(arg) && (arg.insert = !1)
                    }
                    return type.apply(obj, args), isTarget && (target = null), obj
                })
            },
            splice: function (list, items, index, remove) {
                var amount = items && items.length,
                    append = index === undefined;
                index = append ? list.length : index, index > list.length && (index = list.length);
                for (var i = 0; amount > i; i++) items[i]._index = index + i;
                if (append) return list.push.apply(list, items), [];
                var args = [index, remove];
                items && args.push.apply(args, items);
                for (var removed = list.splice.apply(list, args), i = 0, l = removed.length; l > i; i++) removed[i]._index = undefined;
                for (var i = index + amount, l = list.length; l > i; i++) list[i]._index = i;
                return removed
            },
            capitalize: function (str) {
                return str.replace(/\b[a-z]/g, function (match) {
                    return match.toUpperCase()
                })
            },
            camelize: function (str) {
                return str.replace(/-(.)/g, function (all, chr) {
                    return chr.toUpperCase()
                })
            },
            hyphenate: function (str) {
                return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
            }
        }
    });
    var Callback = {
            attach: function (type, func) {
                if ("string" != typeof type) return void Base.each(type, function (value, key) {
                    this.attach(key, value)
                }, this);
                var entry = this._eventTypes[type];
                if (entry) {
                    var handlers = this._handlers = this._handlers || {};
                    handlers = handlers[type] = handlers[type] || [], -1 == handlers.indexOf(func) && (handlers.push(func), entry.install && 1 == handlers.length && entry.install.call(this, type))
                }
            },
            detach: function (type, func) {
                if ("string" != typeof type) return void Base.each(type, function (value, key) {
                    this.detach(key, value)
                }, this);
                var index, entry = this._eventTypes[type],
                    handlers = this._handlers && this._handlers[type];
                entry && handlers && (!func || -1 != (index = handlers.indexOf(func)) && 1 == handlers.length ? (entry.uninstall && entry.uninstall.call(this, type), delete this._handlers[type]) : -1 != index && handlers.splice(index, 1))
            },
            once: function (type, func) {
                this.attach(type, function () {
                    func.apply(this, arguments), this.detach(type, func)
                })
            },
            fire: function (type, event) {
                var handlers = this._handlers && this._handlers[type];
                if (!handlers) return !1;
                for (var args = [].slice.call(arguments, 1), that = this, i = 0, l = handlers.length; l > i; i++)
                    if (handlers[i].apply(that, args) === !1 && event && event.stop) {
                        event.stop();
                        break
                    }
                return !0
            },
            responds: function (type) {
                return !(!this._handlers || !this._handlers[type])
            },
            on: "#attach",
            off: "#detach",
            trigger: "#fire",
            _installEvents: function (install) {
                var handlers = this._handlers,
                    key = install ? "install" : "uninstall";
                for (var type in handlers)
                    if (handlers[type].length > 0) {
                        var entry = this._eventTypes[type],
                            func = entry[key];
                        func && func.call(this, type)
                    }
            },
            statics: {
                inject: function inject() {
                    for (var i = 0, l = arguments.length; l > i; i++) {
                        var src = arguments[i],
                            events = src._events;
                        if (events) {
                            var types = {};
                            Base.each(events, function (entry, key) {
                                var isString = "string" == typeof entry,
                                    name = isString ? entry : key,
                                    part = Base.capitalize(name),
                                    type = name.substring(2).toLowerCase();
                                types[type] = isString ? {} : entry, name = "_" + name, src["get" + part] = function () {
                                    return this[name]
                                }, src["set" + part] = function (func) {
                                    var prev = this[name];
                                    prev && this.detach(type, prev), func && this.attach(type, func), this[name] = func
                                }
                            }), src._eventTypes = types
                        }
                        inject.base.call(this, src)
                    }
                    return this
                }
            }
        },
        PaperScope = Base.extend({
            _class: "PaperScope",
            initialize: function PaperScope(script) {
                if (paper = this, this.settings = {
                    applyMatrix: !0,
                    handleSize: 4,
                    hitTolerance: 0
                }, this.project = null, this.projects = [], this.tools = [], this.palettes = [], this._id = script && (script.getAttribute("id") || script.src) || "paperscope-" + PaperScope._id++, script && script.setAttribute("id", this._id), PaperScope._scopes[this._id] = this, !this.support) {
                    var ctx = CanvasProvider.getContext(1, 1);
                    PaperScope.prototype.support = {
                        nativeDash: "setLineDash" in ctx || "mozDash" in ctx,
                        nativeBlendModes: BlendMode.nativeModes
                    }, CanvasProvider.release(ctx)
                }
            },
            version: "0.9.18",
            getView: function () {
                return this.project && this.project.getView()
            },
            getPaper: function () {
                return this
            },
            execute: function (code) {
                paper.PaperScript.execute(code, this), View.updateFocus()
            },
            install: function (scope) {
                var that = this;
                Base.each(["project", "view", "tool"], function (key) {
                    Base.define(scope, key, {
                        configurable: !0,
                        get: function () {
                            return that[key]
                        }
                    })
                });
                for (var key in this)!/^_/.test(key) && this[key] && (scope[key] = this[key])
            },
            setup: function (canvas) {
                return paper = this, this.project = new Project(canvas), this
            },
            activate: function () {
                paper = this
            },
            clear: function () {
                for (var i = this.projects.length - 1; i >= 0; i--) this.projects[i].remove();
                for (var i = this.tools.length - 1; i >= 0; i--) this.tools[i].remove();
                for (var i = this.palettes.length - 1; i >= 0; i--) this.palettes[i].remove()
            },
            remove: function () {
                this.clear(), delete PaperScope._scopes[this._id]
            },
            statics: new function () {
                function handleAttribute(name) {
                    return name += "Attribute",
                        function (el, attr) {
                            return el[name](attr) || el[name]("data-paper-" + attr)
                        }
                }
                return {
                    _scopes: {},
                    _id: 0,
                    get: function (id) {
                        return id && id.getAttribute && (id = id.getAttribute("id")), this._scopes[id] || null
                    },
                    getAttribute: handleAttribute("get"),
                    hasAttribute: handleAttribute("has")
                }
            }
        }),
        PaperScopeItem = Base.extend(Callback, {
            initialize: function (activate) {
                this._scope = paper, this._index = this._scope[this._list].push(this) - 1, (activate || !this._scope[this._reference]) && this.activate()
            },
            activate: function () {
                if (!this._scope) return !1;
                var prev = this._scope[this._reference];
                return prev && prev !== this && prev.fire("deactivate"), this._scope[this._reference] = this, this.fire("activate", prev), !0
            },
            isActive: function () {
                return this._scope[this._reference] === this
            },
            remove: function () {
                return null == this._index ? !1 : (Base.splice(this._scope[this._list], null, this._index, 1), this._scope[this._reference] == this && (this._scope[this._reference] = null), this._scope = null, !0)
            }
        }),
        Formatter = Base.extend({
            initialize: function (precision) {
                this.precision = precision || 5, this.multiplier = Math.pow(10, this.precision)
            },
            number: function (val) {
                return Math.round(val * this.multiplier) / this.multiplier
            },
            point: function (val, separator) {
                return this.number(val.x) + (separator || ",") + this.number(val.y)
            },
            size: function (val, separator) {
                return this.number(val.width) + (separator || ",") + this.number(val.height)
            },
            rectangle: function (val, separator) {
                return this.point(val, separator) + (separator || ",") + this.size(val, separator)
            }
        });
    Formatter.instance = new Formatter;
    var Numerical = new function () {
            function setupRoots(roots, min, max) {
                var unbound = min === undefined,
                    minE = min - EPSILON,
                    maxE = max + EPSILON,
                    count = 0;
                return function (root) {
                    return (unbound || root > minE && maxE > root) && (roots[count++] = min > root ? min : root > max ? max : root), count
                }
            }
            var abscissas = [
                    [.5773502691896257],
                    [0, .7745966692414834],
                    [.33998104358485626, .8611363115940526],
                    [0, .5384693101056831, .906179845938664],
                    [.2386191860831969, .6612093864662645, .932469514203152],
                    [0, .4058451513773972, .7415311855993945, .9491079123427585],
                    [.1834346424956498, .525532409916329, .7966664774136267, .9602898564975363],
                    [0, .3242534234038089, .6133714327005904, .8360311073266358, .9681602395076261],
                    [.14887433898163122, .4333953941292472, .6794095682990244, .8650633666889845, .9739065285171717],
                    [0, .26954315595234496, .5190961292068118, .7301520055740494, .8870625997680953, .978228658146057],
                    [.1252334085114689, .3678314989981802, .5873179542866175, .7699026741943047, .9041172563704749, .9815606342467192],
                    [0, .2304583159551348, .44849275103644687, .6423493394403402, .8015780907333099, .9175983992229779, .9841830547185881],
                    [.10805494870734367, .31911236892788974, .5152486363581541, .6872929048116855, .827201315069765, .9284348836635735, .9862838086968123],
                    [0, .20119409399743451, .3941513470775634, .5709721726085388, .7244177313601701, .8482065834104272, .937273392400706, .9879925180204854],
                    [.09501250983763744, .2816035507792589, .45801677765722737, .6178762444026438, .755404408355003, .8656312023878318, .9445750230732326, .9894009349916499]
                ],
                weights = [
                    [1],
                    [.8888888888888888, .5555555555555556],
                    [.6521451548625461, .34785484513745385],
                    [.5688888888888889, .47862867049936647, .23692688505618908],
                    [.46791393457269104, .3607615730481386, .17132449237917036],
                    [.4179591836734694, .3818300505051189, .27970539148927664, .1294849661688697],
                    [.362683783378362, .31370664587788727, .22238103445337448, .10122853629037626],
                    [.3302393550012598, .31234707704000286, .26061069640293544, .1806481606948574, .08127438836157441],
                    [.29552422471475287, .26926671930999635, .21908636251598204, .1494513491505806, .06667134430868814],
                    [.2729250867779006, .26280454451024665, .23319376459199048, .18629021092773426, .1255803694649046, .05566856711617366],
                    [.24914704581340277, .2334925365383548, .20316742672306592, .16007832854334622, .10693932599531843, .04717533638651183],
                    [.2325515532308739, .22628318026289723, .2078160475368885, .17814598076194574, .13887351021978725, .09212149983772845, .04048400476531588],
                    [.2152638534631578, .2051984637212956, .18553839747793782, .15720316715819355, .12151857068790319, .08015808715976021, .03511946033175186],
                    [.2025782419255613, .19843148532711158, .1861610000155622, .16626920581699392, .13957067792615432, .10715922046717194, .07036604748810812, .03075324199611727],
                    [.1894506104550685, .18260341504492358, .16915651939500254, .14959598881657674, .12462897125553388, .09515851168249279, .062253523938647894, .027152459411754096]
                ],
                abs = Math.abs,
                sqrt = Math.sqrt,
                pow = Math.pow,
                cos = Math.cos,
                PI = Math.PI,
                TOLERANCE = 1e-5,
                EPSILON = 1e-11;
            return {
                TOLERANCE: TOLERANCE,
                EPSILON: EPSILON,
                KAPPA: 4 * (sqrt(2) - 1) / 3,
                isZero: function (val) {
                    return abs(val) <= EPSILON
                },
                integrate: function (f, a, b, n) {
                    for (var x = abscissas[n - 2], w = weights[n - 2], A = .5 * (b - a), B = A + a, i = 0, m = n + 1 >> 1, sum = 1 & n ? w[i++] * f(B) : 0; m > i;) {
                        var Ax = A * x[i];
                        sum += w[i++] * (f(B + Ax) + f(B - Ax))
                    }
                    return A * sum
                },
                findRoot: function (f, df, x, a, b, n, tolerance) {
                    for (var i = 0; n > i; i++) {
                        var fx = f(x),
                            dx = fx / df(x),
                            nx = x - dx;
                        if (abs(dx) < tolerance) return nx;
                        fx > 0 ? (b = x, x = a >= nx ? .5 * (a + b) : nx) : (a = x, x = nx >= b ? .5 * (a + b) : nx)
                    }
                    return x
                },
                solveQuadratic: function (a, b, c, roots, min, max) {
                    var add = setupRoots(roots, min, max);
                    if (abs(a) < EPSILON) return abs(b) >= EPSILON ? add(-c / b) : abs(c) < EPSILON ? -1 : 0;
                    var p = b / (2 * a),
                        q = c / a,
                        p2 = p * p;
                    if (q - EPSILON > p2) return 0;
                    var s = p2 > q ? sqrt(p2 - q) : 0,
                        count = add(s - p);
                    return s > 0 && (count = add(-s - p)), count
                },
                solveCubic: function (a, b, c, d, roots, min, max) {
                    if (abs(a) < EPSILON) return Numerical.solveQuadratic(b, c, d, roots, min, max);
                    b /= a, c /= a, d /= a;
                    var add = setupRoots(roots, min, max),
                        bb = b * b,
                        p = (bb - 3 * c) / 9,
                        q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
                        ppp = p * p * p,
                        D = q * q - ppp;
                    if (b /= 3, abs(D) < EPSILON) {
                        if (abs(q) < EPSILON) return add(-b);
                        var sqp = sqrt(p),
                            snq = q > 0 ? 1 : -1;
                        return add(2 * -snq * sqp - b), add(snq * sqp - b)
                    }
                    if (0 > D) {
                        var sqp = sqrt(p),
                            phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
                            t = -2 * sqp,
                            o = 2 * PI / 3;
                        return add(t * cos(phi) - b), add(t * cos(phi + o) - b), add(t * cos(phi - o) - b)
                    }
                    var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
                    return add(A + p / A - b)
                }
            }
        },
        Point = Base.extend({
            _class: "Point",
            _readIndex: !0,
            initialize: function (arg0, arg1) {
                var type = typeof arg0;
                if ("number" === type) {
                    var hasY = "number" == typeof arg1;
                    this.x = arg0, this.y = hasY ? arg1 : arg0, this.__read && (this.__read = hasY ? 2 : 1)
                } else "undefined" === type || null === arg0 ? (this.x = this.y = 0, this.__read && (this.__read = null === arg0 ? 1 : 0)) : (Array.isArray(arg0) ? (this.x = arg0[0], this.y = arg0.length > 1 ? arg0[1] : arg0[0]) : null != arg0.x ? (this.x = arg0.x, this.y = arg0.y) : null != arg0.width ? (this.x = arg0.width, this.y = arg0.height) : null != arg0.angle ? (this.x = arg0.length, this.y = 0, this.setAngle(arg0.angle)) : (this.x = this.y = 0, this.__read && (this.__read = 0)), this.__read && (this.__read = 1))
            },
            set: function (x, y) {
                return this.x = x, this.y = y, this
            },
            equals: function (point) {
                return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || !1
            },
            clone: function () {
                return new Point(this.x, this.y)
            },
            toString: function () {
                var f = Formatter.instance;
                return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + " }"
            },
            _serialize: function (options) {
                var f = options.formatter;
                return [f.number(this.x), f.number(this.y)]
            },
            getLength: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            setLength: function (length) {
                if (this.isZero()) {
                    var angle = this._angle || 0;
                    this.set(Math.cos(angle) * length, Math.sin(angle) * length)
                } else {
                    var scale = length / this.getLength();
                    Numerical.isZero(scale) && this.getAngle(), this.set(this.x * scale, this.y * scale)
                }
            },
            getAngle: function () {
                return 180 * this.getAngleInRadians.apply(this, arguments) / Math.PI
            },
            setAngle: function (angle) {
                this.setAngleInRadians.call(this, angle * Math.PI / 180)
            },
            getAngleInDegrees: "#getAngle",
            setAngleInDegrees: "#setAngle",
            getAngleInRadians: function () {
                if (arguments.length) {
                    var point = Point.read(arguments),
                        div = this.getLength() * point.getLength();
                    return Numerical.isZero(div) ? 0 / 0 : Math.acos(this.dot(point) / div)
                }
                return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x)
            },
            setAngleInRadians: function (angle) {
                if (this._angle = angle, !this.isZero()) {
                    var length = this.getLength();
                    this.set(Math.cos(angle) * length, Math.sin(angle) * length)
                }
            },
            getQuadrant: function () {
                return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3
            }
        }, {
            beans: !1,
            getDirectedAngle: function () {
                var point = Point.read(arguments);
                return 180 * Math.atan2(this.cross(point), this.dot(point)) / Math.PI
            },
            getDistance: function () {
                var point = Point.read(arguments),
                    x = point.x - this.x,
                    y = point.y - this.y,
                    d = x * x + y * y,
                    squared = Base.read(arguments);
                return squared ? d : Math.sqrt(d)
            },
            normalize: function (length) {
                length === undefined && (length = 1);
                var current = this.getLength(),
                    scale = 0 !== current ? length / current : 0,
                    point = new Point(this.x * scale, this.y * scale);
                return scale >= 0 && (point._angle = this._angle), point
            },
            rotate: function (angle, center) {
                if (0 === angle) return this.clone();
                angle = angle * Math.PI / 180;
                var point = center ? this.subtract(center) : this,
                    s = Math.sin(angle),
                    c = Math.cos(angle);
                return point = new Point(point.x * c - point.y * s, point.x * s + point.y * c), center ? point.add(center) : point
            },
            transform: function (matrix) {
                return matrix ? matrix._transformPoint(this) : this
            },
            add: function () {
                var point = Point.read(arguments);
                return new Point(this.x + point.x, this.y + point.y)
            },
            subtract: function () {
                var point = Point.read(arguments);
                return new Point(this.x - point.x, this.y - point.y)
            },
            multiply: function () {
                var point = Point.read(arguments);
                return new Point(this.x * point.x, this.y * point.y)
            },
            divide: function () {
                var point = Point.read(arguments);
                return new Point(this.x / point.x, this.y / point.y)
            },
            modulo: function () {
                var point = Point.read(arguments);
                return new Point(this.x % point.x, this.y % point.y)
            },
            negate: function () {
                return new Point(-this.x, -this.y)
            },
            isInside: function (rect) {
                return rect.contains(this)
            },
            isClose: function (point, tolerance) {
                return this.getDistance(point) < tolerance
            },
            isColinear: function (point) {
                return Math.abs(this.cross(point)) < 1e-5
            },
            isOrthogonal: function (point) {
                return Math.abs(this.dot(point)) < 1e-5
            },
            isZero: function () {
                return Numerical.isZero(this.x) && Numerical.isZero(this.y)
            },
            isNaN: function () {
                return isNaN(this.x) || isNaN(this.y)
            },
            dot: function () {
                var point = Point.read(arguments);
                return this.x * point.x + this.y * point.y
            },
            cross: function () {
                var point = Point.read(arguments);
                return this.x * point.y - this.y * point.x
            },
            project: function () {
                var point = Point.read(arguments);
                if (point.isZero()) return new Point(0, 0);
                var scale = this.dot(point) / point.dot(point);
                return new Point(point.x * scale, point.y * scale)
            },
            statics: {
                min: function () {
                    var point1 = Point.read(arguments),
                        point2 = Point.read(arguments);
                    return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y))
                },
                max: function () {
                    var point1 = Point.read(arguments),
                        point2 = Point.read(arguments);
                    return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y))
                },
                random: function () {
                    return new Point(Math.random(), Math.random())
                }
            }
        }, Base.each(["round", "ceil", "floor", "abs"], function (name) {
            var op = Math[name];
            this[name] = function () {
                return new Point(op(this.x), op(this.y))
            }
        }, {})),
        LinkedPoint = Point.extend({
            initialize: function (x, y, owner, setter) {
                this._x = x, this._y = y, this._owner = owner, this._setter = setter
            },
            set: function (x, y, _dontNotify) {
                return this._x = x, this._y = y, _dontNotify || this._owner[this._setter](this), this
            },
            getX: function () {
                return this._x
            },
            setX: function (x) {
                this._x = x, this._owner[this._setter](this)
            },
            getY: function () {
                return this._y
            },
            setY: function (y) {
                this._y = y, this._owner[this._setter](this)
            }
        }),
        Size = Base.extend({
            _class: "Size",
            _readIndex: !0,
            initialize: function (arg0, arg1) {
                var type = typeof arg0;
                if ("number" === type) {
                    var hasHeight = "number" == typeof arg1;
                    this.width = arg0, this.height = hasHeight ? arg1 : arg0, this.__read && (this.__read = hasHeight ? 2 : 1)
                } else "undefined" === type || null === arg0 ? (this.width = this.height = 0, this.__read && (this.__read = null === arg0 ? 1 : 0)) : (Array.isArray(arg0) ? (this.width = arg0[0], this.height = arg0.length > 1 ? arg0[1] : arg0[0]) : null != arg0.width ? (this.width = arg0.width, this.height = arg0.height) : null != arg0.x ? (this.width = arg0.x, this.height = arg0.y) : (this.width = this.height = 0, this.__read && (this.__read = 0)), this.__read && (this.__read = 1))
            },
            set: function (width, height) {
                return this.width = width, this.height = height, this
            },
            equals: function (size) {
                return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || !1
            },
            clone: function () {
                return new Size(this.width, this.height)
            },
            toString: function () {
                var f = Formatter.instance;
                return "{ width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }"
            },
            _serialize: function (options) {
                var f = options.formatter;
                return [f.number(this.width), f.number(this.height)]
            },
            add: function () {
                var size = Size.read(arguments);
                return new Size(this.width + size.width, this.height + size.height)
            },
            subtract: function () {
                var size = Size.read(arguments);
                return new Size(this.width - size.width, this.height - size.height)
            },
            multiply: function () {
                var size = Size.read(arguments);
                return new Size(this.width * size.width, this.height * size.height)
            },
            divide: function () {
                var size = Size.read(arguments);
                return new Size(this.width / size.width, this.height / size.height)
            },
            modulo: function () {
                var size = Size.read(arguments);
                return new Size(this.width % size.width, this.height % size.height)
            },
            negate: function () {
                return new Size(-this.width, -this.height)
            },
            isZero: function () {
                return Numerical.isZero(this.width) && Numerical.isZero(this.height)
            },
            isNaN: function () {
                return isNaN(this.width) || isNaN(this.height)
            },
            statics: {
                min: function (size1, size2) {
                    return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height))
                },
                max: function (size1, size2) {
                    return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height))
                },
                random: function () {
                    return new Size(Math.random(), Math.random())
                }
            }
        }, Base.each(["round", "ceil", "floor", "abs"], function (name) {
            var op = Math[name];
            this[name] = function () {
                return new Size(op(this.width), op(this.height))
            }
        }, {})),
        LinkedSize = Size.extend({
            initialize: function (width, height, owner, setter) {
                this._width = width, this._height = height, this._owner = owner, this._setter = setter
            },
            set: function (width, height, _dontNotify) {
                return this._width = width, this._height = height, _dontNotify || this._owner[this._setter](this), this
            },
            getWidth: function () {
                return this._width
            },
            setWidth: function (width) {
                this._width = width, this._owner[this._setter](this)
            },
            getHeight: function () {
                return this._height
            },
            setHeight: function (height) {
                this._height = height, this._owner[this._setter](this)
            }
        }),
        Rectangle = Base.extend({
            _class: "Rectangle",
            _readIndex: !0,
            beans: !0,
            initialize: function (arg0, arg1, arg2, arg3) {
                var type = typeof arg0,
                    read = 0;
                if ("number" === type ? (this.x = arg0, this.y = arg1, this.width = arg2, this.height = arg3, read = 4) : "undefined" === type || null === arg0 ? (this.x = this.y = this.width = this.height = 0, read = null === arg0 ? 1 : 0) : 1 === arguments.length && (Array.isArray(arg0) ? (this.x = arg0[0], this.y = arg0[1], this.width = arg0[2], this.height = arg0[3], read = 1) : arg0.x !== undefined || arg0.width !== undefined ? (this.x = arg0.x || 0, this.y = arg0.y || 0, this.width = arg0.width || 0, this.height = arg0.height || 0, read = 1) : arg0.from === undefined && arg0.to === undefined && (this.x = this.y = this.width = this.height = 0, this._set(arg0), read = 1)), !read) {
                    var point = Point.readNamed(arguments, "from"),
                        next = Base.peek(arguments);
                    if (this.x = point.x, this.y = point.y, next && next.x !== undefined || Base.hasNamed(arguments, "to")) {
                        var to = Point.readNamed(arguments, "to");
                        this.width = to.x - point.x, this.height = to.y - point.y, this.width < 0 && (this.x = to.x, this.width = -this.width), this.height < 0 && (this.y = to.y, this.height = -this.height)
                    } else {
                        var size = Size.read(arguments);
                        this.width = size.width, this.height = size.height
                    }
                    read = arguments.__index
                }
                this.__read && (this.__read = read)
            },
            set: function (x, y, width, height) {
                return this.x = x, this.y = y, this.width = width, this.height = height, this
            },
            clone: function () {
                return new Rectangle(this.x, this.y, this.width, this.height)
            },
            equals: function (rect) {
                var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
                return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || !1
            },
            toString: function () {
                var f = Formatter.instance;
                return "{ x: " + f.number(this.x) + ", y: " + f.number(this.y) + ", width: " + f.number(this.width) + ", height: " + f.number(this.height) + " }"
            },
            _serialize: function (options) {
                var f = options.formatter;
                return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)]
            },
            getPoint: function (_dontLink) {
                var ctor = _dontLink ? Point : LinkedPoint;
                return new ctor(this.x, this.y, this, "setPoint")
            },
            setPoint: function () {
                var point = Point.read(arguments);
                this.x = point.x, this.y = point.y
            },
            getSize: function (_dontLink) {
                var ctor = _dontLink ? Size : LinkedSize;
                return new ctor(this.width, this.height, this, "setSize")
            },
            setSize: function () {
                var size = Size.read(arguments);
                this._fixX && (this.x += (this.width - size.width) * this._fixX), this._fixY && (this.y += (this.height - size.height) * this._fixY), this.width = size.width, this.height = size.height, this._fixW = 1, this._fixH = 1
            },
            getLeft: function () {
                return this.x
            },
            setLeft: function (left) {
                this._fixW || (this.width -= left - this.x), this.x = left, this._fixX = 0
            },
            getTop: function () {
                return this.y
            },
            setTop: function (top) {
                this._fixH || (this.height -= top - this.y), this.y = top, this._fixY = 0
            },
            getRight: function () {
                return this.x + this.width
            },
            setRight: function (right) {
                this._fixX !== undefined && 1 !== this._fixX && (this._fixW = 0), this._fixW ? this.x = right - this.width : this.width = right - this.x, this._fixX = 1
            },
            getBottom: function () {
                return this.y + this.height
            },
            setBottom: function (bottom) {
                this._fixY !== undefined && 1 !== this._fixY && (this._fixH = 0), this._fixH ? this.y = bottom - this.height : this.height = bottom - this.y, this._fixY = 1
            },
            getCenterX: function () {
                return this.x + .5 * this.width
            },
            setCenterX: function (x) {
                this.x = x - .5 * this.width, this._fixX = .5
            },
            getCenterY: function () {
                return this.y + .5 * this.height
            },
            setCenterY: function (y) {
                this.y = y - .5 * this.height, this._fixY = .5
            },
            getCenter: function (_dontLink) {
                var ctor = _dontLink ? Point : LinkedPoint;
                return new ctor(this.getCenterX(), this.getCenterY(), this, "setCenter")
            },
            setCenter: function () {
                var point = Point.read(arguments);
                return this.setCenterX(point.x), this.setCenterY(point.y), this
            },
            getArea: function () {
                return this.width * this.height
            },
            isEmpty: function () {
                return 0 === this.width || 0 === this.height
            },
            contains: function (arg) {
                return arg && arg.width !== undefined || 4 == (Array.isArray(arg) ? arg : arguments).length ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments))
            },
            _containsPoint: function (point) {
                var x = point.x,
                    y = point.y;
                return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height
            },
            _containsRectangle: function (rect) {
                var x = rect.x,
                    y = rect.y;
                return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height
            },
            intersects: function () {
                var rect = Rectangle.read(arguments);
                return rect.x + rect.width > this.x && rect.y + rect.height > this.y && rect.x < this.x + this.width && rect.y < this.y + this.height
            },
            touches: function () {
                var rect = Rectangle.read(arguments);
                return rect.x + rect.width >= this.x && rect.y + rect.height >= this.y && rect.x <= this.x + this.width && rect.y <= this.y + this.height
            },
            intersect: function () {
                var rect = Rectangle.read(arguments),
                    x1 = Math.max(this.x, rect.x),
                    y1 = Math.max(this.y, rect.y),
                    x2 = Math.min(this.x + this.width, rect.x + rect.width),
                    y2 = Math.min(this.y + this.height, rect.y + rect.height);
                return new Rectangle(x1, y1, x2 - x1, y2 - y1)
            },
            unite: function () {
                var rect = Rectangle.read(arguments),
                    x1 = Math.min(this.x, rect.x),
                    y1 = Math.min(this.y, rect.y),
                    x2 = Math.max(this.x + this.width, rect.x + rect.width),
                    y2 = Math.max(this.y + this.height, rect.y + rect.height);
                return new Rectangle(x1, y1, x2 - x1, y2 - y1)
            },
            include: function () {
                var point = Point.read(arguments),
                    x1 = Math.min(this.x, point.x),
                    y1 = Math.min(this.y, point.y),
                    x2 = Math.max(this.x + this.width, point.x),
                    y2 = Math.max(this.y + this.height, point.y);
                return new Rectangle(x1, y1, x2 - x1, y2 - y1)
            },
            expand: function () {
                var amount = Size.read(arguments),
                    hor = amount.width,
                    ver = amount.height;
                return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver)
            },
            scale: function (hor, ver) {
                return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height)
            }
        }, new function () {
            return Base.each([
                ["Top", "Left"],
                ["Top", "Right"],
                ["Bottom", "Left"],
                ["Bottom", "Right"],
                ["Left", "Center"],
                ["Top", "Center"],
                ["Right", "Center"],
                ["Bottom", "Center"]
            ], function (parts, index) {
                var part = parts.join(""),
                    xFirst = /^[RL]/.test(part);
                index >= 4 && (parts[1] += xFirst ? "Y" : "X");
                var x = parts[xFirst ? 0 : 1],
                    y = parts[xFirst ? 1 : 0],
                    getX = "get" + x,
                    getY = "get" + y,
                    setX = "set" + x,
                    setY = "set" + y,
                    get = "get" + part,
                    set = "set" + part;
                this[get] = function (_dontLink) {
                    var ctor = _dontLink ? Point : LinkedPoint;
                    return new ctor(this[getX](), this[getY](), this, set)
                }, this[set] = function () {
                    var point = Point.read(arguments);
                    this[setX](point.x), this[setY](point.y)
                }
            }, {
                beans: !0
            })
        }),
        LinkedRectangle = Rectangle.extend({
            initialize: function (x, y, width, height, owner, setter) {
                this.set(x, y, width, height, !0), this._owner = owner, this._setter = setter
            },
            set: function (x, y, width, height, _dontNotify) {
                return this._x = x, this._y = y, this._width = width, this._height = height, _dontNotify || this._owner[this._setter](this), this
            }
        }, new function () {
            var proto = Rectangle.prototype;
            return Base.each(["x", "y", "width", "height"], function (key) {
                var part = Base.capitalize(key),
                    internal = "_" + key;
                this["get" + part] = function () {
                    return this[internal]
                }, this["set" + part] = function (value) {
                    this[internal] = value, this._dontNotify || this._owner[this._setter](this)
                }
            }, Base.each(["Point", "Size", "Center", "Left", "Top", "Right", "Bottom", "CenterX", "CenterY", "TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter"], function (key) {
                var name = "set" + key;
                this[name] = function () {
                    this._dontNotify = !0, proto[name].apply(this, arguments), this._dontNotify = !1, this._owner[this._setter](this)
                }
            }, {
                isSelected: function () {
                    return this._owner._boundsSelected
                },
                setSelected: function (selected) {
                    var owner = this._owner;
                    owner.setSelected && (owner._boundsSelected = selected, owner.setSelected(selected || owner._selectedSegmentState > 0))
                }
            }))
        }),
        Matrix = Base.extend({
            _class: "Matrix",
            initialize: function Matrix(arg) {
                var count = arguments.length,
                    ok = !0;
                if (6 === count ? this.set.apply(this, arguments) : 1 === count ? arg instanceof Matrix ? this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty) : Array.isArray(arg) ? this.set.apply(this, arg) : ok = !1 : 0 === count ? this.reset() : ok = !1, !ok) throw new Error("Unsupported matrix parameters")
            },
            set: function (a, c, b, d, tx, ty, _dontNotify) {
                return this._a = a, this._c = c, this._b = b, this._d = d, this._tx = tx, this._ty = ty, _dontNotify || this._changed(), this
            },
            _serialize: function (options) {
                return Base.serialize(this.getValues(), options)
            },
            _changed: function () {
                var owner = this._owner;
                owner && (owner._applyMatrix ? owner.transform(null, !0) : owner._changed(9))
            },
            clone: function () {
                return new Matrix(this._a, this._c, this._b, this._d, this._tx, this._ty)
            },
            equals: function (mx) {
                return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty || !1
            },
            toString: function () {
                var f = Formatter.instance;
                return "[[" + [f.number(this._a), f.number(this._b), f.number(this._tx)].join(", ") + "], [" + [f.number(this._c), f.number(this._d), f.number(this._ty)].join(", ") + "]]"
            },
            reset: function (_dontNotify) {
                return this._a = this._d = 1, this._c = this._b = this._tx = this._ty = 0, _dontNotify || this._changed(), this
            },
            apply: function () {
                var owner = this._owner;
                return owner ? (owner.transform(null, !0), this.isIdentity()) : !1
            },
            translate: function () {
                var point = Point.read(arguments),
                    x = point.x,
                    y = point.y;
                return this._tx += x * this._a + y * this._b, this._ty += x * this._c + y * this._d, this._changed(), this
            },
            scale: function () {
                var scale = Point.read(arguments),
                    center = Point.read(arguments, 0, {
                        readNull: !0
                    });
                return center && this.translate(center), this._a *= scale.x, this._c *= scale.x, this._b *= scale.y, this._d *= scale.y, center && this.translate(center.negate()), this._changed(), this
            },
            rotate: function (angle) {
                angle *= Math.PI / 180;
                var center = Point.read(arguments, 1),
                    x = center.x,
                    y = center.y,
                    cos = Math.cos(angle),
                    sin = Math.sin(angle),
                    tx = x - x * cos + y * sin,
                    ty = y - x * sin - y * cos,
                    a = this._a,
                    b = this._b,
                    c = this._c,
                    d = this._d;
                return this._a = cos * a + sin * b, this._b = -sin * a + cos * b, this._c = cos * c + sin * d, this._d = -sin * c + cos * d, this._tx += tx * a + ty * b, this._ty += tx * c + ty * d, this._changed(), this
            },
            shear: function () {
                var shear = Point.read(arguments),
                    center = Point.read(arguments, 0, {
                        readNull: !0
                    });
                center && this.translate(center);
                var a = this._a,
                    c = this._c;
                return this._a += shear.y * this._b, this._c += shear.y * this._d, this._b += shear.x * a, this._d += shear.x * c, center && this.translate(center.negate()), this._changed(), this
            },
            skew: function () {
                var skew = Point.read(arguments),
                    center = Point.read(arguments, 0, {
                        readNull: !0
                    }),
                    toRadians = Math.PI / 180,
                    shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
                return this.shear(shear, center)
            },
            concatenate: function (mx) {
                var a = this._a,
                    b = this._b,
                    c = this._c,
                    d = this._d;
                return this._a = mx._a * a + mx._c * b, this._b = mx._b * a + mx._d * b, this._c = mx._a * c + mx._c * d, this._d = mx._b * c + mx._d * d, this._tx += mx._tx * a + mx._ty * b, this._ty += mx._tx * c + mx._ty * d, this._changed(), this
            },
            preConcatenate: function (mx) {
                var a = this._a,
                    b = this._b,
                    c = this._c,
                    d = this._d,
                    tx = this._tx,
                    ty = this._ty;
                return this._a = mx._a * a + mx._b * c, this._b = mx._a * b + mx._b * d, this._c = mx._c * a + mx._d * c, this._d = mx._c * b + mx._d * d, this._tx = mx._a * tx + mx._b * ty + mx._tx, this._ty = mx._c * tx + mx._d * ty + mx._ty, this._changed(), this
            },
            isIdentity: function () {
                return 1 === this._a && 0 === this._c && 0 === this._b && 1 === this._d && 0 === this._tx && 0 === this._ty
            },
            orNullIfIdentity: function () {
                return this.isIdentity() ? null : this
            },
            isInvertible: function () {
                return !!this._getDeterminant()
            },
            isSingular: function () {
                return !this._getDeterminant()
            },
            transform: function (src, srcOffset, dst, dstOffset, count) {
                return arguments.length < 5 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, srcOffset, dst, dstOffset, count)
            },
            _transformPoint: function (point, dest, _dontNotify) {
                var x = point.x,
                    y = point.y;
                return dest || (dest = new Point), dest.set(x * this._a + y * this._b + this._tx, x * this._c + y * this._d + this._ty, _dontNotify)
            },
            _transformCoordinates: function (src, srcOffset, dst, dstOffset, count) {
                for (var i = srcOffset, j = dstOffset, max = i + 2 * count; max > i;) {
                    var x = src[i++],
                        y = src[i++];
                    dst[j++] = x * this._a + y * this._b + this._tx, dst[j++] = x * this._c + y * this._d + this._ty
                }
                return dst
            },
            _transformCorners: function (rect) {
                var x1 = rect.x,
                    y1 = rect.y,
                    x2 = x1 + rect.width,
                    y2 = y1 + rect.height,
                    coords = [x1, y1, x2, y1, x2, y2, x1, y2];
                return this._transformCoordinates(coords, 0, coords, 0, 4)
            },
            _transformBounds: function (bounds, dest, _dontNotify) {
                for (var coords = this._transformCorners(bounds), min = coords.slice(0, 2), max = coords.slice(), i = 2; 8 > i; i++) {
                    var val = coords[i],
                        j = 1 & i;
                    val < min[j] ? min[j] = val : val > max[j] && (max[j] = val)
                }
                return dest || (dest = new Rectangle), dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify)
            },
            inverseTransform: function () {
                return this._inverseTransform(Point.read(arguments))
            },
            _getDeterminant: function () {
                var det = this._a * this._d - this._b * this._c;
                return isFinite(det) && !Numerical.isZero(det) && isFinite(this._tx) && isFinite(this._ty) ? det : null
            },
            _inverseTransform: function (point, dest, _dontNotify) {
                var det = this._getDeterminant();
                if (!det) return null;
                var x = point.x - this._tx,
                    y = point.y - this._ty;
                return dest || (dest = new Point), dest.set((x * this._d - y * this._b) / det, (y * this._a - x * this._c) / det, _dontNotify)
            },
            decompose: function () {
                var a = this._a,
                    b = this._b,
                    c = this._c,
                    d = this._d;
                if (Numerical.isZero(a * d - b * c)) return null;
                var scaleX = Math.sqrt(a * a + b * b);
                a /= scaleX, b /= scaleX;
                var shear = a * c + b * d;
                c -= a * shear, d -= b * shear;
                var scaleY = Math.sqrt(c * c + d * d);
                return c /= scaleY, d /= scaleY, shear /= scaleY, b * c > a * d && (a = -a, b = -b, shear = -shear, scaleX = -scaleX), {
                    scaling: new Point(scaleX, scaleY),
                    rotation: 180 * -Math.atan2(b, a) / Math.PI,
                    shearing: shear
                }
            },
            getValues: function () {
                return [this._a, this._c, this._b, this._d, this._tx, this._ty]
            },
            getTranslation: function () {
                return new Point(this._tx, this._ty)
            },
            getScaling: function () {
                return (this.decompose() || {}).scaling
            },
            getRotation: function () {
                return (this.decompose() || {}).rotation
            },
            inverted: function () {
                var det = this._getDeterminant();
                return det && new Matrix(this._d / det, -this._c / det, -this._b / det, this._a / det, (this._b * this._ty - this._d * this._tx) / det, (this._c * this._tx - this._a * this._ty) / det)
            },
            shiftless: function () {
                return new Matrix(this._a, this._c, this._b, this._d, 0, 0)
            },
            applyToContext: function (ctx) {
                ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty)
            }
        }, Base.each(["a", "c", "b", "d", "tx", "ty"], function (name) {
            var part = Base.capitalize(name),
                prop = "_" + name;
            this["get" + part] = function () {
                return this[prop]
            }, this["set" + part] = function (value) {
                this[prop] = value, this._changed()
            }
        }, {})),
        Line = Base.extend({
            _class: "Line",
            initialize: function (arg0, arg1, arg2, arg3, arg4) {
                var asVector = !1;
                arguments.length >= 4 ? (this._px = arg0, this._py = arg1, this._vx = arg2, this._vy = arg3, asVector = arg4) : (this._px = arg0.x, this._py = arg0.y, this._vx = arg1.x, this._vy = arg1.y, asVector = arg2), asVector || (this._vx -= this._px, this._vy -= this._py)
            },
            getPoint: function () {
                return new Point(this._px, this._py)
            },
            getVector: function () {
                return new Point(this._vx, this._vy)
            },
            getLength: function () {
                return this.getVector().getLength()
            },
            intersect: function (line, isInfinite) {
                return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, !0, isInfinite)
            },
            getSide: function (point) {
                return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, !0)
            },
            getDistance: function (point) {
                return Math.abs(Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, !0))
            },
            statics: {
                intersect: function (apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector, isInfinite) {
                    asVector || (avx -= apx, avy -= apy, bvx -= bpx, bvy -= bpy);
                    var cross = bvy * avx - bvx * avy;
                    if (!Numerical.isZero(cross)) {
                        var dx = apx - bpx,
                            dy = apy - bpy,
                            ta = (bvx * dy - bvy * dx) / cross,
                            tb = (avx * dy - avy * dx) / cross;
                        if ((isInfinite || ta >= 0 && 1 >= ta) && (isInfinite || tb >= 0 && 1 >= tb)) return new Point(apx + ta * avx, apy + ta * avy)
                    }
                },
                getSide: function (px, py, vx, vy, x, y, asVector) {
                    asVector || (vx -= px, vy -= py);
                    var v2x = x - px,
                        v2y = y - py,
                        ccw = v2x * vy - v2y * vx;
                    return 0 === ccw && (ccw = v2x * vx + v2y * vy, ccw > 0 && (v2x -= vx, v2y -= vy, ccw = v2x * vx + v2y * vy, 0 > ccw && (ccw = 0))), 0 > ccw ? -1 : ccw > 0 ? 1 : 0
                },
                getSignedDistance: function (px, py, vx, vy, x, y, asVector) {
                    asVector || (vx -= px, vy -= py);
                    var m = vy / vx,
                        b = py - m * px;
                    return (y - m * x - b) / Math.sqrt(m * m + 1)
                }
            }
        }),
        Project = PaperScopeItem.extend({
            _class: "Project",
            _list: "projects",
            _reference: "project",
            initialize: function (element) {
                PaperScopeItem.call(this, !0), this.layers = [], this.symbols = [], this._currentStyle = new Style(null, null, this), this.activeLayer = new Layer, this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1)), this._selectedItems = {}, this._selectedItemCount = 0, this._updateVersion = 0
            },
            _serialize: function (options, dictionary) {
                return Base.serialize(this.layers, options, !0, dictionary)
            },
            clear: function () {
                for (var i = this.layers.length - 1; i >= 0; i--) this.layers[i].remove();
                this.symbols = []
            },
            isEmpty: function () {
                return this.layers.length <= 1 && (!this.activeLayer || this.activeLayer.isEmpty())
            },
            remove: function remove() {
                return remove.base.call(this) ? (this._view && this._view.remove(), !0) : !1
            },
            getView: function () {
                return this._view
            },
            getCurrentStyle: function () {
                return this._currentStyle
            },
            setCurrentStyle: function (style) {
                this._currentStyle.initialize(style)
            },
            getIndex: function () {
                return this._index
            },
            addChild: function (child) {
                return child instanceof Layer ? (Base.splice(this.layers, [child]), this.activeLayer || (this.activeLayer = child)) : child instanceof Item ? (this.activeLayer || this.addChild(new Layer(Item.NO_INSERT))).addChild(child) : child = null, child
            },
            getSelectedItems: function () {
                var items = [];
                for (var id in this._selectedItems) {
                    var item = this._selectedItems[id];
                    item.isInserted() && items.push(item)
                }
                return items
            },
            getOptions: function () {
                return this._scope.settings
            },
            _updateSelection: function (item) {
                var id = item._id,
                    selectedItems = this._selectedItems;
                item._selected ? selectedItems[id] !== item && (this._selectedItemCount++, selectedItems[id] = item) : selectedItems[id] === item && (this._selectedItemCount--, delete selectedItems[id])
            },
            selectAll: function () {
                for (var layers = this.layers, i = 0, l = layers.length; l > i; i++) layers[i].setFullySelected(!0)
            },
            deselectAll: function () {
                var selectedItems = this._selectedItems;
                for (var i in selectedItems) selectedItems[i].setFullySelected(!1)
            },
            hitTest: function () {
                for (var point = Point.read(arguments), options = HitResult.getOptions(Base.read(arguments)), i = this.layers.length - 1; i >= 0; i--) {
                    var res = this.layers[i].hitTest(point, options);
                    if (res) return res
                }
                return null
            },
            getItems: function (match) {
                return Item._getItems(this.layers, match, !0)
            },
            getItem: function (match) {
                return Item._getItems(this.layers, match, !1)
            },
            importJSON: function (json) {
                this.activate();
                var layer = this.activeLayer;
                return Base.importJSON(json, layer && layer.isEmpty() && layer)
            },
            draw: function (ctx, matrix, pixelRatio) {
                this._updateVersion++, ctx.save(), matrix.applyToContext(ctx);
                for (var param = new Base({
                    offset: new Point(0, 0),
                    pixelRatio: pixelRatio,
                    trackTransforms: !0,
                    transforms: [matrix]
                }), i = 0, l = this.layers.length; l > i; i++) this.layers[i].draw(ctx, param);
                if (ctx.restore(), this._selectedItemCount > 0) {
                    ctx.save(), ctx.strokeWidth = 1;
                    for (var id in this._selectedItems) {
                        var item = this._selectedItems[id],
                            globalMatrix = item._globalMatrix,
                            size = this._scope.settings.handleSize,
                            half = size / 2;
                        if (item._updateVersion === this._updateVersion && (item._drawSelected || item._boundsSelected) && globalMatrix) {
                            var color = item.getSelectedColor() || item.getLayer().getSelectedColor();
                            if (ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : "#009dec", item._drawSelected && item._drawSelected(ctx, globalMatrix), item._boundsSelected) {
                                var coords = globalMatrix._transformCorners(item.getInternalBounds());
                                ctx.beginPath();
                                for (var i = 0; 8 > i; i++) ctx[0 === i ? "moveTo" : "lineTo"](coords[i], coords[++i]);
                                ctx.closePath(), ctx.stroke();
                                for (var i = 0; 8 > i; i++) ctx.fillRect(coords[i] - half, coords[++i] - half, size, size)
                            }
                        }
                    }
                    ctx.restore()
                }
            }
        }),
        Symbol = Base.extend({
            _class: "Symbol",
            initialize: function Symbol(item, dontCenter) {
                this._id = Symbol._id = (Symbol._id || 0) + 1, this.project = paper.project, this.project.symbols.push(this), item && this.setDefinition(item, dontCenter)
            },
            _serialize: function (options, dictionary) {
                return dictionary.add(this, function () {
                    return Base.serialize([this._class, this._definition], options, !1, dictionary)
                })
            },
            _changed: function (flags) {
                8 & flags && Item._clearBoundsCache(this), 1 & flags && (this.project._needsUpdate = !0)
            },
            getDefinition: function () {
                return this._definition
            },
            setDefinition: function (item, _dontCenter) {
                item._parentSymbol && (item = item.clone()), this._definition && (this._definition._parentSymbol = null), this._definition = item, item.remove(), item.setSelected(!1), _dontCenter || item.setPosition(new Point), item._parentSymbol = this, this._changed(9)
            },
            place: function (position) {
                return new PlacedSymbol(this, position)
            },
            clone: function () {
                return new Symbol(this._definition.clone(!1))
            }
        }),
        Item = Base.extend(Callback, {
            statics: {
                extend: function extend(src) {
                    return src._serializeFields && (src._serializeFields = new Base(this.prototype._serializeFields, src._serializeFields)), extend.base.apply(this, arguments)
                },
                NO_INSERT: {
                    insert: !1
                }
            },
            _class: "Item",
            _applyMatrix: !0,
            _canApplyMatrix: !0,
            _boundsSelected: !1,
            _selectChildren: !1,
            _serializeFields: {
                name: null,
                matrix: new Matrix,
                pivot: null,
                locked: !1,
                visible: !0,
                blendMode: "normal",
                opacity: 1,
                guide: !1,
                selected: !1,
                clipMask: !1,
                applyMatrix: null,
                data: {}
            },
            initialize: function () {},
            _initialize: function (props, point) {
                var internal = props && props.internal === !0,
                    matrix = this._matrix = new Matrix,
                    project = paper.project;
                return internal || (this._id = Item._id = (Item._id || 0) + 1), this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix, point && matrix.translate(point), matrix._owner = this, this._style = new Style(project._currentStyle, this, project), this._project || (internal || props && props.insert === !1 ? this._setProject(project) : (project.activeLayer || new Layer).addChild(this)), props && props !== Item.NO_INSERT ? this._set(props, {
                    insert: !0
                }) : !0
            },
            _events: new function () {
                var mouseFlags = {
                        mousedown: {
                            mousedown: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mouseup: {
                            mouseup: 1,
                            mousedrag: 1,
                            click: 1,
                            doubleclick: 1
                        },
                        mousemove: {
                            mousedrag: 1,
                            mousemove: 1,
                            mouseenter: 1,
                            mouseleave: 1
                        }
                    },
                    mouseEvent = {
                        install: function (type) {
                            var counters = this.getView()._eventCounters;
                            if (counters)
                                for (var key in mouseFlags) counters[key] = (counters[key] || 0) + (mouseFlags[key][type] || 0)
                        },
                        uninstall: function (type) {
                            var counters = this.getView()._eventCounters;
                            if (counters)
                                for (var key in mouseFlags) counters[key] -= mouseFlags[key][type] || 0
                        }
                    };
                return Base.each(["onMouseDown", "onMouseUp", "onMouseDrag", "onClick", "onDoubleClick", "onMouseMove", "onMouseEnter", "onMouseLeave"], function (name) {
                    this[name] = mouseEvent
                }, {
                    onFrame: {
                        install: function () {
                            this._animateItem(!0)
                        },
                        uninstall: function () {
                            this._animateItem(!1)
                        }
                    },
                    onLoad: {}
                })
            },
            _animateItem: function (animate) {
                this.getView()._animateItem(this, animate)
            },
            _serialize: function (options, dictionary) {
                function serialize(fields) {
                    for (var key in fields) {
                        var value = that[key];
                        Base.equals(value, "leading" === key ? 1.2 * fields.fontSize : fields[key]) || (props[key] = Base.serialize(value, options, "data" !== key, dictionary))
                    }
                }
                var props = {},
                    that = this;
                return serialize(this._serializeFields), this instanceof Group || serialize(this._style._defaults), [this._class, props]
            },
            _changed: function (flags) {
                var symbol = this._parentSymbol,
                    cacheParent = this._parent || symbol,
                    project = this._project;
                if (8 & flags && (this._bounds = this._position = this._decomposed = this._globalMatrix = this._currentPath = undefined), cacheParent && 40 & flags && Item._clearBoundsCache(cacheParent), 2 & flags && Item._clearBoundsCache(this), project && (1 & flags && (project._needsUpdate = !0), project._changes)) {
                    var entry = project._changesById[this._id];
                    entry ? entry.flags |= flags : (entry = {
                        item: this,
                        flags: flags
                    }, project._changesById[this._id] = entry, project._changes.push(entry))
                }
                symbol && symbol._changed(flags)
            },
            set: function (props) {
                return props && this._set(props, {
                    insert: !0
                }), this
            },
            getId: function () {
                return this._id
            },
            getClassName: function () {
                return this._class
            },
            getName: function () {
                return this._name
            },
            setName: function (name, unique) {
                if (this._name && this._removeNamed(), name === +name + "") throw new Error("Names consisting only of numbers are not supported.");
                if (name && this._parent) {
                    for (var children = this._parent._children, namedChildren = this._parent._namedChildren, orig = name, i = 1; unique && children[name];) name = orig + " " + i++;
                    (namedChildren[name] = namedChildren[name] || []).push(this), children[name] = this
                }
                this._name = name || undefined, this._changed(128)
            },
            getStyle: function () {
                return this._style
            },
            setStyle: function (style) {
                this.getStyle().set(style)
            },
            hasFill: function () {
                return this.getStyle().hasFill()
            },
            hasStroke: function () {
                return this.getStyle().hasStroke()
            },
            hasShadow: function () {
                return this.getStyle().hasShadow()
            }
        }, Base.each(["locked", "visible", "blendMode", "opacity", "guide"], function (name) {
            var part = Base.capitalize(name),
                name = "_" + name;
            this["get" + part] = function () {
                return this[name]
            }, this["set" + part] = function (value) {
                value != this[name] && (this[name] = value, this._changed("_locked" === name ? 128 : 129))
            }
        }, {}), {
            beans: !0,
            _locked: !1,
            _visible: !0,
            _blendMode: "normal",
            _opacity: 1,
            _guide: !1,
            isSelected: function () {
                if (this._selectChildren)
                    for (var i = 0, l = this._children.length; l > i; i++)
                        if (this._children[i].isSelected()) return !0;
                return this._selected
            },
            setSelected: function (selected, noChildren) {
                if (!noChildren && this._selectChildren)
                    for (var i = 0, l = this._children.length; l > i; i++) this._children[i].setSelected(selected);
                (selected = !!selected) ^ this._selected && (this._selected = selected, this._project._updateSelection(this), this._changed(129))
            },
            _selected: !1,
            isFullySelected: function () {
                if (this._children && this._selected) {
                    for (var i = 0, l = this._children.length; l > i; i++)
                        if (!this._children[i].isFullySelected()) return !1;
                    return !0
                }
                return this._selected
            },
            setFullySelected: function (selected) {
                if (this._children)
                    for (var i = 0, l = this._children.length; l > i; i++) this._children[i].setFullySelected(selected);
                this.setSelected(selected, !0)
            },
            isClipMask: function () {
                return this._clipMask
            },
            setClipMask: function (clipMask) {
                this._clipMask != (clipMask = !!clipMask) && (this._clipMask = clipMask, clipMask && (this.setFillColor(null), this.setStrokeColor(null)), this._changed(129), this._parent && this._parent._changed(1024))
            },
            _clipMask: !1,
            getData: function () {
                return this._data || (this._data = {}), this._data
            },
            setData: function (data) {
                this._data = data
            },
            getPosition: function (_dontLink) {
                var position = this._position,
                    ctor = _dontLink ? Point : LinkedPoint;
                if (!position) {
                    var pivot = this._pivot;
                    position = this._position = pivot ? this._matrix._transformPoint(pivot) : this.getBounds().getCenter(!0)
                }
                return new ctor(position.x, position.y, this, "setPosition")
            },
            setPosition: function () {
                this.translate(Point.read(arguments).subtract(this.getPosition(!0)))
            },
            getPivot: function (_dontLink) {
                var pivot = this._pivot;
                if (pivot) {
                    var ctor = _dontLink ? Point : LinkedPoint;
                    pivot = new ctor(pivot.x, pivot.y, this, "setAnchor")
                }
                return pivot
            },
            setPivot: function () {
                this._pivot = Point.read(arguments), this._position = undefined
            },
            _pivot: null,
            getRegistration: "#getPivot",
            setRegistration: "#setPivot"
        }, Base.each(["bounds", "strokeBounds", "handleBounds", "roughBounds", "internalBounds", "internalRoughBounds"], function (key) {
            var getter = "get" + Base.capitalize(key),
                match = key.match(/^internal(.*)$/),
                internalGetter = match ? "get" + match[1] : null;
            this[getter] = function (_matrix) {
                var boundsGetter = this._boundsGetter,
                    name = !internalGetter && ("string" == typeof boundsGetter ? boundsGetter : boundsGetter && boundsGetter[getter]) || getter,
                    bounds = this._getCachedBounds(name, _matrix, null, internalGetter);
                return "bounds" === key ? new LinkedRectangle(bounds.x, bounds.y, bounds.width, bounds.height, this, "setBounds") : bounds
            }
        }, {
            beans: !0,
            _getBounds: function (getter, matrix, cacheItem) {
                var children = this._children;
                if (!children || 0 == children.length) return new Rectangle;
                for (var x1 = 1 / 0, x2 = -x1, y1 = x1, y2 = x2, i = 0, l = children.length; l > i; i++) {
                    var child = children[i];
                    if (child._visible && !child.isEmpty()) {
                        var rect = child._getCachedBounds(getter, matrix, cacheItem);
                        x1 = Math.min(rect.x, x1), y1 = Math.min(rect.y, y1), x2 = Math.max(rect.x + rect.width, x2), y2 = Math.max(rect.y + rect.height, y2)
                    }
                }
                return isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle
            },
            setBounds: function () {
                var rect = Rectangle.read(arguments),
                    bounds = this.getBounds(),
                    matrix = new Matrix,
                    center = rect.getCenter();
                matrix.translate(center), (rect.width != bounds.width || rect.height != bounds.height) && matrix.scale(0 != bounds.width ? rect.width / bounds.width : 1, 0 != bounds.height ? rect.height / bounds.height : 1), center = bounds.getCenter(), matrix.translate(-center.x, -center.y), this.transform(matrix)
            },
            _getCachedBounds: function (getter, matrix, cacheItem, internalGetter) {
                matrix = matrix && matrix.orNullIfIdentity();
                var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
                    cache = (!matrix || matrix.equals(_matrix)) && getter,
                    cacheParent = this._parent || this._parentSymbol;
                if (cacheItem && cacheParent) {
                    var id = cacheItem._id,
                        ref = cacheParent._boundsCache = cacheParent._boundsCache || {
                            ids: {},
                            list: []
                        };
                    ref.ids[id] || (ref.list.push(cacheItem), ref.ids[id] = cacheItem)
                }
                if (cache && this._bounds && this._bounds[cache]) return this._bounds[cache].clone();
                matrix = matrix ? _matrix ? matrix.clone().concatenate(_matrix) : matrix : _matrix;
                var bounds = this._getBounds(internalGetter || getter, matrix, cache ? this : cacheItem);
                if (cache) {
                    this._bounds || (this._bounds = {});
                    var cached = this._bounds[cache] = bounds.clone();
                    cached._internal = !!internalGetter
                }
                return bounds
            },
            statics: {
                _clearBoundsCache: function (item) {
                    if (item._boundsCache) {
                        for (var i = 0, list = item._boundsCache.list, l = list.length; l > i; i++) {
                            var child = list[i];
                            child._bounds = child._position = undefined, child !== item && child._boundsCache && Item._clearBoundsCache(child)
                        }
                        item._boundsCache = undefined
                    }
                }
            }
        }), {
            beans: !0,
            _decompose: function () {
                return this._decomposed = this._matrix.decompose()
            },
            getRotation: function () {
                var decomposed = this._decomposed || this._decompose();
                return decomposed && decomposed.rotation
            },
            setRotation: function (rotation) {
                var current = this.getRotation();
                if (null != current && null != rotation) {
                    var decomposed = this._decomposed;
                    this.rotate(rotation - current), decomposed.rotation = rotation, this._decomposed = decomposed
                }
            },
            getScaling: function () {
                var decomposed = this._decomposed || this._decompose();
                return decomposed && decomposed.scaling
            },
            setScaling: function () {
                var current = this.getScaling();
                if (null != current) {
                    var scaling = Point.read(arguments, 0, {
                            clone: !0
                        }),
                        decomposed = this._decomposed;
                    this.scale(scaling.x / current.x, scaling.y / current.y), decomposed.scaling = scaling, this._decomposed = decomposed
                }
            },
            getMatrix: function () {
                return this._matrix
            },
            setMatrix: function (matrix) {
                this._matrix.initialize(matrix), this._applyMatrix ? this.transform(null, !0) : this._changed(9)
            },
            getGlobalMatrix: function (_internal) {
                var matrix = this._globalMatrix,
                    updateVersion = this._project._updateVersion,
                    viewMatrix = this.getView()._matrix;
                return matrix && matrix._updateVersion !== updateVersion && (matrix = null), matrix || (matrix = this._globalMatrix = this._matrix.clone(), matrix.preConcatenate(this._parent ? this._parent.getGlobalMatrix(!0) : viewMatrix), matrix._updateVersion = updateVersion), _internal ? matrix : viewMatrix.inverted().concatenate(matrix)
            },
            getApplyMatrix: function () {
                return this._applyMatrix
            },
            setApplyMatrix: function (transform) {
                (this._applyMatrix = this._canApplyMatrix && !!transform) && this.transform(null, !0)
            },
            getTransformContent: "#getApplyMatrix",
            setTransformContent: "#setApplyMatrix"
        }, {
            getProject: function () {
                return this._project
            },
            _setProject: function (project, installEvents) {
                if (this._project !== project) {
                    this._project && this._installEvents(!1), this._project = project;
                    for (var children = this._children, i = 0, l = children && children.length; l > i; i++) children[i]._setProject(project);
                    installEvents = !0
                }
                installEvents && this._installEvents(!0)
            },
            getView: function () {
                return this._project.getView()
            },
            _installEvents: function _installEvents(install) {
                _installEvents.base.call(this, install);
                for (var children = this._children, i = 0, l = children && children.length; l > i; i++) children[i]._installEvents(install)
            },
            getLayer: function () {
                for (var parent = this; parent = parent._parent;)
                    if (parent instanceof Layer) return parent;
                return null
            },
            getParent: function () {
                return this._parent
            },
            setParent: function (item) {
                return item.addChild(this)
            },
            getChildren: function () {
                return this._children
            },
            setChildren: function (items) {
                this.removeChildren(), this.addChildren(items)
            },
            getFirstChild: function () {
                return this._children && this._children[0] || null
            },
            getLastChild: function () {
                return this._children && this._children[this._children.length - 1] || null
            },
            getNextSibling: function () {
                return this._parent && this._parent._children[this._index + 1] || null
            },
            getPreviousSibling: function () {
                return this._parent && this._parent._children[this._index - 1] || null
            },
            getIndex: function () {
                return this._index
            },
            isInserted: function () {
                return this._parent ? this._parent.isInserted() : !1
            },
            equals: function (item) {
                return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || !1
            },
            _equals: function (item) {
                return Base.equals(this._children, item._children)
            },
            clone: function (insert) {
                return this._clone(new this.constructor(Item.NO_INSERT), insert)
            },
            _clone: function (copy, insert) {
                if (copy.setStyle(this._style), this._children)
                    for (var i = 0, l = this._children.length; l > i; i++) copy.addChild(this._children[i].clone(!1), !0);
                (insert || insert === undefined) && copy.insertAbove(this);
                for (var keys = ["_locked", "_visible", "_blendMode", "_opacity", "_clipMask", "_guide", "_applyMatrix"], i = 0, l = keys.length; l > i; i++) {
                    var key = keys[i];
                    this.hasOwnProperty(key) && (copy[key] = this[key])
                }
                return copy._matrix.initialize(this._matrix), copy._data = this._data ? Base.clone(this._data) : null, copy.setSelected(this._selected), this._name && copy.setName(this._name, !0), copy
            },
            copyTo: function (itemOrProject) {
                return itemOrProject.addChild(this.clone(!1))
            },
            rasterize: function (resolution) {
                var bounds = this.getStrokeBounds(),
                    scale = (resolution || this.getView().getResolution()) / 72,
                    topLeft = bounds.getTopLeft().floor(),
                    bottomRight = bounds.getBottomRight().ceil(),
                    size = new Size(bottomRight.subtract(topLeft)),
                    canvas = CanvasProvider.getCanvas(size.multiply(scale)),
                    ctx = canvas.getContext("2d"),
                    matrix = (new Matrix).scale(scale).translate(topLeft.negate());
                ctx.save(), matrix.applyToContext(ctx), this.draw(ctx, new Base({
                    transforms: [matrix]
                })), ctx.restore();
                var raster = new Raster(Item.NO_INSERT);
                return raster.setCanvas(canvas), raster.transform((new Matrix).translate(topLeft.add(size.divide(2))).scale(1 / scale)), raster.insertAbove(this), raster
            },
            contains: function () {
                return !!this._contains(this._matrix._inverseTransform(Point.read(arguments)))
            },
            _contains: function (point) {
                if (this._children) {
                    for (var i = this._children.length - 1; i >= 0; i--)
                        if (this._children[i].contains(point)) return !0;
                    return !1
                }
                return point.isInside(this.getInternalBounds())
            },
            hitTest: function (point, options) {
                function checkBounds(type, part) {
                    var pt = bounds["get" + part]();
                    return point.subtract(pt).divide(tolerancePadding).length <= 1 ? new HitResult(type, that, {
                        name: Base.hyphenate(part),
                        point: pt
                    }) : void 0
                }
                if (point = Point.read(arguments), options = HitResult.getOptions(Base.read(arguments)), this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) return null;
                var matrix = this._matrix,
                    parentTotalMatrix = options._totalMatrix,
                    view = this.getView(),
                    totalMatrix = options._totalMatrix = parentTotalMatrix ? parentTotalMatrix.clone().concatenate(matrix) : this.getGlobalMatrix().clone().preConcatenate(view._matrix),
                    tolerancePadding = options._tolerancePadding = new Size(Path._getPenPadding(1, totalMatrix.inverted())).multiply(Math.max(options.tolerance, 1e-5));
                if (point = matrix._inverseTransform(point), !this._children && !this.getInternalRoughBounds().expand(tolerancePadding.multiply(2))._containsPoint(point)) return null;
                var type, res, checkSelf = !(options.guides && !this._guide || options.selected && !this._selected || (type = options.type) && ("string" == typeof type ? type !== Base.hyphenate(this._class) : !(this instanceof type))),
                    that = this;
                if (checkSelf && (options.center || options.bounds) && this._parent) {
                    var bounds = this.getInternalBounds();
                    if (options.center && (res = checkBounds("center", "Center")), !res && options.bounds)
                        for (var points = ["TopLeft", "TopRight", "BottomLeft", "BottomRight", "LeftCenter", "TopCenter", "RightCenter", "BottomCenter"], i = 0; 8 > i && !res; i++) res = checkBounds("bounds", points[i])
                }
                var children = !res && this._children;
                if (children)
                    for (var opts = this._getChildHitTestOptions(options), i = children.length - 1; i >= 0 && !res; i--) res = children[i].hitTest(point, opts);
                return !res && checkSelf && (res = this._hitTest(point, options)), res && res.point && (res.point = matrix.transform(res.point)), options._totalMatrix = parentTotalMatrix, res
            },
            _getChildHitTestOptions: function (options) {
                return options
            },
            _hitTest: function (point, options) {
                return options.fill && this.hasFill() && this._contains(point) ? new HitResult("fill", this) : void 0
            }
        }, {
            matches: function (match) {
                function matchObject(obj1, obj2) {
                    for (var i in obj1)
                        if (obj1.hasOwnProperty(i)) {
                            var val1 = obj1[i],
                                val2 = obj2[i];
                            if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                                if (!matchObject(val1, val2)) return !1
                            } else if (!Base.equals(val1, val2)) return !1
                        }
                    return !0
                }
                for (var key in match)
                    if (match.hasOwnProperty(key)) {
                        var value = this[key],
                            compare = match[key];
                        if (value === undefined && "type" === key && (value = Base.hyphenate(this._class)), /^(constructor|class)$/.test(key)) {
                            if (!(this instanceof compare)) return !1
                        } else if (compare instanceof RegExp) {
                            if (!compare.test(value)) return !1
                        } else if ("function" == typeof compare) {
                            if (!compare(value)) return !1
                        } else if (Base.isPlainObject(compare)) {
                            if (!matchObject(compare, value)) return !1
                        } else if (!Base.equals(value, compare)) return !1
                    }
                return !0
            },
            getItems: function (match) {
                return Item._getItems(this._children, match, !0)
            },
            getItem: function (match) {
                return Item._getItems(this._children, match, !1)
            },
            statics: {
                _getItems: function _getItems(children, match, list) {
                    for (var items = list && [], i = 0, l = children && children.length; l > i; i++) {
                        var child = children[i];
                        if (child.matches(match)) {
                            if (!list) return child;
                            items.push(child)
                        }
                        var res = _getItems(child._children, match, list);
                        if (list) items.push.apply(items, res);
                        else if (res) return res
                    }
                    return list ? items : null
                }
            }
        }, {
            importJSON: function (json) {
                var res = Base.importJSON(json, this);
                return res !== this ? this.addChild(res) : res
            },
            addChild: function (item, _preserve) {
                return this.insertChild(undefined, item, _preserve)
            },
            insertChild: function (index, item, _preserve) {
                var res = this.insertChildren(index, [item], _preserve);
                return res && res[0]
            },
            addChildren: function (items, _preserve) {
                return this.insertChildren(this._children.length, items, _preserve)
            },
            insertChildren: function (index, items, _preserve, _proto) {
                var children = this._children;
                if (children && items && items.length > 0) {
                    items = Array.prototype.slice.apply(items);
                    for (var i = items.length - 1; i >= 0; i--) {
                        var item = items[i];
                        !_proto || item instanceof _proto ? item._remove(!1, !0) : items.splice(i, 1)
                    }
                    Base.splice(children, items, index, 0);
                    for (var project = this._project, notifySelf = project && project._changes, i = 0, l = items.length; l > i; i++) {
                        var item = items[i];
                        item._parent = this, item._setProject(this._project, !0), item._name && item.setName(item._name), notifySelf && this._changed(5)
                    }
                    this._changed(11)
                } else items = null;
                return items
            },
            _insert: function (above, item, _preserve) {
                if (!item._parent) return null;
                var index = item._index + (above ? 1 : 0);
                return item._parent === this._parent && index > this._index && index--, item._parent.insertChild(index, this, _preserve)
            },
            insertAbove: function (item, _preserve) {
                return this._insert(!0, item, _preserve)
            },
            insertBelow: function (item, _preserve) {
                return this._insert(!1, item, _preserve)
            },
            sendToBack: function () {
                return this._parent.insertChild(0, this)
            },
            bringToFront: function () {
                return this._parent.addChild(this)
            },
            appendTop: "#addChild",
            appendBottom: function (item) {
                return this.insertChild(0, item)
            },
            moveAbove: "#insertAbove",
            moveBelow: "#insertBelow",
            reduce: function () {
                if (this._children && 1 === this._children.length) {
                    var child = this._children[0].reduce();
                    return child.insertAbove(this), child.setStyle(this._style), this.remove(), child
                }
                return this
            },
            _removeNamed: function () {
                var children = this._parent._children,
                    namedChildren = this._parent._namedChildren,
                    name = this._name,
                    namedArray = namedChildren[name],
                    index = namedArray ? namedArray.indexOf(this) : -1; - 1 != index && (children[name] == this && delete children[name], namedArray.splice(index, 1), namedArray.length ? children[name] = namedArray[namedArray.length - 1] : delete namedChildren[name])
            },
            _remove: function (notifySelf, notifyParent) {
                var parent = this._parent;
                if (parent) {
                    if (this._name && this._removeNamed(), null != this._index && Base.splice(parent._children, null, this._index, 1), this._installEvents(!1), notifySelf) {
                        var project = this._project;
                        project && project._changes && this._changed(5)
                    }
                    return notifyParent && parent._changed(11), this._parent = null, !0
                }
                return !1
            },
            remove: function () {
                return this._remove(!0, !0)
            },
            removeChildren: function (from, to) {
                if (!this._children) return null;
                from = from || 0, to = Base.pick(to, this._children.length);
                for (var removed = Base.splice(this._children, null, from, to - from), i = removed.length - 1; i >= 0; i--) removed[i]._remove(!0, !1);
                return removed.length > 0 && this._changed(11), removed
            },
            clear: "#removeChildren",
            reverseChildren: function () {
                if (this._children) {
                    this._children.reverse();
                    for (var i = 0, l = this._children.length; l > i; i++) this._children[i]._index = i;
                    this._changed(11)
                }
            },
            isEmpty: function () {
                return !this._children || 0 == this._children.length
            },
            isEditable: function () {
                for (var item = this; item;) {
                    if (!item._visible || item._locked) return !1;
                    item = item._parent
                }
                return !0
            },
            _getOrder: function (item) {
                function getList(item) {
                    var list = [];
                    do list.unshift(item); while (item = item._parent);
                    return list
                }
                for (var list1 = getList(this), list2 = getList(item), i = 0, l = Math.min(list1.length, list2.length); l > i; i++)
                    if (list1[i] != list2[i]) return list1[i]._index < list2[i]._index ? 1 : -1;
                return 0
            },
            hasChildren: function () {
                return this._children && this._children.length > 0
            },
            isAbove: function (item) {
                return -1 === this._getOrder(item)
            },
            isBelow: function (item) {
                return 1 === this._getOrder(item)
            },
            isParent: function (item) {
                return this._parent === item
            },
            isChild: function (item) {
                return item && item._parent === this
            },
            isDescendant: function (item) {
                for (var parent = this; parent = parent._parent;)
                    if (parent == item) return !0;
                return !1
            },
            isAncestor: function (item) {
                return item ? item.isDescendant(this) : !1
            },
            isGroupedWith: function (item) {
                for (var parent = this._parent; parent;) {
                    if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return !0;
                    parent = parent._parent
                }
                return !1
            },
            translate: function () {
                var mx = new Matrix;
                return this.transform(mx.translate.apply(mx, arguments))
            },
            rotate: function (angle) {
                return this.transform((new Matrix).rotate(angle, Point.read(arguments, 1, {
                    readNull: !0
                }) || this.getPosition(!0)))
            }
        }, Base.each(["scale", "shear", "skew"], function (name) {
            this[name] = function () {
                var point = Point.read(arguments),
                    center = Point.read(arguments, 0, {
                        readNull: !0
                    });
                return this.transform((new Matrix)[name](point, center || this.getPosition(!0)))
            }
        }, {}), {
            transform: function (matrix, _applyMatrix) {
                matrix && matrix.isIdentity() && (matrix = null);
                var _matrix = this._matrix,
                    applyMatrix = (_applyMatrix || this._applyMatrix) && (!_matrix.isIdentity() || matrix);
                if (!matrix && !applyMatrix) return this;
                if (matrix && _matrix.preConcatenate(matrix), applyMatrix = applyMatrix && this._transformContent(_matrix)) {
                    var pivot = this._pivot,
                        style = this._style,
                        fillColor = style.getFillColor(!0),
                        strokeColor = style.getStrokeColor(!0);
                    pivot && pivot.transform(_matrix), fillColor && fillColor.transform(_matrix), strokeColor && strokeColor.transform(_matrix), _matrix.reset(!0)
                }
                var bounds = this._bounds,
                    position = this._position;
                this._changed(9);
                var decomp = bounds && matrix && matrix.decompose();
                if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
                    for (var key in bounds) {
                        var rect = bounds[key];
                        (applyMatrix || !rect._internal) && matrix._transformBounds(rect, rect)
                    }
                    var getter = this._boundsGetter,
                        rect = bounds[getter && getter.getBounds || getter || "getBounds"];
                    rect && (this._position = rect.getCenter(!0)), this._bounds = bounds
                } else matrix && position && (this._position = matrix._transformPoint(position, position));
                return this
            },
            _transformContent: function (matrix) {
                var children = this._children;
                if (children) {
                    for (var i = 0, l = children.length; l > i; i++) children[i].transform(matrix, !0);
                    return !0
                }
            },
            globalToLocal: function () {
                var matrix = this.getGlobalMatrix();
                return matrix && matrix._inverseTransform(Point.read(arguments))
            },
            localToGlobal: function () {
                var matrix = this.getGlobalMatrix();
                return matrix && matrix._transformPoint(Point.read(arguments))
            },
            fitBounds: function (rectangle, fill) {
                rectangle = Rectangle.read(arguments);
                var bounds = this.getBounds(),
                    itemRatio = bounds.height / bounds.width,
                    rectRatio = rectangle.height / rectangle.width,
                    scale = (fill ? itemRatio > rectRatio : rectRatio > itemRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
                    newBounds = new Rectangle(new Point, new Size(bounds.width * scale, bounds.height * scale));
                newBounds.setCenter(rectangle.getCenter()), this.setBounds(newBounds)
            },
            _setStyles: function (ctx) {
                var style = this._style,
                    fillColor = style.getFillColor(),
                    strokeColor = style.getStrokeColor(),
                    shadowColor = style.getShadowColor();
                if (fillColor && (ctx.fillStyle = fillColor.toCanvasStyle(ctx)), strokeColor) {
                    var strokeWidth = style.getStrokeWidth();
                    if (strokeWidth > 0) {
                        ctx.strokeStyle = strokeColor.toCanvasStyle(ctx), ctx.lineWidth = strokeWidth;
                        var strokeJoin = style.getStrokeJoin(),
                            strokeCap = style.getStrokeCap(),
                            miterLimit = style.getMiterLimit();
                        if (strokeJoin && (ctx.lineJoin = strokeJoin), strokeCap && (ctx.lineCap = strokeCap), miterLimit && (ctx.miterLimit = miterLimit), paper.support.nativeDash) {
                            var dashArray = style.getDashArray(),
                                dashOffset = style.getDashOffset();
                            dashArray && dashArray.length && ("setLineDash" in ctx ? (ctx.setLineDash(dashArray), ctx.lineDashOffset = dashOffset) : (ctx.mozDash = dashArray, ctx.mozDashOffset = dashOffset))
                        }
                    }
                }
                if (shadowColor) {
                    var shadowBlur = style.getShadowBlur();
                    if (shadowBlur > 0) {
                        ctx.shadowColor = shadowColor.toCanvasStyle(ctx), ctx.shadowBlur = shadowBlur;
                        var offset = this.getShadowOffset();
                        ctx.shadowOffsetX = offset.x, ctx.shadowOffsetY = offset.y
                    }
                }
            },
            draw: function (ctx, param) {
                if (this._visible && 0 !== this._opacity) {
                    var updateVersion = this._updateVersion = this._project._updateVersion,
                        trackTransforms = param.trackTransforms,
                        transforms = param.transforms,
                        matrix = this._matrix,
                        parentMatrix = transforms[transforms.length - 1],
                        globalMatrix = parentMatrix.clone().concatenate(matrix);
                    if (globalMatrix.isInvertible()) {
                        trackTransforms && (transforms.push(this._globalMatrix = globalMatrix), globalMatrix._updateVersion = updateVersion);
                        var mainCtx, itemOffset, prevOffset, blendMode = this._blendMode,
                            opacity = this._opacity,
                            normalBlend = "normal" === blendMode,
                            nativeBlend = BlendMode.nativeModes[blendMode],
                            direct = normalBlend && 1 === opacity || param.clip || (nativeBlend || normalBlend && 1 > opacity) && this._canComposite();
                        if (!direct) {
                            var bounds = this.getStrokeBounds(parentMatrix);
                            if (!bounds.width || !bounds.height) return;
                            prevOffset = param.offset, itemOffset = param.offset = bounds.getTopLeft().floor(), mainCtx = ctx, ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(new Size(1, 1)), param.pixelRatio)
                        }
                        ctx.save(), direct ? (ctx.globalAlpha = opacity, nativeBlend && (ctx.globalCompositeOperation = blendMode)) : ctx.translate(-itemOffset.x, -itemOffset.y), (direct ? matrix : globalMatrix).applyToContext(ctx), !direct && param.clipItem && param.clipItem.draw(ctx, param.extend({
                            clip: !0
                        })), this._draw(ctx, param), ctx.restore(), trackTransforms && transforms.pop(), param.clip && !param.dontFinish && ctx.clip(), direct || (BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(param.pixelRatio)), CanvasProvider.release(ctx), param.offset = prevOffset)
                    }
                }
            },
            _canComposite: function () {
                return !1
            }
        }, Base.each(["down", "drag", "up", "move"], function (name) {
            this["removeOn" + Base.capitalize(name)] = function () {
                var hash = {};
                return hash[name] = !0, this.removeOn(hash)
            }
        }, {
            removeOn: function (obj) {
                for (var name in obj)
                    if (obj[name]) {
                        var key = "mouse" + name,
                            project = this._project,
                            sets = project._removeSets = project._removeSets || {};
                        sets[key] = sets[key] || {}, sets[key][this._id] = this
                    }
                return this
            }
        })),
        Group = Item.extend({
            _class: "Group",
            _selectChildren: !0,
            _serializeFields: {
                children: []
            },
            initialize: function (arg) {
                this._children = [], this._namedChildren = {}, this._initialize(arg) || this.addChildren(Array.isArray(arg) ? arg : arguments)
            },
            _changed: function _changed(flags) {
                _changed.base.call(this, flags), 1026 & flags && (this._clipItem = undefined)
            },
            _getClipItem: function () {
                var clipItem = this._clipItem;
                if (clipItem === undefined) {
                    clipItem = null;
                    for (var i = 0, l = this._children.length; l > i; i++) {
                        var child = this._children[i];
                        if (child._clipMask) {
                            clipItem = child;
                            break
                        }
                    }
                    this._clipItem = clipItem
                }
                return clipItem
            },
            isClipped: function () {
                return !!this._getClipItem()
            },
            setClipped: function (clipped) {
                var child = this.getFirstChild();
                child && child.setClipMask(clipped)
            },
            _draw: function (ctx, param) {
                var clip = param.clip,
                    clipItem = !clip && this._getClipItem(),
                    draw = !0;
                if (param = param.extend({
                    clipItem: clipItem,
                    clip: !1
                }), clip ? this._currentPath ? (ctx.currentPath = this._currentPath, draw = !1) : (ctx.beginPath(), param.dontStart = param.dontFinish = !0) : clipItem && clipItem.draw(ctx, param.extend({
                    clip: !0
                })), draw)
                    for (var i = 0, l = this._children.length; l > i; i++) {
                        var item = this._children[i];
                        item !== clipItem && item.draw(ctx, param)
                    }
                clip && (this._currentPath = ctx.currentPath)
            }
        }),
        Layer = Group.extend({
            _class: "Layer",
            initialize: function (arg) {
                var props = Base.isPlainObject(arg) ? new Base(arg) : {
                        children: Array.isArray(arg) ? arg : arguments
                    },
                    insert = props.insert;
                props.insert = !1, Group.call(this, props), (insert || insert === undefined) && (this._project.addChild(this), this.activate())
            },
            _remove: function _remove(notify) {
                return this._parent ? _remove.base.call(this, notify) : null != this._index ? (this._project.activeLayer === this && (this._project.activeLayer = this.getNextSibling() || this.getPreviousSibling()), Base.splice(this._project.layers, null, this._index, 1), this._installEvents(!1), this._project._needsUpdate = !0, !0) : !1
            },
            getNextSibling: function getNextSibling() {
                return this._parent ? getNextSibling.base.call(this) : this._project.layers[this._index + 1] || null
            },
            getPreviousSibling: function getPreviousSibling() {
                return this._parent ? getPreviousSibling.base.call(this) : this._project.layers[this._index - 1] || null
            },
            isInserted: function isInserted() {
                return this._parent ? isInserted.base.call(this) : null != this._index
            },
            activate: function () {
                this._project.activeLayer = this
            },
            _insert: function _insert(above, item, _preserve) {
                return item instanceof Layer && !item._parent ? (this._remove(!0, !0), Base.splice(item._project.layers, [this], item._index + (above ? 1 : 0), 0), this._setProject(item._project, !0), this) : _insert.base.call(this, above, item, _preserve)
            }
        }),
        Shape = Item.extend({
            _class: "Shape",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _boundsSelected: !0,
            _serializeFields: {
                type: null,
                size: null,
                radius: null
            },
            initialize: function (props) {
                this._initialize(props)
            },
            _equals: function (item) {
                return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius)
            },
            clone: function (insert) {
                var copy = new Shape(Item.NO_INSERT);
                return copy.setType(this._type), copy.setSize(this._size), copy.setRadius(this._radius), this._clone(copy, insert)
            },
            getType: function () {
                return this._type
            },
            setType: function (type) {
                this._type = type
            },
            getShape: "#getType",
            setShape: "#setType",
            getSize: function () {
                var size = this._size;
                return new LinkedSize(size.width, size.height, this, "setSize")
            },
            setSize: function () {
                var size = Size.read(arguments);
                if (this._size) {
                    if (!this._size.equals(size)) {
                        var type = this._type,
                            width = size.width,
                            height = size.height;
                        if ("rectangle" === type) {
                            var radius = Size.min(this._radius, size.divide(2));
                            this._radius.set(radius.width, radius.height)
                        } else "circle" === type ? (width = height = (width + height) / 2, this._radius = width / 2) : "ellipse" === type && this._radius.set(width / 2, height / 2);
                        this._size.set(width, height), this._changed(9)
                    }
                } else this._size = size.clone()
            },
            getRadius: function () {
                var rad = this._radius;
                return "circle" === this._type ? rad : new LinkedSize(rad.width, rad.height, this, "setRadius")
            },
            setRadius: function (radius) {
                var type = this._type;
                if ("circle" === type) {
                    if (radius === this._radius) return;
                    var size = 2 * radius;
                    this._radius = radius, this._size.set(size, size)
                } else if (radius = Size.read(arguments), this._radius) {
                    if (this._radius.equals(radius)) return;
                    if (this._radius.set(radius.width, radius.height), "rectangle" === type) {
                        var size = Size.max(this._size, radius.multiply(2));
                        this._size.set(size.width, size.height)
                    } else "ellipse" === type && this._size.set(2 * radius.width, 2 * radius.height)
                } else this._radius = radius.clone();
                this._changed(9)
            },
            isEmpty: function () {
                return !1
            },
            toPath: function (insert) {
                var path = new(Path[Base.capitalize(this._type)])({
                    center: new Point,
                    size: this._size,
                    radius: this._radius,
                    insert: !1
                });
                return path.setStyle(this._style), path.transform(this._matrix), (insert || insert === undefined) && path.insertAbove(this), path
            },
            _draw: function (ctx, param) {
                var style = this._style,
                    hasFill = style.hasFill(),
                    hasStroke = style.hasStroke(),
                    dontPaint = param.dontFinish || param.clip;
                if (hasFill || hasStroke || dontPaint) {
                    var radius = this._radius,
                        type = this._type;
                    if (param.dontStart || ctx.beginPath(), "circle" === type) ctx.arc(0, 0, radius, 0, 2 * Math.PI, !0);
                    else {
                        var rx = radius.width,
                            ry = radius.height,
                            kappa = .5522847498307936;
                        if ("ellipse" === type) {
                            var cx = rx * kappa,
                                cy = ry * kappa;
                            ctx.moveTo(-rx, 0), ctx.bezierCurveTo(-rx, -cy, -cx, -ry, 0, -ry), ctx.bezierCurveTo(cx, -ry, rx, -cy, rx, 0), ctx.bezierCurveTo(rx, cy, cx, ry, 0, ry), ctx.bezierCurveTo(-cx, ry, -rx, cy, -rx, 0)
                        } else {
                            var size = this._size,
                                width = size.width,
                                height = size.height;
                            if (0 === rx && 0 === ry) ctx.rect(-width / 2, -height / 2, width, height);
                            else {
                                kappa = 1 - kappa;
                                var x = width / 2,
                                    y = height / 2,
                                    cx = rx * kappa,
                                    cy = ry * kappa;
                                ctx.moveTo(-x, -y + ry), ctx.bezierCurveTo(-x, -y + cy, -x + cx, -y, -x + rx, -y), ctx.lineTo(x - rx, -y), ctx.bezierCurveTo(x - cx, -y, x, -y + cy, x, -y + ry), ctx.lineTo(x, y - ry), ctx.bezierCurveTo(x, y - cy, x - cx, y, x - rx, y), ctx.lineTo(-x + rx, y), ctx.bezierCurveTo(-x + cx, y, -x, y - cy, -x, y - ry)
                            }
                        }
                    }
                    ctx.closePath()
                }
                dontPaint || !hasFill && !hasStroke || (this._setStyles(ctx), hasFill && (ctx.fill(style.getWindingRule()), ctx.shadowColor = "rgba(0,0,0,0)"), hasStroke && ctx.stroke())
            },
            _canComposite: function () {
                return !(this.hasFill() && this.hasStroke())
            },
            _getBounds: function (getter, matrix) {
                var rect = new Rectangle(this._size).setCenter(0, 0);
                return "getBounds" !== getter && this.hasStroke() && (rect = rect.expand(this.getStrokeWidth())), matrix ? matrix._transformBounds(rect) : rect
            }
        }, new function () {
            function getCornerCenter(that, point, expand) {
                var radius = that._radius;
                if (!radius.isZero())
                    for (var halfSize = that._size.divide(2), i = 0; 4 > i; i++) {
                        var dir = new Point(1 & i ? 1 : -1, i > 1 ? 1 : -1),
                            corner = dir.multiply(halfSize),
                            center = corner.subtract(dir.multiply(radius)),
                            rect = new Rectangle(corner, center);
                        if ((expand ? rect.expand(expand) : rect).contains(point)) return center
                    }
            }

            function getEllipseRadius(point, radius) {
                var angle = point.getAngleInRadians(),
                    width = 2 * radius.width,
                    height = 2 * radius.height,
                    x = width * Math.sin(angle),
                    y = height * Math.cos(angle);
                return width * height / (2 * Math.sqrt(x * x + y * y))
            }
            return {
                _contains: function _contains(point) {
                    if ("rectangle" === this._type) {
                        var center = getCornerCenter(this, point);
                        return center ? point.subtract(center).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point)
                    }
                    return point.divide(this.size).getLength() <= .5
                },
                _hitTest: function _hitTest(point, options) {
                    var hit = !1;
                    if (this.hasStroke()) {
                        var type = this._type,
                            radius = this._radius,
                            strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
                        if ("rectangle" === type) {
                            var center = getCornerCenter(this, point, strokeWidth);
                            if (center) {
                                var pt = point.subtract(center);
                                hit = 2 * Math.abs(pt.getLength() - getEllipseRadius(pt, radius)) <= strokeWidth
                            } else {
                                var rect = new Rectangle(this._size).setCenter(0, 0),
                                    outer = rect.expand(strokeWidth),
                                    inner = rect.expand(-strokeWidth);
                                hit = outer._containsPoint(point) && !inner._containsPoint(point)
                            }
                        } else "ellipse" === type && (radius = getEllipseRadius(point, radius)), hit = 2 * Math.abs(point.getLength() - radius) <= strokeWidth
                    }
                    return hit ? new HitResult("stroke", this) : _hitTest.base.apply(this, arguments)
                }
            }
        }, {
            statics: new function () {
                function createShape(type, point, size, radius, args) {
                    var item = new Shape(Base.getNamed(args));
                    return item._type = type, item._size = size, item._radius = radius, item.translate(point)
                }
                return {
                    Circle: function () {
                        var center = Point.readNamed(arguments, "center"),
                            radius = Base.readNamed(arguments, "radius");
                        return createShape("circle", center, new Size(2 * radius), radius, arguments)
                    },
                    Rectangle: function () {
                        var rect = Rectangle.readNamed(arguments, "rectangle"),
                            radius = Size.min(Size.readNamed(arguments, "radius"), rect.getSize(!0).divide(2));
                        return createShape("rectangle", rect.getCenter(!0), rect.getSize(!0), radius, arguments)
                    },
                    Ellipse: function () {
                        var ellipse = Shape._readEllipse(arguments),
                            radius = ellipse.radius;
                        return createShape("ellipse", ellipse.center, radius.multiply(2), radius, arguments)
                    },
                    _readEllipse: function (args) {
                        var center, radius;
                        if (Base.hasNamed(args, "radius")) center = Point.readNamed(args, "center"), radius = Size.readNamed(args, "radius");
                        else {
                            var rect = Rectangle.readNamed(args, "rectangle");
                            center = rect.getCenter(!0), radius = rect.getSize(!0).divide(2)
                        }
                        return {
                            center: center,
                            radius: radius
                        }
                    }
                }
            }
        }),
        Raster = Item.extend({
            _class: "Raster",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _boundsGetter: "getBounds",
            _boundsSelected: !0,
            _serializeFields: {
                source: null
            },
            initialize: function (object, position) {
                this._initialize(object, position !== undefined && Point.read(arguments, 1)) || ("string" == typeof object ? this.setSource(object) : this.setImage(object)), this._size || (this._size = new Size)
            },
            _equals: function (item) {
                return this.getSource() === item.getSource()
            },
            clone: function (insert) {
                var copy = new Raster(Item.NO_INSERT),
                    image = this._image,
                    canvas = this._canvas;
                if (image) copy.setImage(image);
                else if (canvas) {
                    var copyCanvas = CanvasProvider.getCanvas(this._size);
                    copyCanvas.getContext("2d").drawImage(canvas, 0, 0), copy.setCanvas(copyCanvas)
                }
                return this._clone(copy, insert)
            },
            getSize: function () {
                var size = this._size;
                return new LinkedSize(size.width, size.height, this, "setSize")
            },
            setSize: function () {
                var size = Size.read(arguments);
                if (!this._size.equals(size)) {
                    var element = this.getElement();
                    this.setCanvas(CanvasProvider.getCanvas(size)), element && this.getContext(!0).drawImage(element, 0, 0, size.width, size.height)
                }
            },
            getWidth: function () {
                return this._size.width
            },
            getHeight: function () {
                return this._size.height
            },
            isEmpty: function () {
                return 0 == this._size.width && 0 == this._size.height
            },
            getPpi: function () {
                var matrix = this._matrix,
                    orig = new Point(0, 0).transform(matrix),
                    u = new Point(1, 0).transform(matrix).subtract(orig),
                    v = new Point(0, 1).transform(matrix).subtract(orig);
                return new Size(72 / u.getLength(), 72 / v.getLength())
            },
            getImage: function () {
                return this._image
            },
            setImage: function (image) {
                this._canvas && CanvasProvider.release(this._canvas), image.getContext ? (this._image = null, this._canvas = image) : (this._image = image, this._canvas = null), this._size = new Size(image.naturalWidth || image.width, image.naturalHeight || image.height), this._context = null, this._changed(521)
            },
            getCanvas: function () {
                if (!this._canvas) {
                    var ctx = CanvasProvider.getContext(this._size);
                    try {
                        this._image && ctx.drawImage(this._image, 0, 0), this._canvas = ctx.canvas
                    } catch (e) {
                        CanvasProvider.release(ctx)
                    }
                }
                return this._canvas
            },
            setCanvas: "#setImage",
            getContext: function (modify) {
                return this._context || (this._context = this.getCanvas().getContext("2d")), modify && (this._image = null, this._changed(513)), this._context
            },
            setContext: function (context) {
                this._context = context
            },
            getSource: function () {
                return this._image && this._image.src || this.toDataURL()
            },
            setSource: function (src) {
                function loaded() {
                    var view = that.getView();
                    view && (paper = view._scope, that.setImage(image), that.fire("load"), view.update())
                }
                var image, that = this;
                image = document.getElementById(src) || new Image, image.naturalWidth && image.naturalHeight ? setTimeout(loaded, 0) : (DomEvent.add(image, {
                    load: loaded
                }), image.src || (image.src = src)), this.setImage(image)
            },
            getElement: function () {
                return this._canvas || this._image
            },
            getSubCanvas: function (rect) {
                var rect = Rectangle.read(arguments),
                    ctx = CanvasProvider.getContext(rect.getSize());
                return ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height), ctx.canvas
            },
            getSubRaster: function (rect) {
                var rect = Rectangle.read(arguments),
                    raster = new Raster(Item.NO_INSERT);
                return raster.setCanvas(this.getSubCanvas(rect)), raster.translate(rect.getCenter().subtract(this.getSize().divide(2))), raster._matrix.preConcatenate(this._matrix), raster.insertAbove(this), raster
            },
            toDataURL: function () {
                var src = this._image && this._image.src;
                if (/^data:/.test(src)) return src;
                var canvas = this.getCanvas();
                return canvas ? canvas.toDataURL() : null
            },
            drawImage: function (image) {
                var point = Point.read(arguments, 1);
                this.getContext(!0).drawImage(image, point.x, point.y)
            },
            getAverageColor: function (object) {
                var bounds, path;
                object ? object instanceof PathItem ? (path = object, bounds = object.getBounds()) : object.width ? bounds = new Rectangle(object) : object.x && (bounds = new Rectangle(object.x - .5, object.y - .5, 1, 1)) : bounds = this.getBounds();
                var sampleSize = 32,
                    width = Math.min(bounds.width, sampleSize),
                    height = Math.min(bounds.height, sampleSize),
                    ctx = Raster._sampleContext;
                ctx ? ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1) : ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize)), ctx.save();
                var matrix = (new Matrix).scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
                matrix.applyToContext(ctx), path && path.draw(ctx, new Base({
                    clip: !0,
                    transforms: [matrix]
                })), this._matrix.applyToContext(ctx), ctx.drawImage(this.getElement(), -this._size.width / 2, -this._size.height / 2), ctx.restore();
                for (var pixels = ctx.getImageData(.5, .5, Math.ceil(width), Math.ceil(height)).data, channels = [0, 0, 0], total = 0, i = 0, l = pixels.length; l > i; i += 4) {
                    var alpha = pixels[i + 3];
                    total += alpha, alpha /= 255, channels[0] += pixels[i] * alpha, channels[1] += pixels[i + 1] * alpha, channels[2] += pixels[i + 2] * alpha
                }
                for (var i = 0; 3 > i; i++) channels[i] /= total;
                return total ? Color.read(channels) : null
            },
            getPixel: function (point) {
                var point = Point.read(arguments),
                    data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
                return new Color("rgb", [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255)
            },
            setPixel: function () {
                var point = Point.read(arguments),
                    color = Color.read(arguments),
                    components = color._convert("rgb"),
                    alpha = color._alpha,
                    ctx = this.getContext(!0),
                    imageData = ctx.createImageData(1, 1),
                    data = imageData.data;
                data[0] = 255 * components[0], data[1] = 255 * components[1], data[2] = 255 * components[2], data[3] = null != alpha ? 255 * alpha : 255, ctx.putImageData(imageData, point.x, point.y)
            },
            createImageData: function () {
                var size = Size.read(arguments);
                return this.getContext().createImageData(size.width, size.height)
            },
            getImageData: function (rect) {
                var rect = Rectangle.read(arguments);
                return rect.isEmpty() && (rect = new Rectangle(this._size)), this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height)
            },
            setImageData: function (data) {
                var point = Point.read(arguments, 1);
                this.getContext(!0).putImageData(data, point.x, point.y)
            },
            _getBounds: function (getter, matrix) {
                var rect = new Rectangle(this._size).setCenter(0, 0);
                return matrix ? matrix._transformBounds(rect) : rect
            },
            _hitTest: function (point) {
                if (this._contains(point)) {
                    var that = this;
                    return new HitResult("pixel", that, {
                        offset: point.add(that._size.divide(2)).round(),
                        color: {
                            get: function () {
                                return that.getPixel(this.offset)
                            }
                        }
                    })
                }
            },
            _draw: function (ctx) {
                var element = this.getElement();
                element && (ctx.globalAlpha = this._opacity, ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2))
            },
            _canComposite: function () {
                return !0
            }
        }),
        PlacedSymbol = Item.extend({
            _class: "PlacedSymbol",
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _boundsGetter: {
                getBounds: "getStrokeBounds"
            },
            _boundsSelected: !0,
            _serializeFields: {
                symbol: null
            },
            initialize: function (arg0, arg1) {
                this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1)) || this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0))
            },
            _equals: function (item) {
                return this._symbol === item._symbol
            },
            getSymbol: function () {
                return this._symbol
            },
            setSymbol: function (symbol) {
                this._symbol = symbol, this._changed(9)
            },
            clone: function (insert) {
                var copy = new PlacedSymbol(Item.NO_INSERT);
                return copy.setSymbol(this._symbol), this._clone(copy, insert)
            },
            isEmpty: function () {
                return this._symbol._definition.isEmpty()
            },
            _getBounds: function (getter, matrix, cacheItem) {
                return this.symbol._definition._getCachedBounds(getter, matrix, cacheItem)
            },
            _hitTest: function (point, options) {
                var res = this._symbol._definition.hitTest(point, options);
                return res && (res.item = this), res
            },
            _draw: function (ctx, param) {
                this.symbol._definition.draw(ctx, param)
            }
        }),
        HitResult = Base.extend({
            _class: "HitResult",
            initialize: function (type, item, values) {
                this.type = type, this.item = item, values && (values.enumerable = !0, this.inject(values))
            },
            statics: {
                getOptions: function (options) {
                    return options && options._merged ? options : new Base({
                        type: null,
                        tolerance: paper.settings.hitTolerance,
                        fill: !options,
                        stroke: !options,
                        segments: !options,
                        handles: !1,
                        ends: !1,
                        center: !1,
                        bounds: !1,
                        guides: !1,
                        selected: !1,
                        _merged: !0
                    }, options)
                }
            }
        }),
        Segment = Base.extend({
            _class: "Segment",
            beans: !0,
            initialize: function (arg0, arg1, arg2, arg3, arg4, arg5) {
                var point, handleIn, handleOut, count = arguments.length;
                0 === count || (1 === count ? arg0.point ? (point = arg0.point, handleIn = arg0.handleIn, handleOut = arg0.handleOut) : point = arg0 : 2 === count && "number" == typeof arg0 ? point = arguments : 3 >= count ? (point = arg0, handleIn = arg1, handleOut = arg2) : (point = arg0 !== undefined ? [arg0, arg1] : null, handleIn = arg2 !== undefined ? [arg2, arg3] : null, handleOut = arg4 !== undefined ? [arg4, arg5] : null)), new SegmentPoint(point, this, "_point"), new SegmentPoint(handleIn, this, "_handleIn"), new SegmentPoint(handleOut, this, "_handleOut")
            },
            _serialize: function (options) {
                return Base.serialize(this.isLinear() ? this._point : [this._point, this._handleIn, this._handleOut], options, !0)
            },
            _changed: function (point) {
                var path = this._path;
                if (path) {
                    var curveIn, curveOut, curves = path._curves,
                        index = this._index;
                    curves && (point && point !== this._point && point !== this._handleIn || !(curveIn = curves[index - 1] || path._closed && curves[curves.length - 1]) || curveIn._changed(), point && point !== this._point && point !== this._handleOut || !(curveOut = curves[index]) || curveOut._changed()), path._changed(25)
                }
            },
            getPoint: function () {
                return this._point
            },
            setPoint: function () {
                var point = Point.read(arguments);
                this._point.set(point.x, point.y)
            },
            getHandleIn: function () {
                return this._handleIn
            },
            setHandleIn: function () {
                var point = Point.read(arguments);
                this._handleIn.set(point.x, point.y)
            },
            getHandleOut: function () {
                return this._handleOut
            },
            setHandleOut: function () {
                var point = Point.read(arguments);
                this._handleOut.set(point.x, point.y)
            },
            isLinear: function () {
                return this._handleIn.isZero() && this._handleOut.isZero()
            },
            setLinear: function () {
                this._handleIn.set(0, 0), this._handleOut.set(0, 0)
            },
            isColinear: function (segment) {
                var next1 = this.getNext(),
                    next2 = segment.getNext();
                return this._handleOut.isZero() && next1._handleIn.isZero() && segment._handleOut.isZero() && next2._handleIn.isZero() && next1._point.subtract(this._point).isColinear(next2._point.subtract(segment._point))
            },
            isOrthogonal: function () {
                var prev = this.getPrevious(),
                    next = this.getNext();
                return prev._handleOut.isZero() && this._handleIn.isZero() && this._handleOut.isZero() && next._handleIn.isZero() && this._point.subtract(prev._point).isOrthogonal(next._point.subtract(this._point))
            },
            isArc: function () {
                var next = this.getNext(),
                    handle1 = this._handleOut,
                    handle2 = next._handleIn,
                    kappa = .5522847498307936;
                if (handle1.isOrthogonal(handle2)) {
                    var from = this._point,
                        to = next._point,
                        corner = new Line(from, handle1, !0).intersect(new Line(to, handle2, !0), !0);
                    return corner && Numerical.isZero(handle1.getLength() / corner.subtract(from).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(to).getLength() - kappa)
                }
                return !1
            },
            _selectionState: 0,
            isSelected: function (_point) {
                var state = this._selectionState;
                return _point ? _point === this._point ? !!(4 & state) : _point === this._handleIn ? !!(1 & state) : _point === this._handleOut ? !!(2 & state) : !1 : !!(7 & state)
            },
            setSelected: function (selected, _point) {
                var path = this._path,
                    selected = !!selected,
                    state = this._selectionState,
                    oldState = state,
                    flag = _point ? _point === this._point ? 4 : _point === this._handleIn ? 1 : _point === this._handleOut ? 2 : 0 : 7;
                selected ? state |= flag : state &= ~flag, this._selectionState = state, path && state !== oldState && (path._updateSelection(this, oldState, state), path._changed(129))
            },
            getIndex: function () {
                return this._index !== undefined ? this._index : null
            },
            getPath: function () {
                return this._path || null
            },
            getCurve: function () {
                var path = this._path,
                    index = this._index;
                return path ? (index > 0 && !path._closed && index === path._segments.length - 1 && index--, path.getCurves()[index] || null) : null
            },
            getLocation: function () {
                var curve = this.getCurve();
                return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null
            },
            getNext: function () {
                var segments = this._path && this._path._segments;
                return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null
            },
            getPrevious: function () {
                var segments = this._path && this._path._segments;
                return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null
            },
            reverse: function () {
                return new Segment(this._point, this._handleOut, this._handleIn)
            },
            remove: function () {
                return this._path ? !!this._path.removeSegment(this._index) : !1
            },
            clone: function () {
                return new Segment(this._point, this._handleIn, this._handleOut)
            },
            equals: function (segment) {
                return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || !1
            },
            toString: function () {
                var parts = ["point: " + this._point];
                return this._handleIn.isZero() || parts.push("handleIn: " + this._handleIn), this._handleOut.isZero() || parts.push("handleOut: " + this._handleOut), "{ " + parts.join(", ") + " }"
            },
            transform: function (matrix) {
                this._transformCoordinates(matrix, new Array(6), !0), this._changed()
            },
            _transformCoordinates: function (matrix, coords, change) {
                var point = this._point,
                    handleIn = change && this._handleIn.isZero() ? null : this._handleIn,
                    handleOut = change && this._handleOut.isZero() ? null : this._handleOut,
                    x = point._x,
                    y = point._y,
                    i = 2;
                return coords[0] = x, coords[1] = y, handleIn && (coords[i++] = handleIn._x + x, coords[i++] = handleIn._y + y), handleOut && (coords[i++] = handleOut._x + x, coords[i++] = handleOut._y + y), matrix && (matrix._transformCoordinates(coords, 0, coords, 0, i / 2), x = coords[0], y = coords[1], change ? (point._x = x, point._y = y, i = 2, handleIn && (handleIn._x = coords[i++] - x, handleIn._y = coords[i++] - y), handleOut && (handleOut._x = coords[i++] - x, handleOut._y = coords[i++] - y)) : (handleIn || (coords[i++] = x, coords[i++] = y), handleOut || (coords[i++] = x, coords[i++] = y))), coords
            }
        }),
        SegmentPoint = Point.extend({
            initialize: function (point, owner, key) {
                var x, y, selected;
                if (point)
                    if ((x = point[0]) !== undefined) y = point[1];
                    else {
                        var pt = point;
                        (x = pt.x) === undefined && (pt = Point.read(arguments), x = pt.x), y = pt.y, selected = pt.selected
                    } else x = y = 0;
                this._x = x, this._y = y, this._owner = owner, owner[key] = this, selected && this.setSelected(!0)
            },
            set: function (x, y) {
                return this._x = x, this._y = y, this._owner._changed(this), this
            },
            _serialize: function (options) {
                var f = options.formatter,
                    x = f.number(this._x),
                    y = f.number(this._y);
                return this.isSelected() ? {
                    x: x,
                    y: y,
                    selected: !0
                } : [x, y]
            },
            getX: function () {
                return this._x
            },
            setX: function (x) {
                this._x = x, this._owner._changed(this)
            },
            getY: function () {
                return this._y
            },
            setY: function (y) {
                this._y = y, this._owner._changed(this)
            },
            isZero: function () {
                return Numerical.isZero(this._x) && Numerical.isZero(this._y)
            },
            setSelected: function (selected) {
                this._owner.setSelected(selected, this)
            },
            isSelected: function () {
                return this._owner.isSelected(this)
            }
        }),
        Curve = Base.extend({
            _class: "Curve",
            initialize: function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
                var count = arguments.length;
                if (3 === count) this._path = arg0, this._segment1 = arg1, this._segment2 = arg2;
                else if (0 === count) this._segment1 = new Segment, this._segment2 = new Segment;
                else if (1 === count) this._segment1 = new Segment(arg0.segment1), this._segment2 = new Segment(arg0.segment2);
                else if (2 === count) this._segment1 = new Segment(arg0), this._segment2 = new Segment(arg1);
                else {
                    var point1, handle1, handle2, point2;
                    4 === count ? (point1 = arg0, handle1 = arg1, handle2 = arg2, point2 = arg3) : 8 === count && (point1 = [arg0, arg1], point2 = [arg6, arg7], handle1 = [arg2 - arg0, arg3 - arg1], handle2 = [arg4 - arg6, arg5 - arg7]), this._segment1 = new Segment(point1, null, handle1), this._segment2 = new Segment(point2, handle2, null)
                }
            },
            _changed: function () {
                this._length = this._bounds = undefined
            },
            getPoint1: function () {
                return this._segment1._point
            },
            setPoint1: function () {
                var point = Point.read(arguments);
                this._segment1._point.set(point.x, point.y)
            },
            getPoint2: function () {
                return this._segment2._point
            },
            setPoint2: function () {
                var point = Point.read(arguments);
                this._segment2._point.set(point.x, point.y)
            },
            getHandle1: function () {
                return this._segment1._handleOut
            },
            setHandle1: function () {
                var point = Point.read(arguments);
                this._segment1._handleOut.set(point.x, point.y)
            },
            getHandle2: function () {
                return this._segment2._handleIn
            },
            setHandle2: function () {
                var point = Point.read(arguments);
                this._segment2._handleIn.set(point.x, point.y)
            },
            getSegment1: function () {
                return this._segment1
            },
            getSegment2: function () {
                return this._segment2
            },
            getPath: function () {
                return this._path
            },
            getIndex: function () {
                return this._segment1._index
            },
            getNext: function () {
                var curves = this._path && this._path._curves;
                return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null
            },
            getPrevious: function () {
                var curves = this._path && this._path._curves;
                return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null
            },
            isSelected: function () {
                return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected()
            },
            setSelected: function (selected) {
                this.getPoint1().setSelected(selected), this.getHandle1().setSelected(selected), this.getHandle2().setSelected(selected), this.getPoint2().setSelected(selected)
            },
            getValues: function (matrix) {
                return Curve.getValues(this._segment1, this._segment2, matrix)
            },
            getPoints: function () {
                for (var coords = this.getValues(), points = [], i = 0; 8 > i; i += 2) points.push(new Point(coords[i], coords[i + 1]));
                return points
            },
            getLength: function () {
                return null == this._length && (this._length = this.isLinear() ? this._segment2._point.getDistance(this._segment1._point) : Curve.getLength(this.getValues(), 0, 1)), this._length
            },
            getArea: function () {
                return Curve.getArea(this.getValues())
            },
            getPart: function (from, to) {
                return new Curve(Curve.getPart(this.getValues(), from, to))
            },
            getPartLength: function (from, to) {
                return Curve.getLength(this.getValues(), from, to)
            },
            isLinear: function () {
                return this._segment1._handleOut.isZero() && this._segment2._handleIn.isZero()
            },
            isHorizontal: function () {
                return this.isLinear() && Numerical.isZero(this._segment1._point._y - this._segment2._point._y)
            },
            getIntersections: function (curve) {
                return Curve.getIntersections(this.getValues(), curve.getValues(), this, curve, [])
            },
            _getParameter: function (offset, isParameter) {
                return isParameter ? offset : offset && offset.curve === this ? offset.parameter : offset === undefined && isParameter === undefined ? .5 : this.getParameterAt(offset, 0)
            },
            divide: function (offset, isParameter, ignoreLinear) {
                var parameter = this._getParameter(offset, isParameter),
                    tolerance = 1e-5,
                    res = null;
                if (parameter > tolerance && 1 - tolerance > parameter) {
                    var parts = Curve.subdivide(this.getValues(), parameter),
                        isLinear = ignoreLinear ? !1 : this.isLinear(),
                        left = parts[0],
                        right = parts[1];
                    isLinear || (this._segment1._handleOut.set(left[2] - left[0], left[3] - left[1]), this._segment2._handleIn.set(right[4] - right[6], right[5] - right[7]));
                    var x = left[6],
                        y = left[7],
                        segment = new Segment(new Point(x, y), !isLinear && new Point(left[4] - x, left[5] - y), !isLinear && new Point(right[2] - x, right[3] - y));
                    if (this._path) this._segment1._index > 0 && 0 === this._segment2._index ? this._path.add(segment) : this._path.insert(this._segment2._index, segment), res = this;
                    else {
                        var end = this._segment2;
                        this._segment2 = segment, res = new Curve(segment, end)
                    }
                }
                return res
            },
            split: function (offset, isParameter) {
                return this._path ? this._path.split(this._segment1._index, this._getParameter(offset, isParameter)) : null
            },
            reverse: function () {
                return new Curve(this._segment2.reverse(), this._segment1.reverse())
            },
            remove: function () {
                var removed = !1;
                if (this._path) {
                    var segment2 = this._segment2,
                        handleOut = segment2._handleOut;
                    removed = segment2.remove(), removed && this._segment1._handleOut.set(handleOut.x, handleOut.y)
                }
                return removed
            },
            clone: function () {
                return new Curve(this._segment1, this._segment2)
            },
            toString: function () {
                var parts = ["point1: " + this._segment1._point];
                return this._segment1._handleOut.isZero() || parts.push("handle1: " + this._segment1._handleOut), this._segment2._handleIn.isZero() || parts.push("handle2: " + this._segment2._handleIn), parts.push("point2: " + this._segment2._point), "{ " + parts.join(", ") + " }"
            },
            statics: {
                getValues: function (segment1, segment2, matrix) {
                    var p1 = segment1._point,
                        h1 = segment1._handleOut,
                        h2 = segment2._handleIn,
                        p2 = segment2._point,
                        values = [p1._x, p1._y, p1._x + h1._x, p1._y + h1._y, p2._x + h2._x, p2._y + h2._y, p2._x, p2._y];
                    return matrix && matrix._transformCoordinates(values, 0, values, 0, 6), values
                },
                evaluate: function (v, t, type) {
                    var x, y, p1x = v[0],
                        p1y = v[1],
                        c1x = v[2],
                        c1y = v[3],
                        c2x = v[4],
                        c2y = v[5],
                        p2x = v[6],
                        p2y = v[7],
                        tolerance = 1e-5;
                    if (0 === type && (tolerance > t || t > 1 - tolerance)) {
                        var isZero = tolerance > t;
                        x = isZero ? p1x : p2x, y = isZero ? p1y : p2y
                    } else {
                        var cx = 3 * (c1x - p1x),
                            bx = 3 * (c2x - c1x) - cx,
                            ax = p2x - p1x - cx - bx,
                            cy = 3 * (c1y - p1y),
                            by = 3 * (c2y - c1y) - cy,
                            ay = p2y - p1y - cy - by;
                        if (0 === type) x = ((ax * t + bx) * t + cx) * t + p1x, y = ((ay * t + by) * t + cy) * t + p1y;
                        else if (tolerance > t && c1x === p1x && c1y === p1y || t > 1 - tolerance && c2x === p2x && c2y === p2y ? (x = p2x - p1x, y = p2y - p1y) : tolerance > t ? (x = cx, y = cy) : t > 1 - tolerance ? (x = 3 * (p2x - c2x), y = 3 * (p2y - c2y)) : (x = (3 * ax * t + 2 * bx) * t + cx, y = (3 * ay * t + 2 * by) * t + cy), 3 === type) {
                            var x2 = 6 * ax * t + 2 * bx,
                                y2 = 6 * ay * t + 2 * by;
                            return (x * y2 - y * x2) / Math.pow(x * x + y * y, 1.5)
                        }
                    }
                    return 2 === type ? new Point(y, -x) : new Point(x, y)
                },
                subdivide: function (v, t) {
                    var p1x = v[0],
                        p1y = v[1],
                        c1x = v[2],
                        c1y = v[3],
                        c2x = v[4],
                        c2y = v[5],
                        p2x = v[6],
                        p2y = v[7];
                    t === undefined && (t = .5);
                    var u = 1 - t,
                        p3x = u * p1x + t * c1x,
                        p3y = u * p1y + t * c1y,
                        p4x = u * c1x + t * c2x,
                        p4y = u * c1y + t * c2y,
                        p5x = u * c2x + t * p2x,
                        p5y = u * c2y + t * p2y,
                        p6x = u * p3x + t * p4x,
                        p6y = u * p3y + t * p4y,
                        p7x = u * p4x + t * p5x,
                        p7y = u * p4y + t * p5y,
                        p8x = u * p6x + t * p7x,
                        p8y = u * p6y + t * p7y;
                    return [
                        [p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
                        [p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
                    ]
                },
                solveCubic: function (v, coord, val, roots, min, max) {
                    var p1 = v[coord],
                        c1 = v[coord + 2],
                        c2 = v[coord + 4],
                        p2 = v[coord + 6],
                        c = 3 * (c1 - p1),
                        b = 3 * (c2 - c1) - c,
                        a = p2 - p1 - c - b;
                    return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max)
                },
                getParameterOf: function (v, x, y) {
                    var tolerance = 1e-5;
                    if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance) return 0;
                    if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance) return 1;
                    for (var tx, ty, txs = [], tys = [], sx = Curve.solveCubic(v, 0, x, txs), sy = Curve.solveCubic(v, 1, y, tys), cx = 0; - 1 == sx || sx > cx;)
                        if (-1 == sx || (tx = txs[cx++]) >= 0 && 1 >= tx) {
                            for (var cy = 0; - 1 == sy || sy > cy;)
                                if ((-1 == sy || (ty = tys[cy++]) >= 0 && 1 >= ty) && (-1 == sx ? tx = ty : -1 == sy && (ty = tx), Math.abs(tx - ty) < tolerance)) return .5 * (tx + ty);
                            if (-1 == sx) break
                        }
                    return null
                },
                getPart: function (v, from, to) {
                    return from > 0 && (v = Curve.subdivide(v, from)[1]), 1 > to && (v = Curve.subdivide(v, (to - from) / (1 - from))[0]), v
                },
                isLinear: function (v) {
                    var isZero = Numerical.isZero;
                    return isZero(v[0] - v[2]) && isZero(v[1] - v[3]) && isZero(v[4] - v[6]) && isZero(v[5] - v[7])
                },
                isFlatEnough: function (v, tolerance) {
                    var p1x = v[0],
                        p1y = v[1],
                        c1x = v[2],
                        c1y = v[3],
                        c2x = v[4],
                        c2y = v[5],
                        p2x = v[6],
                        p2y = v[7],
                        ux = 3 * c1x - 2 * p1x - p2x,
                        uy = 3 * c1y - 2 * p1y - p2y,
                        vx = 3 * c2x - 2 * p2x - p1x,
                        vy = 3 * c2y - 2 * p2y - p1y;
                    return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) < 10 * tolerance * tolerance
                },
                getArea: function (v) {
                    var p1x = v[0],
                        p1y = v[1],
                        c1x = v[2],
                        c1y = v[3],
                        c2x = v[4],
                        c2y = v[5],
                        p2x = v[6],
                        p2y = v[7];
                    return (3 * c1y * p1x - 1.5 * c1y * c2x - 1.5 * c1y * p2x - 3 * p1y * c1x - 1.5 * p1y * c2x - .5 * p1y * p2x + 1.5 * c2y * p1x + 1.5 * c2y * c1x - 3 * c2y * p2x + .5 * p2y * p1x + 1.5 * p2y * c1x + 3 * p2y * c2x) / 10
                },
                getBounds: function (v) {
                    for (var min = v.slice(0, 2), max = min.slice(), roots = [0, 0], i = 0; 2 > i; i++) Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);
                    return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1])
                },
                _addBounds: function (v0, v1, v2, v3, coord, padding, min, max, roots) {
                    function add(value, padding) {
                        var left = value - padding,
                            right = value + padding;
                        left < min[coord] && (min[coord] = left), right > max[coord] && (max[coord] = right)
                    }
                    var a = 3 * (v1 - v2) - v0 + v3,
                        b = 2 * (v0 + v2) - 4 * v1,
                        c = v1 - v0,
                        count = Numerical.solveQuadratic(a, b, c, roots),
                        tMin = 1e-5,
                        tMax = 1 - tMin;
                    add(v3, 0);
                    for (var i = 0; count > i; i++) {
                        var t = roots[i],
                            u = 1 - t;
                        t > tMin && tMax > t && add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding)
                    }
                }
            }
        }, Base.each(["getBounds", "getStrokeBounds", "getHandleBounds", "getRoughBounds"], function (name) {
            this[name] = function () {
                this._bounds || (this._bounds = {});
                var bounds = this._bounds[name];
                return bounds || (bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], !1, this._path.getStyle())), bounds.clone()
            }
        }, {}), Base.each(["getPoint", "getTangent", "getNormal", "getCurvature"], function (name, index) {
            this[name + "At"] = function (offset, isParameter) {
                var values = this.getValues();
                return Curve.evaluate(values, isParameter ? offset : Curve.getParameterAt(values, offset, 0), index)
            }, this[name] = function (parameter) {
                return Curve.evaluate(this.getValues(), parameter, index)
            }
        }, {
            getParameterAt: function (offset, start) {
                return Curve.getParameterAt(this.getValues(), offset, start !== undefined ? start : 0 > offset ? 1 : 0)
            },
            getParameterOf: function (point) {
                var point = Point.read(arguments);
                return Curve.getParameterOf(this.getValues(), point.x, point.y)
            },
            getLocationAt: function (offset, isParameter) {
                return isParameter || (offset = this.getParameterAt(offset)), new CurveLocation(this, offset)
            },
            getLocationOf: function (point) {
                var point = Point.read(arguments),
                    t = this.getParameterOf(point);
                return null != t ? new CurveLocation(this, t) : null
            },
            getNearestLocation: function (point) {
                function refine(t) {
                    if (t >= 0 && 1 >= t) {
                        var dist = point.getDistance(Curve.evaluate(values, t, 0), !0);
                        if (minDist > dist) return minDist = dist, minT = t, !0
                    }
                }
                for (var point = Point.read(arguments), values = this.getValues(), count = 100, minDist = 1 / 0, minT = 0, i = 0; count >= i; i++) refine(i / count);
                for (var step = 1 / (2 * count); step > 1e-5;) refine(minT - step) || refine(minT + step) || (step /= 2);
                var pt = Curve.evaluate(values, minT, 0);
                return new CurveLocation(this, minT, pt, null, null, null, point.getDistance(pt))
            },
            getNearestPoint: function (point) {
                var point = Point.read(arguments);
                return this.getNearestLocation(point).getPoint()
            }
        }), new function () {
            function getLengthIntegrand(v) {
                var p1x = v[0],
                    p1y = v[1],
                    c1x = v[2],
                    c1y = v[3],
                    c2x = v[4],
                    c2y = v[5],
                    p2x = v[6],
                    p2y = v[7],
                    ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
                    bx = 6 * (p1x + c2x) - 12 * c1x,
                    cx = 3 * (c1x - p1x),
                    ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
                    by = 6 * (p1y + c2y) - 12 * c1y,
                    cy = 3 * (c1y - p1y);
                return function (t) {
                    var dx = (ax * t + bx) * t + cx,
                        dy = (ay * t + by) * t + cy;
                    return Math.sqrt(dx * dx + dy * dy)
                }
            }

            function getIterations(a, b) {
                return Math.max(2, Math.min(16, Math.ceil(32 * Math.abs(b - a))))
            }
            return {
                statics: !0,
                getLength: function (v, a, b) {
                    a === undefined && (a = 0), b === undefined && (b = 1);
                    var isZero = Numerical.isZero;
                    if (0 === a && 1 === b && isZero(v[0] - v[2]) && isZero(v[1] - v[3]) && isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
                        var dx = v[6] - v[0],
                            dy = v[7] - v[1];
                        return Math.sqrt(dx * dx + dy * dy)
                    }
                    var ds = getLengthIntegrand(v);
                    return Numerical.integrate(ds, a, b, getIterations(a, b))
                },
                getParameterAt: function (v, offset, start) {
                    function f(t) {
                        var count = getIterations(start, t);
                        return length += t > start ? Numerical.integrate(ds, start, t, count) : -Numerical.integrate(ds, t, start, count), start = t, length - offset
                    }
                    if (0 === offset) return start;
                    var forward = offset > 0,
                        a = forward ? start : 0,
                        b = forward ? 1 : start,
                        offset = Math.abs(offset),
                        ds = getLengthIntegrand(v),
                        rangeLength = Numerical.integrate(ds, a, b, getIterations(a, b));
                    if (offset >= rangeLength) return forward ? b : a;
                    var guess = offset / rangeLength,
                        length = 0;
                    return Numerical.findRoot(f, ds, forward ? a + guess : b - guess, a, b, 16, 1e-5)
                }
            }
        }, new function () {
            function addLocation(locations, include, curve1, t1, point1, curve2, t2, point2) {
                var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
                (!include || include(loc)) && locations.push(loc)
            }

            function addCurveIntersections(v1, v2, curve1, curve2, locations, include, tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
                if (!(recursion > 20)) {
                    var tMinNew, tMaxNew, tDiff, q0x = v2[0],
                        q0y = v2[1],
                        q3x = v2[6],
                        q3y = v2[7],
                        tolerance = 1e-5,
                        hullEpsilon = 1e-9,
                        getSignedDistance = Line.getSignedDistance,
                        d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
                        d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
                        factor = d1 * d2 > 0 ? .75 : 4 / 9,
                        dMin = factor * Math.min(0, d1, d2),
                        dMax = factor * Math.max(0, d1, d2),
                        dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
                        dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
                        dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
                        dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]);
                    if (q0x === q3x && hullEpsilon >= uMax - uMin && recursion > 3) tMinNew = (tMax + tMin) / 2, tMaxNew = tMinNew, tDiff = 0;
                    else {
                        var tMinClip, tMaxClip, hull = getConvexHull(dp0, dp1, dp2, dp3),
                            top = hull[0],
                            bottom = hull[1];
                        if (tMinClip = clipConvexHull(top, bottom, dMin, dMax), top.reverse(), bottom.reverse(), tMaxClip = clipConvexHull(top, bottom, dMin, dMax), null == tMinClip || null == tMaxClip) return !1;
                        v1 = Curve.getPart(v1, tMinClip, tMaxClip), tDiff = tMaxClip - tMinClip, tMinNew = tMax * tMinClip + tMin * (1 - tMinClip), tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip)
                    } if (oldTDiff > .8 && tDiff > .8)
                        if (tMaxNew - tMinNew > uMax - uMin) {
                            var parts = Curve.subdivide(v1, .5),
                                t = tMinNew + (tMaxNew - tMinNew) / 2;
                            addCurveIntersections(v2, parts[0], curve2, curve1, locations, include, uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion), addCurveIntersections(v2, parts[1], curve2, curve1, locations, include, uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion)
                        } else {
                            var parts = Curve.subdivide(v2, .5),
                                t = uMin + (uMax - uMin) / 2;
                            addCurveIntersections(parts[0], v1, curve2, curve1, locations, include, uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion), addCurveIntersections(parts[1], v1, curve2, curve1, locations, include, t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion)
                        } else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
                        var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
                            t2 = uMin + (uMax - uMin) / 2;
                        reverse ? addLocation(locations, include, curve2, t2, Curve.evaluate(v2, t2, 0), curve1, t1, Curve.evaluate(v1, t1, 0)) : addLocation(locations, include, curve1, t1, Curve.evaluate(v1, t1, 0), curve2, t2, Curve.evaluate(v2, t2, 0))
                    } else addCurveIntersections(v2, v1, curve2, curve1, locations, include, uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion)
                }
            }

            function getConvexHull(dq0, dq1, dq2, dq3) {
                var hull, p0 = [0, dq0],
                    p1 = [1 / 3, dq1],
                    p2 = [2 / 3, dq2],
                    p3 = [1, dq3],
                    getSignedDistance = Line.getSignedDistance,
                    dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
                    dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
                    flip = !1;
                if (0 > dist1 * dist2) hull = [
                    [p0, p1, p3],
                    [p0, p2, p3]
                ], flip = 0 > dist1;
                else {
                    var pmax, cross = 0,
                        distZero = 0 === dist1 || 0 === dist2;
                    Math.abs(dist1) > Math.abs(dist2) ? (pmax = p1, cross = (dq3 - dq2 - (dq3 - dq0) / 3) * (2 * (dq3 - dq2) - dq3 + dq1) / 3) : (pmax = p2, cross = (dq1 - dq0 + (dq0 - dq3) / 3) * (-2 * (dq0 - dq1) + dq0 - dq2) / 3), hull = 0 > cross || distZero ? [
                        [p0, pmax, p3],
                        [p0, p3]
                    ] : [
                        [p0, p1, p2, p3],
                        [p0, p3]
                    ], flip = dist1 ? 0 > dist1 : 0 > dist2
                }
                return flip ? hull.reverse() : hull
            }

            function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
                for (var tProxy, px, py, qx, qy, tVal = null, i = 0, l = hullBottom.length - 1; l > i; i++) {
                    if (py = hullBottom[i][1], qy = hullBottom[i + 1][1], qy > py) tProxy = null;
                    else {
                        if (!(dMax >= qy)) continue;
                        px = hullBottom[i][0], qx = hullBottom[i + 1][0], tProxy = px + (dMax - py) * (qx - px) / (qy - py)
                    }
                    break
                }
                hullTop[0][1] <= dMax && (tProxy = hullTop[0][0]);
                for (var i = 0, l = hullTop.length - 1; l > i; i++) {
                    if (py = hullTop[i][1], qy = hullTop[i + 1][1], py >= dMin) tVal = tProxy;
                    else if (py > qy) tVal = null;
                    else {
                        if (!(qy >= dMin)) continue;
                        px = hullTop[i][0], qx = hullTop[i + 1][0], tVal = px + (dMin - py) * (qx - px) / (qy - py)
                    }
                    break
                }
                return tVal
            }

            function addCurveLineIntersections(v1, v2, curve1, curve2, locations, include) {
                for (var flip = Curve.isLinear(v1), vc = flip ? v2 : v1, vl = flip ? v1 : v2, lx1 = vl[0], ly1 = vl[1], lx2 = vl[6], ly2 = vl[7], ldx = lx2 - lx1, ldy = ly2 - ly1, angle = Math.atan2(-ldy, ldx), sin = Math.sin(angle), cos = Math.cos(angle), rlx2 = ldx * cos - ldy * sin, rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0], rvc = [], i = 0; 8 > i; i += 2) {
                    var x = vc[i] - lx1,
                        y = vc[i + 1] - ly1;
                    rvc.push(x * cos - y * sin, y * cos + x * sin)
                }
                for (var roots = [], count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1), i = 0; count > i; i++) {
                    var tc = roots[i],
                        x = Curve.evaluate(rvc, tc, 0).x;
                    if (x >= 0 && rlx2 >= x) {
                        var tl = Curve.getParameterOf(rvl, x, 0),
                            t1 = flip ? tl : tc,
                            t2 = flip ? tc : tl;
                        addLocation(locations, include, curve1, t1, Curve.evaluate(v1, t1, 0), curve2, t2, Curve.evaluate(v2, t2, 0))
                    }
                }
            }

            function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
                var point = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);
                if (point) {
                    var x = point.x,
                        y = point.y;
                    addLocation(locations, include, curve1, Curve.getParameterOf(v1, x, y), point, curve2, Curve.getParameterOf(v2, x, y), point)
                }
            }
            return {
                statics: {
                    getIntersections: function (v1, v2, curve1, curve2, locations, include) {
                        var linear1 = Curve.isLinear(v1),
                            linear2 = Curve.isLinear(v2);
                        return (linear1 && linear2 ? addLineIntersection : linear1 || linear2 ? addCurveLineIntersections : addCurveIntersections)(v1, v2, curve1, curve2, locations, include, 0, 1, 0, 1, 0, !1, 0), locations
                    }
                }
            }
        }),
        CurveLocation = Base.extend({
            _class: "CurveLocation",
            beans: !0,
            initialize: function CurveLocation(curve, parameter, point, _curve2, _parameter2, _point2, _distance) {
                this._id = CurveLocation._id = (CurveLocation._id || 0) + 1, this._curve = curve, this._segment1 = curve._segment1, this._segment2 = curve._segment2, this._parameter = parameter, this._point = point, this._curve2 = _curve2, this._parameter2 = _parameter2, this._point2 = _point2, this._distance = _distance
            },
            getSegment: function (_preferFirst) {
                if (!this._segment) {
                    var curve = this.getCurve(),
                        parameter = this.getParameter();
                    if (1 === parameter) this._segment = curve._segment2;
                    else if (0 === parameter || _preferFirst) this._segment = curve._segment1;
                    else {
                        if (null == parameter) return null;
                        this._segment = curve.getPartLength(0, parameter) < curve.getPartLength(parameter, 1) ? curve._segment1 : curve._segment2
                    }
                }
                return this._segment
            },
            getCurve: function (_uncached) {
                return (!this._curve || _uncached) && (this._curve = this._segment1.getCurve(), null == this._curve.getParameterOf(this._point) && (this._curve = this._segment2.getPrevious().getCurve())), this._curve
            },
            getIntersection: function () {
                var intersection = this._intersection;
                if (!intersection && this._curve2) {
                    var param = this._parameter2;
                    this._intersection = intersection = new CurveLocation(this._curve2, param, this._point2 || this._point, this), intersection._intersection = this
                }
                return intersection
            },
            getPath: function () {
                var curve = this.getCurve();
                return curve && curve._path
            },
            getIndex: function () {
                var curve = this.getCurve();
                return curve && curve.getIndex()
            },
            getOffset: function () {
                var path = this.getPath();
                return path && path._getOffset(this)
            },
            getCurveOffset: function () {
                var curve = this.getCurve(),
                    parameter = this.getParameter();
                return null != parameter && curve && curve.getPartLength(0, parameter)
            },
            getParameter: function (_uncached) {
                if ((null == this._parameter || _uncached) && this._point) {
                    var curve = this.getCurve(_uncached && this._point);
                    this._parameter = curve && curve.getParameterOf(this._point)
                }
                return this._parameter
            },
            getPoint: function (_uncached) {
                if ((!this._point || _uncached) && null != this._parameter) {
                    var curve = this.getCurve();
                    this._point = curve && curve.getPointAt(this._parameter, !0)
                }
                return this._point
            },
            getTangent: function () {
                var parameter = this.getParameter(),
                    curve = this.getCurve();
                return null != parameter && curve && curve.getTangentAt(parameter, !0)
            },
            getNormal: function () {
                var parameter = this.getParameter(),
                    curve = this.getCurve();
                return null != parameter && curve && curve.getNormalAt(parameter, !0)
            },
            getDistance: function () {
                return this._distance
            },
            divide: function () {
                var curve = this.getCurve(!0);
                return curve && curve.divide(this.getParameter(!0), !0)
            },
            split: function () {
                var curve = this.getCurve(!0);
                return curve && curve.split(this.getParameter(!0), !0)
            },
            equals: function (loc) {
                var isZero = Numerical.isZero;
                return this === loc || loc && this._curve === loc._curve && this._curve2 === loc._curve2 && isZero(this._parameter - loc._parameter) && isZero(this._parameter2 - loc._parameter2) || !1
            },
            toString: function () {
                var parts = [],
                    point = this.getPoint(),
                    f = Formatter.instance;
                point && parts.push("point: " + point);
                var index = this.getIndex();
                null != index && parts.push("index: " + index);
                var parameter = this.getParameter();
                return null != parameter && parts.push("parameter: " + f.number(parameter)), null != this._distance && parts.push("distance: " + f.number(this._distance)), "{ " + parts.join(", ") + " }"
            }
        }),
        PathItem = Item.extend({
            _class: "PathItem",
            initialize: function () {},
            getIntersections: function (path, _expand) {
                function compare(loc1, loc2) {
                    var path1 = loc1.getPath(),
                        path2 = loc2.getPath();
                    return path1 === path2 ? loc1.getIndex() + loc1.getParameter() - (loc2.getIndex() + loc2.getParameter()) : path1._id - path2._id
                }
                if (this === path && (path = null), path && !this.getBounds().touches(path.getBounds())) return [];
                for (var locations = [], curves1 = this.getCurves(), curves2 = path ? path.getCurves() : curves1, matrix1 = this._matrix.orNullIfIdentity(), matrix2 = path ? path._matrix.orNullIfIdentity() : matrix1, length1 = curves1.length, length2 = path ? curves2.length : length1, values2 = [], MIN = 1e-11, MAX = 1 - 1e-11, i = 0; length2 > i; i++) values2[i] = curves2[i].getValues(matrix2);
                for (var i = 0; length1 > i; i++) {
                    var curve1 = curves1[i],
                        values1 = path ? curve1.getValues(matrix1) : values2[i];
                    if (!path) {
                        var seg1 = curve1.getSegment1(),
                            seg2 = curve1.getSegment2(),
                            h1 = seg1._handleOut,
                            h2 = seg2._handleIn;
                        if (new Line(seg1._point.subtract(h1), h1.multiply(2), !0).intersect(new Line(seg2._point.subtract(h2), h2.multiply(2), !0), !1)) {
                            var parts = Curve.subdivide(values1);
                            Curve.getIntersections(parts[0], parts[1], curve1, curve1, locations, function (loc) {
                                return loc._parameter <= MAX ? (loc._parameter /= 2, loc._parameter2 = .5 + loc._parameter2 / 2, !0) : void 0
                            })
                        }
                    }
                    for (var j = path ? 0 : i + 1; length2 > j; j++) Curve.getIntersections(values1, values2[j], curve1, curves2[j], locations, !path && (j === i + 1 || j === length2 - 1 && 0 === i) && function (loc) {
                        var t = loc._parameter;
                        return t >= MIN && MAX >= t
                    })
                }
                for (var last = locations.length - 1, i = last; i >= 0; i--) {
                    var loc = locations[i],
                        next = loc._curve.getNext(),
                        next2 = loc._curve2.getNext();
                    next && loc._parameter >= MAX && (loc._parameter = 0, loc._curve = next), next2 && loc._parameter2 >= MAX && (loc._parameter2 = 0, loc._curve2 = next2)
                }
                if (last > 0) {
                    locations.sort(compare);
                    for (var i = last; i >= 0; i--) locations[i].equals(locations[0 === i ? last : i - 1]) && (locations.splice(i, 1), last--)
                }
                if (_expand) {
                    for (var i = last; i >= 0; i--) locations.push(locations[i].getIntersection());
                    locations.sort(compare)
                }
                return locations
            },
            setPathData: function (data) {
                function getCoord(index, coord) {
                    var val = +coords[index];
                    return relative && (val += current[coord]), val
                }

                function getPoint(index) {
                    return new Point(getCoord(index, "x"), getCoord(index + 1, "y"))
                }
                var coords, previous, control, parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/gi),
                    relative = !1,
                    current = new Point,
                    start = new Point;
                this.clear();
                for (var i = 0, l = parts.length; l > i; i++) {
                    var part = parts[i],
                        command = part[0],
                        lower = command.toLowerCase();
                    coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
                    var length = coords && coords.length;
                    switch (relative = command === lower, "z" !== previous || /[mz]/.test(lower) || this.moveTo(current = start), lower) {
                    case "m":
                    case "l":
                        var move = "m" === lower;
                        move && previous && "z" !== previous && this.closePath(!0);
                        for (var j = 0; length > j; j += 2) this[0 === j && move ? "moveTo" : "lineTo"](current = getPoint(j));
                        control = current, move && (start = current);
                        break;
                    case "h":
                    case "v":
                        for (var coord = "h" === lower ? "x" : "y", j = 0; length > j; j++) current[coord] = getCoord(j, coord), this.lineTo(current);
                        control = current;
                        break;
                    case "c":
                        for (var j = 0; length > j; j += 6) this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
                        break;
                    case "s":
                        for (var j = 0; length > j; j += 4) this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2)), previous = lower;
                        break;
                    case "q":
                        for (var j = 0; length > j; j += 4) this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
                        break;
                    case "t":
                        for (var j = 0; length > j; j += 2) this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j)), previous = lower;
                        break;
                    case "a":
                        for (var j = 0; length > j; j += 7) this.arcTo(current = getPoint(j + 5), new Size(+coords[0], +coords[1]), +coords[2], +coords[4], +coords[3]);
                        break;
                    case "z":
                        this.closePath(!0)
                    }
                    previous = lower
                }
            },
            _canComposite: function () {
                return !(this.hasFill() && this.hasStroke())
            },
            _contains: function (point) {
                var winding = this._getWinding(point, !1, !0);
                return !!("evenodd" === this.getWindingRule() ? 1 & winding : winding)
            }
        }),
        Path = PathItem.extend({
            _class: "Path",
            _serializeFields: {
                segments: [],
                closed: !1
            },
            initialize: function (arg) {
                this._closed = !1, this._segments = [];
                var segments = Array.isArray(arg) ? "object" == typeof arg[0] ? arg : arguments : !arg || arg.size !== undefined || arg.x === undefined && arg.point === undefined ? null : arguments;
                segments && segments.length > 0 ? this.setSegments(segments) : (this._curves = undefined, this._selectedSegmentState = 0, segments || "string" != typeof arg || (this.setPathData(arg), arg = null)), this._initialize(!segments && arg)
            },
            _equals: function (item) {
                return Base.equals(this._segments, item._segments)
            },
            clone: function (insert) {
                var copy = new Path(Item.NO_INSERT);
                return copy.setSegments(this._segments), copy._closed = this._closed, this._clockwise !== undefined && (copy._clockwise = this._clockwise), this._clone(copy, insert)
            },
            _changed: function _changed(flags) {
                if (_changed.base.call(this, flags), 8 & flags) {
                    var parent = this._parent;
                    if (parent && (parent._currentPath = undefined), this._length = this._clockwise = undefined, this._curves && !(16 & flags))
                        for (var i = 0, l = this._curves.length; l > i; i++) this._curves[i]._changed();
                    this._monoCurves = undefined
                } else 32 & flags && (this._bounds = undefined)
            },
            getStyle: function () {
                var parent = this._parent;
                return (parent instanceof CompoundPath ? parent : this)._style
            },
            getSegments: function () {
                return this._segments
            },
            setSegments: function (segments) {
                var fullySelected = this.isFullySelected();
                this._segments.length = 0, this._selectedSegmentState = 0, this._curves = undefined, segments && segments.length > 0 && this._add(Segment.readAll(segments)), fullySelected && this.setFullySelected(!0)
            },
            getFirstSegment: function () {
                return this._segments[0]
            },
            getLastSegment: function () {
                return this._segments[this._segments.length - 1]
            },
            getCurves: function () {
                var curves = this._curves,
                    segments = this._segments;
                if (!curves) {
                    var length = this._countCurves();
                    curves = this._curves = new Array(length);
                    for (var i = 0; length > i; i++) curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0])
                }
                return curves
            },
            getFirstCurve: function () {
                return this.getCurves()[0]
            },
            getLastCurve: function () {
                var curves = this.getCurves();
                return curves[curves.length - 1]
            },
            isClosed: function () {
                return this._closed
            },
            setClosed: function (closed) {
                if (this._closed != (closed = !!closed)) {
                    if (this._closed = closed, this._curves) {
                        var length = this._curves.length = this._countCurves();
                        closed && (this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]))
                    }
                    this._changed(25)
                }
            }
        }, {
            beans: !0,
            getPathData: function (_precision) {
                function addCurve(seg1, seg2, skipLine) {
                    var point1 = seg1._point,
                        point2 = seg2._point,
                        handle1 = seg1._handleOut,
                        handle2 = seg2._handleIn;
                    if (handle1.isZero() && handle2.isZero()) skipLine || parts.push("L" + f.point(point2, _precision));
                    else {
                        var end = point2.subtract(point1);
                        parts.push("c" + f.point(handle1, _precision) + " " + f.point(end.add(handle2), _precision) + " " + f.point(end, _precision))
                    }
                }
                var segments = this._segments,
                    f = Formatter.instance,
                    parts = [];
                if (0 === segments.length) return "";
                parts.push("M" + f.point(segments[0]._point));
                for (var i = 0, l = segments.length - 1; l > i; i++) addCurve(segments[i], segments[i + 1], !1);
                return this._closed && (addCurve(segments[segments.length - 1], segments[0], !0), parts.push("z")), parts.join("")
            }
        }, {
            isEmpty: function () {
                return 0 === this._segments.length
            },
            isPolygon: function () {
                for (var i = 0, l = this._segments.length; l > i; i++)
                    if (!this._segments[i].isLinear()) return !1;
                return !0
            },
            _transformContent: function (matrix) {
                for (var coords = new Array(6), i = 0, l = this._segments.length; l > i; i++) this._segments[i]._transformCoordinates(matrix, coords, !0);
                return !0
            },
            _add: function (segs, index) {
                for (var segments = this._segments, curves = this._curves, amount = segs.length, append = null == index, index = append ? segments.length : index, i = 0; amount > i; i++) {
                    var segment = segs[i];
                    segment._path && (segment = segs[i] = segment.clone()), segment._path = this, segment._index = index + i, segment._selectionState && this._updateSelection(segment, 0, segment._selectionState)
                }
                if (append) segments.push.apply(segments, segs);
                else {
                    segments.splice.apply(segments, [index, 0].concat(segs));
                    for (var i = index + amount, l = segments.length; l > i; i++) segments[i]._index = i
                } if (curves || segs._curves) {
                    curves || (curves = this._curves = []);
                    var from = index > 0 ? index - 1 : index,
                        start = from,
                        to = Math.min(from + amount, this._countCurves());
                    segs._curves && (curves.splice.apply(curves, [from, 0].concat(segs._curves)), start += segs._curves.length);
                    for (var i = start; to > i; i++) curves.splice(i, 0, new Curve(this, null, null));
                    this._adjustCurves(from, to)
                }
                return this._changed(25), segs
            },
            _adjustCurves: function (from, to) {
                for (var curve, segments = this._segments, curves = this._curves, i = from; to > i; i++) curve = curves[i], curve._path = this, curve._segment1 = segments[i], curve._segment2 = segments[i + 1] || segments[0];
                (curve = curves[this._closed && 0 === from ? segments.length - 1 : from - 1]) && (curve._segment2 = segments[from] || segments[0]), (curve = curves[to]) && (curve._segment1 = segments[to])
            },
            _countCurves: function () {
                var length = this._segments.length;
                return !this._closed && length > 0 ? length - 1 : length
            },
            add: function (segment1) {
                return arguments.length > 1 && "number" != typeof segment1 ? this._add(Segment.readAll(arguments)) : this._add([Segment.read(arguments)])[0]
            },
            insert: function (index, segment1) {
                return arguments.length > 2 && "number" != typeof segment1 ? this._add(Segment.readAll(arguments, 1), index) : this._add([Segment.read(arguments, 1)], index)[0]
            },
            addSegment: function () {
                return this._add([Segment.read(arguments)])[0]
            },
            insertSegment: function (index) {
                return this._add([Segment.read(arguments, 1)], index)[0]
            },
            addSegments: function (segments) {
                return this._add(Segment.readAll(segments))
            },
            insertSegments: function (index, segments) {
                return this._add(Segment.readAll(segments), index)
            },
            removeSegment: function (index) {
                return this.removeSegments(index, index + 1)[0] || null
            },
            removeSegments: function (from, to, _includeCurves) {
                from = from || 0, to = Base.pick(to, this._segments.length);
                var segments = this._segments,
                    curves = this._curves,
                    count = segments.length,
                    removed = segments.splice(from, to - from),
                    amount = removed.length;
                if (!amount) return removed;
                for (var i = 0; amount > i; i++) {
                    var segment = removed[i];
                    segment._selectionState && this._updateSelection(segment, segment._selectionState, 0), segment._index = segment._path = null
                }
                for (var i = from, l = segments.length; l > i; i++) segments[i]._index = i;
                if (curves) {
                    var index = from > 0 && to === count + (this._closed ? 1 : 0) ? from - 1 : from,
                        curves = curves.splice(index, amount);
                    _includeCurves && (removed._curves = curves.slice(1)), this._adjustCurves(index, index)
                }
                return this._changed(25), removed
            },
            clear: "#removeSegments",
            isFullySelected: function () {
                var length = this._segments.length;
                return this._selected && length > 0 && this._selectedSegmentState === 7 * length
            },
            setFullySelected: function (selected) {
                selected && this._selectSegments(!0), this.setSelected(selected)
            },
            setSelected: function setSelected(selected) {
                selected || this._selectSegments(!1), setSelected.base.call(this, selected)
            },
            _selectSegments: function (selected) {
                var length = this._segments.length;
                this._selectedSegmentState = selected ? 7 * length : 0;
                for (var i = 0; length > i; i++) this._segments[i]._selectionState = selected ? 7 : 0
            },
            _updateSelection: function (segment, oldState, newState) {
                segment._selectionState = newState;
                var total = this._selectedSegmentState += newState - oldState;
                total > 0 && this.setSelected(!0)
            },
            flatten: function (maxDistance) {
                for (var flattener = new PathFlattener(this), pos = 0, step = flattener.length / Math.ceil(flattener.length / maxDistance), end = flattener.length + (this._closed ? -step : step) / 2, segments = []; end >= pos;) segments.push(new Segment(flattener.evaluate(pos, 0))), pos += step;
                this.setSegments(segments)
            },
            reduce: function () {
                for (var curves = this.getCurves(), i = curves.length - 1; i >= 0; i--) {
                    var curve = curves[i];
                    curve.isLinear() && 0 === curve.getLength() && curve.remove()
                }
                return this
            },
            simplify: function (tolerance) {
                if (this._segments.length > 2) {
                    var fitter = new PathFitter(this, tolerance || 2.5);
                    this.setSegments(fitter.fit())
                }
            },
            split: function (index, parameter) {
                if (null !== parameter) {
                    if (1 === arguments.length) {
                        var arg = index;
                        "number" == typeof arg && (arg = this.getLocationAt(arg)), index = arg.index, parameter = arg.parameter
                    }
                    var tolerance = 1e-5;
                    parameter >= 1 - tolerance && (index++, parameter--);
                    var curves = this.getCurves();
                    if (index >= 0 && index < curves.length) {
                        parameter > tolerance && curves[index++].divide(parameter, !0);
                        var path, segs = this.removeSegments(index, this._segments.length, !0);
                        return this._closed ? (this.setClosed(!1), path = this) : index > 0 && (path = this._clone((new Path).insertAbove(this, !0))), path._add(segs, 0), this.addSegment(segs[0]), path
                    }
                    return null
                }
            },
            isClockwise: function () {
                return this._clockwise !== undefined ? this._clockwise : Path.isClockwise(this._segments)
            },
            setClockwise: function (clockwise) {
                this.isClockwise() != (clockwise = !!clockwise) && this.reverse(), this._clockwise = clockwise
            },
            reverse: function () {
                this._segments.reverse();
                for (var i = 0, l = this._segments.length; l > i; i++) {
                    var segment = this._segments[i],
                        handleIn = segment._handleIn;
                    segment._handleIn = segment._handleOut, segment._handleOut = handleIn, segment._index = i
                }
                this._curves = null, this._clockwise !== undefined && (this._clockwise = !this._clockwise)
            },
            join: function (path) {
                if (path) {
                    var segments = path._segments,
                        last1 = this.getLastSegment(),
                        last2 = path.getLastSegment();
                    last1._point.equals(last2._point) && path.reverse();
                    var first1, first2 = path.getFirstSegment();
                    last1._point.equals(first2._point) ? (last1.setHandleOut(first2._handleOut), this._add(segments.slice(1))) : (first1 = this.getFirstSegment(), first1._point.equals(first2._point) && path.reverse(), last2 = path.getLastSegment(), first1._point.equals(last2._point) ? (first1.setHandleIn(last2._handleIn), this._add(segments.slice(0, segments.length - 1), 0)) : this._add(segments.slice())), path.closed && this._add([segments[0]]), path.remove()
                }
                var first = this.getFirstSegment(),
                    last = this.getLastSegment();
                first !== last && first._point.equals(last._point) && (first.setHandleIn(last._handleIn), last.remove(), this.setClosed(!0))
            },
            getLength: function () {
                if (null == this._length) {
                    var curves = this.getCurves();
                    this._length = 0;
                    for (var i = 0, l = curves.length; l > i; i++) this._length += curves[i].getLength()
                }
                return this._length
            },
            getArea: function () {
                for (var curves = this.getCurves(), area = 0, i = 0, l = curves.length; l > i; i++) area += curves[i].getArea();
                return area
            },
            _getOffset: function (location) {
                var index = location && location.getIndex();
                if (null != index) {
                    for (var curves = this.getCurves(), offset = 0, i = 0; index > i; i++) offset += curves[i].getLength();
                    var curve = curves[index],
                        parameter = location.getParameter();
                    return parameter > 0 && (offset += curve.getPartLength(0, parameter)), offset
                }
                return null
            },
            getLocationOf: function (point) {
                for (var point = Point.read(arguments), curves = this.getCurves(), i = 0, l = curves.length; l > i; i++) {
                    var loc = curves[i].getLocationOf(point);
                    if (loc) return loc
                }
                return null
            },
            getLocationAt: function (offset, isParameter) {
                var curves = this.getCurves(),
                    length = 0;
                if (isParameter) {
                    var index = ~~offset;
                    return curves[index].getLocationAt(offset - index, !0)
                }
                for (var i = 0, l = curves.length; l > i; i++) {
                    var start = length,
                        curve = curves[i];
                    if (length += curve.getLength(), length > offset) return curve.getLocationAt(offset - start)
                }
                return offset <= this.getLength() ? new CurveLocation(curves[curves.length - 1], 1) : null
            },
            getPointAt: function (offset, isParameter) {
                var loc = this.getLocationAt(offset, isParameter);
                return loc && loc.getPoint()
            },
            getTangentAt: function (offset, isParameter) {
                var loc = this.getLocationAt(offset, isParameter);
                return loc && loc.getTangent()
            },
            getNormalAt: function (offset, isParameter) {
                var loc = this.getLocationAt(offset, isParameter);
                return loc && loc.getNormal()
            },
            getNearestLocation: function (point) {
                for (var point = Point.read(arguments), curves = this.getCurves(), minDist = 1 / 0, minLoc = null, i = 0, l = curves.length; l > i; i++) {
                    var loc = curves[i].getNearestLocation(point);
                    loc._distance < minDist && (minDist = loc._distance, minLoc = loc)
                }
                return minLoc
            },
            getNearestPoint: function (point) {
                var point = Point.read(arguments);
                return this.getNearestLocation(point).getPoint()
            },
            toShape: function (insert) {
                function isColinear(i, j) {
                    return segments[i].isColinear(segments[j])
                }

                function isOrthogonal(i) {
                    return segments[i].isOrthogonal()
                }

                function isArc(i) {
                    return segments[i].isArc()
                }

                function getDistance(i, j) {
                    return segments[i]._point.getDistance(segments[j]._point)
                }
                if (!this._closed) return null;
                var type, size, radius, topCenter, segments = this._segments;
                if (this.isPolygon() && 4 === segments.length && isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1) ? (type = Shape.Rectangle, size = new Size(getDistance(0, 3), getDistance(0, 1)), topCenter = segments[1]._point.add(segments[2]._point).divide(2)) : 8 === segments.length && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isColinear(1, 5) && isColinear(3, 7) ? (type = Shape.Rectangle, size = new Size(getDistance(1, 6), getDistance(0, 3)), radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2), topCenter = segments[3]._point.add(segments[4]._point).divide(2)) : 4 === segments.length && isArc(0) && isArc(1) && isArc(2) && isArc(3) && (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3)) ? (type = Shape.Circle, radius = getDistance(0, 2) / 2) : (type = Shape.Ellipse, radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2)), topCenter = segments[1]._point), type) {
                    var center = this.getPosition(!0),
                        shape = new type({
                            center: center,
                            size: size,
                            radius: radius,
                            insert: !1
                        });
                    return shape.rotate(topCenter.subtract(center).getAngle() + 90), shape.setStyle(this._style), (insert || insert === undefined) && shape.insertAbove(this), shape
                }
                return null
            },
            _hitTest: function (point, options) {
                function isCloseEnough(pt, padding) {
                    return point.subtract(pt).divide(padding).length <= 1
                }

                function checkSegmentPoint(seg, pt, name) {
                    if (!options.selected || pt.isSelected()) {
                        var anchor = seg._point;
                        if (pt !== anchor && (pt = pt.add(anchor)), isCloseEnough(pt, strokePadding)) return new HitResult(name, that, {
                            segment: seg,
                            point: pt
                        })
                    }
                }

                function checkSegmentPoints(seg, ends) {
                    return (ends || options.segments) && checkSegmentPoint(seg, seg._point, "segment") || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, "handle-in") || checkSegmentPoint(seg, seg._handleOut, "handle-out"))
                }

                function addToArea(point) {
                    area.add(point)
                }

                function checkSegmentStroke(segment) {
                    if (("round" !== join || "round" !== cap) && (area = new Path({
                        internal: !0,
                        closed: !0
                    }), closed || segment._index > 0 && segment._index < numSegments - 1 ? "round" !== join && (segment._handleIn.isZero() || segment._handleOut.isZero()) && Path._addBevelJoin(segment, join, radius, miterLimit, addToArea, !0) : "round" !== cap && Path._addSquareCap(segment, cap, radius, addToArea, !0), !area.isEmpty())) {
                        var loc;
                        return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding)
                    }
                    return isCloseEnough(segment._point, strokePadding)
                }
                var join, cap, miterLimit, area, loc, res, that = this,
                    style = this.getStyle(),
                    segments = this._segments,
                    numSegments = segments.length,
                    closed = this._closed,
                    tolerancePadding = options._tolerancePadding,
                    strokePadding = tolerancePadding,
                    hasStroke = options.stroke && style.hasStroke(),
                    hasFill = options.fill && style.hasFill(),
                    radius = hasStroke ? style.getStrokeWidth() / 2 : hasFill ? 0 : null;
                if (null != radius && (radius > 0 ? (join = style.getStrokeJoin(), cap = style.getStrokeCap(), miterLimit = radius * style.getMiterLimit(), strokePadding = tolerancePadding.add(new Point(radius, radius))) : join = cap = "round"), !options.ends || options.segments || closed) {
                    if (options.segments || options.handles)
                        for (var i = 0; numSegments > i; i++)
                            if (res = checkSegmentPoints(segments[i])) return res
                } else if (res = checkSegmentPoints(segments[0], !0) || checkSegmentPoints(segments[numSegments - 1], !0)) return res;
                if (null != radius) {
                    if (loc = this.getNearestLocation(point)) {
                        var parameter = loc.getParameter();
                        0 === parameter || 1 === parameter && numSegments > 1 ? checkSegmentStroke(loc.getSegment()) || (loc = null) : isCloseEnough(loc.getPoint(), strokePadding) || (loc = null)
                    }
                    if (!loc && "miter" === join && numSegments > 1)
                        for (var i = 0; numSegments > i; i++) {
                            var segment = segments[i];
                            if (point.getDistance(segment._point) <= miterLimit && checkSegmentStroke(segment)) {
                                loc = segment.getLocation();
                                break
                            }
                        }
                }
                return !loc && hasFill && this._contains(point) || loc && !hasStroke ? new HitResult("fill", this) : loc ? new HitResult("stroke", this, {
                    location: loc,
                    point: loc.getPoint()
                }) : null
            }
        }, new function () {
            function drawHandles(ctx, segments, matrix, size) {
                function drawHandle(index) {
                    var hX = coords[index],
                        hY = coords[index + 1];
                    (pX != hX || pY != hY) && (ctx.beginPath(), ctx.moveTo(pX, pY), ctx.lineTo(hX, hY), ctx.stroke(), ctx.beginPath(), ctx.arc(hX, hY, half, 0, 2 * Math.PI, !0), ctx.fill())
                }
                for (var half = size / 2, coords = new Array(6), i = 0, l = segments.length; l > i; i++) {
                    var segment = segments[i];
                    segment._transformCoordinates(matrix, coords, !1);
                    var state = segment._selectionState,
                        pX = coords[0],
                        pY = coords[1];
                    if (1 & state && drawHandle(2), 2 & state && drawHandle(4), ctx.fillRect(pX - half, pY - half, size, size), !(4 & state)) {
                        var fillStyle = ctx.fillStyle;
                        ctx.fillStyle = "#ffffff", ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2), ctx.fillStyle = fillStyle
                    }
                }
            }

            function drawSegments(ctx, path, matrix) {
                function drawSegment(i) {
                    var segment = segments[i];
                    if (matrix) segment._transformCoordinates(matrix, coords, !1), curX = coords[0], curY = coords[1];
                    else {
                        var point = segment._point;
                        curX = point._x, curY = point._y
                    } if (first) ctx.moveTo(curX, curY), first = !1;
                    else {
                        if (matrix) inX = coords[2], inY = coords[3];
                        else {
                            var handle = segment._handleIn;
                            inX = curX + handle._x, inY = curY + handle._y
                        }
                        inX == curX && inY == curY && outX == prevX && outY == prevY ? ctx.lineTo(curX, curY) : ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY)
                    } if (prevX = curX, prevY = curY, matrix) outX = coords[4], outY = coords[5];
                    else {
                        var handle = segment._handleOut;
                        outX = prevX + handle._x, outY = prevY + handle._y
                    }
                }
                for (var curX, curY, prevX, prevY, inX, inY, outX, outY, segments = path._segments, length = segments.length, coords = new Array(6), first = !0, i = 0; length > i; i++) drawSegment(i);
                path._closed && length > 0 && drawSegment(0)
            }
            return {
                _draw: function (ctx, param) {
                    function getOffset(i) {
                        return dashArray[(i % dashLength + dashLength) % dashLength]
                    }
                    var dontStart = param.dontStart,
                        dontPaint = param.dontFinish || param.clip;
                    dontStart || ctx.beginPath();
                    var style = this.getStyle(),
                        hasFill = style.hasFill(),
                        hasStroke = style.hasStroke(),
                        dashArray = style.getDashArray(),
                        dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
                    if (!dontStart && this._currentPath ? ctx.currentPath = this._currentPath : (hasFill || hasStroke && !dashLength || dontPaint) && (drawSegments(ctx, this), this._closed && ctx.closePath(), dontStart || (this._currentPath = ctx.currentPath)), !dontPaint && (hasFill || hasStroke) && (this._setStyles(ctx), hasFill && (ctx.fill(style.getWindingRule()), ctx.shadowColor = "rgba(0,0,0,0)"), hasStroke)) {
                        if (dashLength) {
                            dontStart || ctx.beginPath();
                            var to, flattener = new PathFlattener(this),
                                length = flattener.length,
                                from = -style.getDashOffset(),
                                i = 0;
                            for (from %= length; from > 0;) from -= getOffset(i--) + getOffset(i--);
                            for (; length > from;) to = from + getOffset(i++), (from > 0 || to > 0) && flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0)), from = to + getOffset(i++)
                        }
                        ctx.stroke()
                    }
                },
                _drawSelected: function (ctx, matrix) {
                    ctx.beginPath(), drawSegments(ctx, this, matrix), ctx.stroke(), drawHandles(ctx, this._segments, matrix, paper.settings.handleSize)
                }
            }
        }, new function () {
            function getFirstControlPoints(rhs) {
                var n = rhs.length,
                    x = [],
                    tmp = [],
                    b = 2;
                x[0] = rhs[0] / b;
                for (var i = 1; n > i; i++) tmp[i] = 1 / b, b = (n - 1 > i ? 4 : 2) - tmp[i], x[i] = (rhs[i] - x[i - 1]) / b;
                for (var i = 1; n > i; i++) x[n - i - 1] -= tmp[n - i] * x[n - i];
                return x
            }
            return {
                smooth: function () {
                    var segments = this._segments,
                        size = segments.length,
                        closed = this._closed,
                        n = size,
                        overlap = 0;
                    if (!(2 >= size)) {
                        closed && (overlap = Math.min(size, 4), n += 2 * Math.min(size, overlap));
                        for (var knots = [], i = 0; size > i; i++) knots[i + overlap] = segments[i]._point;
                        if (closed)
                            for (var i = 0; overlap > i; i++) knots[i] = segments[i + size - overlap]._point, knots[i + size + overlap] = segments[i]._point;
                        else n--;
                        for (var rhs = [], i = 1; n - 1 > i; i++) rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
                        rhs[0] = knots[0]._x + 2 * knots[1]._x, rhs[n - 1] = 3 * knots[n - 1]._x;
                        for (var x = getFirstControlPoints(rhs), i = 1; n - 1 > i; i++) rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
                        rhs[0] = knots[0]._y + 2 * knots[1]._y, rhs[n - 1] = 3 * knots[n - 1]._y;
                        var y = getFirstControlPoints(rhs);
                        if (closed) {
                            for (var i = 0, j = size; overlap > i; i++, j++) {
                                var f1 = i / overlap,
                                    f2 = 1 - f1,
                                    ie = i + overlap,
                                    je = j + overlap;
                                x[j] = x[i] * f1 + x[j] * f2, y[j] = y[i] * f1 + y[j] * f2, x[je] = x[ie] * f2 + x[je] * f1, y[je] = y[ie] * f2 + y[je] * f1
                            }
                            n--
                        }
                        for (var handleIn = null, i = overlap; n - overlap >= i; i++) {
                            var segment = segments[i - overlap];
                            handleIn && segment.setHandleIn(handleIn.subtract(segment._point)), n > i && (segment.setHandleOut(new Point(x[i], y[i]).subtract(segment._point)), handleIn = n - 1 > i ? new Point(2 * knots[i + 1]._x - x[i + 1], 2 * knots[i + 1]._y - y[i + 1]) : new Point((knots[n]._x + x[n - 1]) / 2, (knots[n]._y + y[n - 1]) / 2))
                        }
                        if (closed && handleIn) {
                            var segment = this._segments[0];
                            segment.setHandleIn(handleIn.subtract(segment._point))
                        }
                    }
                }
            }
        }, new function () {
            function getCurrentSegment(that) {
                var segments = that._segments;
                if (0 === segments.length) throw new Error("Use a moveTo() command first");
                return segments[segments.length - 1]
            }
            return {
                moveTo: function () {
                    var segments = this._segments;
                    1 === segments.length && this.removeSegment(0), segments.length || this._add([new Segment(Point.read(arguments))])
                },
                moveBy: function () {
                    throw new Error("moveBy() is unsupported on Path items.")
                },
                lineTo: function () {
                    this._add([new Segment(Point.read(arguments))])
                },
                cubicCurveTo: function () {
                    var handle1 = Point.read(arguments),
                        handle2 = Point.read(arguments),
                        to = Point.read(arguments),
                        current = getCurrentSegment(this);
                    current.setHandleOut(handle1.subtract(current._point)), this._add([new Segment(to, handle2.subtract(to))])
                },
                quadraticCurveTo: function () {
                    var handle = Point.read(arguments),
                        to = Point.read(arguments),
                        current = getCurrentSegment(this)._point;
                    this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to)
                },
                curveTo: function () {
                    var through = Point.read(arguments),
                        to = Point.read(arguments),
                        t = Base.pick(Base.read(arguments), .5),
                        t1 = 1 - t,
                        current = getCurrentSegment(this)._point,
                        handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);
                    if (handle.isNaN()) throw new Error("Cannot put a curve through points with parameter = " + t);
                    this.quadraticCurveTo(handle, to)
                },
                arcTo: function () {
                    var through, center, extent, vector, matrix, current = getCurrentSegment(this),
                        from = current._point,
                        to = Point.read(arguments),
                        peek = Base.peek(arguments),
                        clockwise = Base.pick(peek, !0);
                    if ("boolean" == typeof clockwise) var middle = from.add(to).divide(2),
                        through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
                    else if (Base.remain(arguments) <= 2) through = to, to = Point.read(arguments);
                    else {
                        var radius = Size.read(arguments);
                        if (radius.isZero()) return this.lineTo(to);
                        var rotation = Base.read(arguments),
                            clockwise = !!Base.read(arguments),
                            large = !!Base.read(arguments),
                            middle = from.add(to).divide(2),
                            pt = from.subtract(middle).rotate(-rotation),
                            x = pt.x,
                            y = pt.y,
                            abs = Math.abs,
                            EPSILON = 1e-11,
                            rx = abs(radius.width),
                            ry = abs(radius.height),
                            rxSq = rx * rx,
                            rySq = ry * ry,
                            xSq = x * x,
                            ySq = y * y,
                            factor = Math.sqrt(xSq / rxSq + ySq / rySq);
                        if (factor > 1 && (rx *= factor, ry *= factor, rxSq = rx * rx, rySq = ry * ry), factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq), abs(factor) < EPSILON && (factor = 0), 0 > factor) throw new Error("Cannot create an arc with the given arguments");
                        center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * Math.sqrt(factor)).rotate(rotation).add(middle), matrix = (new Matrix).translate(center).rotate(rotation).scale(rx, ry), vector = matrix._inverseTransform(from), extent = vector.getDirectedAngle(matrix._inverseTransform(to)), !clockwise && extent > 0 ? extent -= 360 : clockwise && 0 > extent && (extent += 360)
                    } if (through) {
                        var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), !0),
                            l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), !0),
                            line = new Line(from, to),
                            throughSide = line.getSide(through);
                        if (center = l1.intersect(l2, !0), !center) {
                            if (!throughSide) return this.lineTo(to);
                            throw new Error("Cannot create an arc with the given arguments")
                        }
                        vector = from.subtract(center), extent = vector.getDirectedAngle(to.subtract(center));
                        var centerSide = line.getSide(center);
                        0 === centerSide ? extent = throughSide * Math.abs(extent) : throughSide === centerSide && (extent += 0 > extent ? 360 : -360)
                    }
                    for (var ext = Math.abs(extent), count = ext >= 360 ? 4 : Math.ceil(ext / 90), inc = extent / count, half = inc * Math.PI / 360, z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)), segments = [], i = 0; count >= i; i++) {
                        var pt = to,
                            out = null;
                        if (count > i && (out = vector.rotate(90).multiply(z), matrix ? (pt = matrix._transformPoint(vector), out = matrix._transformPoint(vector.add(out)).subtract(pt)) : pt = center.add(vector)), 0 === i) current.setHandleOut(out);
                        else {
                            var _in = vector.rotate(-90).multiply(z);
                            matrix && (_in = matrix._transformPoint(vector.add(_in)).subtract(pt)), segments.push(new Segment(pt, _in, out))
                        }
                        vector = vector.rotate(inc)
                    }
                    this._add(segments)
                },
                lineBy: function () {
                    var to = Point.read(arguments),
                        current = getCurrentSegment(this)._point;
                    this.lineTo(current.add(to))
                },
                curveBy: function () {
                    var through = Point.read(arguments),
                        to = Point.read(arguments),
                        parameter = Base.read(arguments),
                        current = getCurrentSegment(this)._point;
                    this.curveTo(current.add(through), current.add(to), parameter)
                },
                cubicCurveBy: function () {
                    var handle1 = Point.read(arguments),
                        handle2 = Point.read(arguments),
                        to = Point.read(arguments),
                        current = getCurrentSegment(this)._point;
                    this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to))
                },
                quadraticCurveBy: function () {
                    var handle = Point.read(arguments),
                        to = Point.read(arguments),
                        current = getCurrentSegment(this)._point;
                    this.quadraticCurveTo(current.add(handle), current.add(to))
                },
                arcBy: function () {
                    var current = getCurrentSegment(this)._point,
                        point = current.add(Point.read(arguments)),
                        clockwise = Base.pick(Base.peek(arguments), !0);
                    "boolean" == typeof clockwise ? this.arcTo(point, clockwise) : this.arcTo(point, current.add(Point.read(arguments)))
                },
                closePath: function (join) {
                    this.setClosed(!0), join && this.join()
                }
            }
        }, {
            _getBounds: function (getter, matrix) {
                return Path[getter](this._segments, this._closed, this.getStyle(), matrix)
            },
            statics: {
                isClockwise: function (segments) {
                    for (var sum = 0, i = 0, l = segments.length; l > i; i++)
                        for (var v = Curve.getValues(segments[i], segments[l > i + 1 ? i + 1 : 0]), j = 2; 8 > j; j += 2) sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
                    return sum > 0
                },
                getBounds: function (segments, closed, style, matrix, strokePadding) {
                    function processSegment(segment) {
                        segment._transformCoordinates(matrix, coords, !1);
                        for (var i = 0; 2 > i; i++) Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
                        var tmp = prevCoords;
                        prevCoords = coords, coords = tmp
                    }
                    var first = segments[0];
                    if (!first) return new Rectangle;
                    for (var coords = new Array(6), prevCoords = first._transformCoordinates(matrix, new Array(6), !1), min = prevCoords.slice(0, 2), max = min.slice(), roots = new Array(2), i = 1, l = segments.length; l > i; i++) processSegment(segments[i]);
                    return closed && processSegment(first), new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1])
                },
                getStrokeBounds: function (segments, closed, style, matrix) {
                    function add(point) {
                        bounds = bounds.include(matrix ? matrix._transformPoint(point, point) : point)
                    }

                    function addRound(segment) {
                        bounds = bounds.unite(joinBounds.setCenter(matrix ? matrix._transformPoint(segment._point) : segment._point))
                    }

                    function addJoin(segment, join) {
                        var handleIn = segment._handleIn,
                            handleOut = segment._handleOut;
                        "round" === join || !handleIn.isZero() && !handleOut.isZero() && handleIn.isColinear(handleOut) ? addRound(segment) : Path._addBevelJoin(segment, join, radius, miterLimit, add)
                    }

                    function addCap(segment, cap) {
                        "round" === cap ? addRound(segment) : Path._addSquareCap(segment, cap, radius, add)
                    }
                    if (!style.hasStroke()) return Path.getBounds(segments, closed, style, matrix);
                    for (var length = segments.length - (closed ? 0 : 1), radius = style.getStrokeWidth() / 2, padding = Path._getPenPadding(radius, matrix), bounds = Path.getBounds(segments, closed, style, matrix, padding), join = style.getStrokeJoin(), cap = style.getStrokeCap(), miterLimit = radius * style.getMiterLimit(), joinBounds = new Rectangle(new Size(padding).multiply(2)), i = 1; length > i; i++) addJoin(segments[i], join);
                    return closed ? addJoin(segments[0], join) : length > 0 && (addCap(segments[0], cap), addCap(segments[segments.length - 1], cap)), bounds
                },
                _getPenPadding: function (radius, matrix) {
                    if (!matrix) return [radius, radius];
                    var mx = matrix.shiftless(),
                        hor = mx.transform(new Point(radius, 0)),
                        ver = mx.transform(new Point(0, radius)),
                        phi = hor.getAngleInRadians(),
                        a = hor.getLength(),
                        b = ver.getLength(),
                        sin = Math.sin(phi),
                        cos = Math.cos(phi),
                        tan = Math.tan(phi),
                        tx = -Math.atan(b * tan / a),
                        ty = Math.atan(b / (tan * a));
                    return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)]
                },
                _addBevelJoin: function (segment, join, radius, miterLimit, addPoint, area) {
                    var curve2 = segment.getCurve(),
                        curve1 = curve2.getPrevious(),
                        point = curve2.getPointAt(0, !0),
                        normal1 = curve1.getNormalAt(1, !0),
                        normal2 = curve2.getNormalAt(0, !0),
                        step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
                    if (normal1.setLength(step), normal2.setLength(step), area && (addPoint(point), addPoint(point.add(normal1))), "miter" === join) {
                        var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), !0).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), !0), !0);
                        if (corner && point.getDistance(corner) <= miterLimit && (addPoint(corner), !area)) return
                    }
                    area || addPoint(point.add(normal1)), addPoint(point.add(normal2))
                },
                _addSquareCap: function (segment, cap, radius, addPoint, area) {
                    var point = segment._point,
                        loc = segment.getLocation(),
                        normal = loc.getNormal().normalize(radius);
                    area && (addPoint(point.subtract(normal)), addPoint(point.add(normal))), "square" === cap && (point = point.add(normal.rotate(0 == loc.getParameter() ? -90 : 90))), addPoint(point.add(normal)), addPoint(point.subtract(normal))
                },
                getHandleBounds: function (segments, closed, style, matrix, strokePadding, joinPadding) {
                    for (var coords = new Array(6), x1 = 1 / 0, x2 = -x1, y1 = x1, y2 = x2, i = 0, l = segments.length; l > i; i++) {
                        var segment = segments[i];
                        segment._transformCoordinates(matrix, coords, !1);
                        for (var j = 0; 6 > j; j += 2) {
                            var padding = 0 == j ? joinPadding : strokePadding,
                                paddingX = padding ? padding[0] : 0,
                                paddingY = padding ? padding[1] : 0,
                                x = coords[j],
                                y = coords[j + 1],
                                xn = x - paddingX,
                                xx = x + paddingX,
                                yn = y - paddingY,
                                yx = y + paddingY;
                            x1 > xn && (x1 = xn), xx > x2 && (x2 = xx), y1 > yn && (y1 = yn), yx > y2 && (y2 = yx)
                        }
                    }
                    return new Rectangle(x1, y1, x2 - x1, y2 - y1)
                },
                getRoughBounds: function (segments, closed, style, matrix) {
                    var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
                        joinRadius = strokeRadius;
                    return strokeRadius > 0 && ("miter" === style.getStrokeJoin() && (joinRadius = strokeRadius * style.getMiterLimit()), "square" === style.getStrokeCap() && (joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2)))), Path.getHandleBounds(segments, closed, style, matrix, Path._getPenPadding(strokeRadius, matrix), Path._getPenPadding(joinRadius, matrix))
                }
            }
        });
    Path.inject({
        statics: new function () {
            function createPath(segments, closed, args) {
                var props = Base.getNamed(args),
                    path = new Path(props && props.insert === !1 && Item.NO_INSERT);
                return path._add(segments), path._closed = closed, path.set(props)
            }

            function createEllipse(center, radius, args) {
                for (var segments = new Array(4), i = 0; 4 > i; i++) {
                    var segment = ellipseSegments[i];
                    segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius))
                }
                return createPath(segments, !0, args)
            }
            var kappa = .5522847498307936,
                ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];
            return {
                Line: function () {
                    return createPath([new Segment(Point.readNamed(arguments, "from")), new Segment(Point.readNamed(arguments, "to"))], !1, arguments)
                },
                Circle: function () {
                    var center = Point.readNamed(arguments, "center"),
                        radius = Base.readNamed(arguments, "radius");
                    return createEllipse(center, new Size(radius), arguments)
                },
                Rectangle: function () {
                    var segments, rect = Rectangle.readNamed(arguments, "rectangle"),
                        radius = Size.readNamed(arguments, "radius", 0, {
                            readNull: !0
                        }),
                        bl = rect.getBottomLeft(!0),
                        tl = rect.getTopLeft(!0),
                        tr = rect.getTopRight(!0),
                        br = rect.getBottomRight(!0);
                    if (!radius || radius.isZero()) segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
                    else {
                        radius = Size.min(radius, rect.getSize(!0).divide(2));
                        var rx = radius.width,
                            ry = radius.height,
                            hx = rx * kappa,
                            hy = ry * kappa;
                        segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])]
                    }
                    return createPath(segments, !0, arguments)
                },
                RoundRectangle: "#Rectangle",
                Ellipse: function () {
                    var ellipse = Shape._readEllipse(arguments);
                    return createEllipse(ellipse.center, ellipse.radius, arguments)
                },
                Oval: "#Ellipse",
                Arc: function () {
                    var from = Point.readNamed(arguments, "from"),
                        through = Point.readNamed(arguments, "through"),
                        to = Point.readNamed(arguments, "to"),
                        props = Base.getNamed(arguments),
                        path = new Path(props && props.insert === !1 && Item.NO_INSERT);
                    return path.moveTo(from), path.arcTo(through, to), path.set(props)
                },
                RegularPolygon: function () {
                    for (var center = Point.readNamed(arguments, "center"), sides = Base.readNamed(arguments, "sides"), radius = Base.readNamed(arguments, "radius"), step = 360 / sides, three = !(sides % 3), vector = new Point(0, three ? -radius : radius), offset = three ? -1 : .5, segments = new Array(sides), i = 0; sides > i; i++) segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));
                    return createPath(segments, !0, arguments)
                },
                Star: function () {
                    for (var center = Point.readNamed(arguments, "center"), points = 2 * Base.readNamed(arguments, "points"), radius1 = Base.readNamed(arguments, "radius1"), radius2 = Base.readNamed(arguments, "radius2"), step = 360 / points, vector = new Point(0, -1), segments = new Array(points), i = 0; points > i; i++) segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));
                    return createPath(segments, !0, arguments)
                }
            }
        }
    });
    var CompoundPath = PathItem.extend({
        _class: "CompoundPath",
        _serializeFields: {
            children: []
        },
        initialize: function (arg) {
            this._children = [], this._namedChildren = {}, this._initialize(arg) || ("string" == typeof arg ? this.setPathData(arg) : this.addChildren(Array.isArray(arg) ? arg : arguments))
        },
        insertChildren: function insertChildren(index, items, _preserve) {
            items = insertChildren.base.call(this, index, items, _preserve, Path);
            for (var i = 0, l = !_preserve && items && items.length; l > i; i++) {
                var item = items[i];
                item._clockwise === undefined && item.setClockwise(0 === item._index)
            }
            return items
        },
        reverse: function () {
            for (var children = this._children, i = 0, l = children.length; l > i; i++) children[i].reverse()
        },
        smooth: function () {
            for (var i = 0, l = this._children.length; l > i; i++) this._children[i].smooth()
        },
        isClockwise: function () {
            var child = this.getFirstChild();
            return child && child.isClockwise()
        },
        setClockwise: function (clockwise) {
            this.isClockwise() !== !!clockwise && this.reverse()
        },
        getFirstSegment: function () {
            var first = this.getFirstChild();
            return first && first.getFirstSegment()
        },
        getLastSegment: function () {
            var last = this.getLastChild();
            return last && last.getLastSegment()
        },
        getCurves: function () {
            for (var children = this._children, curves = [], i = 0, l = children.length; l > i; i++) curves.push.apply(curves, children[i].getCurves());
            return curves
        },
        getFirstCurve: function () {
            var first = this.getFirstChild();
            return first && first.getFirstCurve()
        },
        getLastCurve: function () {
            var last = this.getLastChild();
            return last && last.getFirstCurve()
        },
        getArea: function () {
            for (var children = this._children, area = 0, i = 0, l = children.length; l > i; i++) area += children[i].getArea();
            return area
        }
    }, {
        beans: !0,
        getPathData: function (_precision) {
            for (var children = this._children, paths = [], i = 0, l = children.length; l > i; i++) paths.push(children[i].getPathData(_precision));
            return paths.join(" ")
        }
    }, {
        _getChildHitTestOptions: function (options) {
            return "path" === options.type ? options : new Base(options, {
                fill: !1
            })
        },
        _draw: function (ctx, param) {
            var children = this._children;
            if (0 !== children.length) {
                if (this._currentPath) ctx.currentPath = this._currentPath;
                else {
                    param = param.extend({
                        dontStart: !0,
                        dontFinish: !0
                    }), ctx.beginPath();
                    for (var i = 0, l = children.length; l > i; i++) children[i].draw(ctx, param);
                    this._currentPath = ctx.currentPath
                } if (!param.clip) {
                    this._setStyles(ctx);
                    var style = this._style;
                    style.hasFill() && (ctx.fill(style.getWindingRule()), ctx.shadowColor = "rgba(0,0,0,0)"), style.hasStroke() && ctx.stroke()
                }
            }
        },
        _drawSelected: function (ctx, matrix) {
            for (var children = this._children, i = 0, l = children.length; l > i; i++) {
                var child = children[i],
                    mx = child._matrix;
                child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.clone().concatenate(child._matrix))
            }
        }
    }, new function () {
        function getCurrentPath(that, check) {
            var children = that._children;
            if (check && 0 === children.length) throw new Error("Use a moveTo() command first");
            return children[children.length - 1]
        }
        var fields = {
            moveTo: function () {
                var current = getCurrentPath(this),
                    path = current && current.isEmpty() ? current : new Path;
                path !== current && this.addChild(path), path.moveTo.apply(path, arguments)
            },
            moveBy: function () {
                var current = getCurrentPath(this, !0),
                    last = current && current.getLastSegment(),
                    point = Point.read(arguments);
                this.moveTo(last ? point.add(last._point) : point)
            },
            closePath: function (join) {
                getCurrentPath(this, !0).closePath(join)
            }
        };
        return Base.each(["lineTo", "cubicCurveTo", "quadraticCurveTo", "curveTo", "arcTo", "lineBy", "cubicCurveBy", "quadraticCurveBy", "curveBy", "arcBy"], function (key) {
            fields[key] = function () {
                var path = getCurrentPath(this, !0);
                path[key].apply(path, arguments)
            }
        }), fields
    });
    PathItem.inject(new function () {
        function computeBoolean(path1, path2, operator, subtract) {
            function preparePath(path) {
                return path.clone(!1).reduce().reorient().transform(null, !0)
            }

            function collect(paths) {
                for (var i = 0, l = paths.length; l > i; i++) {
                    var path = paths[i];
                    segments.push.apply(segments, path._segments), monoCurves.push.apply(monoCurves, path._getMonoCurves())
                }
            }
            var _path1 = preparePath(path1),
                _path2 = path2 && path1 !== path2 && preparePath(path2);
            _path1.isClockwise() || _path1.reverse(), !_path2 || subtract ^ _path2.isClockwise() || _path2.reverse(), splitPath(_path1.getIntersections(_path2, !0));
            var chain = [],
                windings = [],
                lengths = [],
                segments = [],
                monoCurves = [];
            collect(_path1._children || [_path1]), _path2 && collect(_path2._children || [_path2]), segments.sort(function (a, b) {
                var _a = a._intersection,
                    _b = b._intersection;
                return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1
            });
            for (var i = 0, l = segments.length; l > i; i++) {
                var segment = segments[i];
                if (null == segment._winding) {
                    chain.length = windings.length = lengths.length = 0;
                    var totalLength = 0,
                        startSeg = segment;
                    do chain.push(segment), lengths.push(totalLength += segment.getCurve().getLength()), segment = segment.getNext(); while (segment && !segment._intersection && segment !== startSeg);
                    for (var j = 0; 3 > j; j++) {
                        var length = totalLength * Math.random(),
                            amount = lengths.length,
                            k = 0;
                        do
                            if (lengths[k] >= length) {
                                k > 0 && (length -= lengths[k - 1]);
                                break
                            }
                        while (++k < amount);
                        var curve = chain[k].getCurve(),
                            point = curve.getPointAt(length),
                            hor = curve.isHorizontal(),
                            path = curve._path;
                        path._parent instanceof CompoundPath && (path = path._parent), windings[j] = subtract && _path2 && (path === _path1 && _path2._getWinding(point, hor) || path === _path2 && !_path1._getWinding(point, hor)) ? 0 : getWinding(point, monoCurves, hor)
                    }
                    windings.sort();
                    for (var winding = windings[1], j = chain.length - 1; j >= 0; j--) chain[j]._winding = winding
                }
            }
            var result = new CompoundPath;
            return result.addChildren(tracePaths(segments, operator), !0), _path1.remove(), _path2 && _path2.remove(), result.reduce()
        }

        function splitPath(intersections) {
            function resetLinear() {
                for (var i = 0, l = linearSegments.length; l > i; i++) {
                    var segment = linearSegments[i];
                    segment._handleOut.set(0, 0), segment._handleIn.set(0, 0)
                }
            }
            for (var linearSegments, curve, prevLoc, TOLERANCE = 1e-5, i = intersections.length - 1; i >= 0; i--) {
                var loc = intersections[i],
                    t = loc._parameter;
                prevLoc && prevLoc._curve === loc._curve && prevLoc._parameter > 0 ? t /= prevLoc._parameter : (linearSegments && resetLinear(), curve = loc._curve, linearSegments = curve.isLinear() && []);
                var newCurve, segment;
                (newCurve = curve.divide(t, !0, !0)) ? (segment = newCurve._segment1, curve = newCurve.getPrevious()) : segment = TOLERANCE > t ? curve._segment1 : t > 1 - TOLERANCE ? curve._segment2 : curve.getPartLength(0, t) < curve.getPartLength(t, 1) ? curve._segment1 : curve._segment2, segment._intersection = loc.getIntersection(), loc._segment = segment, linearSegments && linearSegments.push(segment), prevLoc = loc
            }
            linearSegments && resetLinear()
        }

        function getWinding(point, curves, horizontal, testContains) {
            var TOLERANCE = 1e-5,
                x = point.x,
                y = point.y,
                windLeft = 0,
                windRight = 0,
                roots = [],
                abs = Math.abs,
                MAX = 1 - TOLERANCE;
            if (horizontal) {
                for (var yTop = -1 / 0, yBottom = 1 / 0, yBefore = y - TOLERANCE, yAfter = y + TOLERANCE, i = 0, l = curves.length; l > i; i++) {
                    var values = curves[i].values;
                    if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0)
                        for (var j = roots.length - 1; j >= 0; j--) {
                            var y0 = Curve.evaluate(values, roots[j], 0).y;
                            yBefore > y0 && y0 > yTop ? yTop = y0 : y0 > yAfter && yBottom > y0 && (yBottom = y0)
                        }
                }
                yTop = (yTop + y) / 2, yBottom = (yBottom + y) / 2, yTop > -1 / 0 && (windLeft = getWinding(new Point(x, yTop), curves)), 1 / 0 > yBottom && (windRight = getWinding(new Point(x, yBottom), curves))
            } else
                for (var xBefore = x - TOLERANCE, xAfter = x + TOLERANCE, i = 0, l = curves.length; l > i; i++) {
                    var curve = curves[i],
                        values = curve.values,
                        winding = curve.winding,
                        next = curve.next;
                    if (winding && (1 === winding && y >= values[1] && y <= values[7] || y >= values[7] && y <= values[1]) && 1 === Curve.solveCubic(values, 1, y, roots, 0, next.winding || next.values[1] !== y ? MAX : 1)) {
                        var t = roots[0],
                            x0 = Curve.evaluate(values, t, 0).x,
                            slope = Curve.evaluate(values, t, 1).y;
                        abs(slope) < TOLERANCE && !Curve.isLinear(values) || TOLERANCE > t && slope * Curve.evaluate(curve.previous.values, t, 1).y < 0 ? testContains && x0 >= xBefore && xAfter >= x0 && (++windLeft, ++windRight) : xBefore >= x0 ? windLeft += winding : x0 >= xAfter && (windRight += winding)
                    }
                }
            return Math.max(abs(windLeft), abs(windRight))
        }

        function tracePaths(segments, operator, selfOp) {
            operator = operator || function () {
                return !0
            };
            for (var seg, startSeg, paths = [], ZERO = .001, ONE = .999, i = 0, l = segments.length; l > i; i++)
                if (seg = startSeg = segments[i], !seg._visited && operator(seg._winding)) {
                    var path = new Path(Item.NO_INSERT),
                        inter = seg._intersection,
                        startInterSeg = inter && inter._segment,
                        added = !1,
                        dir = 1;
                    do {
                        var interSeg, handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
                            handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
                        if (added && (!operator(seg._winding) || selfOp) && (inter = seg._intersection) && (interSeg = inter._segment) && interSeg !== startSeg) {
                            if (selfOp) seg._visited = interSeg._visited, seg = interSeg, dir = 1;
                            else {
                                var c1 = seg.getCurve();
                                dir > 0 && (c1 = c1.getPrevious());
                                var t1 = c1.getTangentAt(1 > dir ? ZERO : ONE, !0),
                                    c4 = interSeg.getCurve(),
                                    c3 = c4.getPrevious(),
                                    t3 = c3.getTangentAt(ONE, !0),
                                    t4 = c4.getTangentAt(ZERO, !0),
                                    w3 = t1.cross(t3),
                                    w4 = t1.cross(t4);
                                if (w3 * w4 !== 0) {
                                    var curve = w4 > w3 ? c3 : c4,
                                        nextCurve = operator(curve._segment1._winding) ? curve : w4 > w3 ? c4 : c3,
                                        nextSeg = nextCurve._segment1;
                                    dir = nextCurve === c3 ? -1 : 1, nextSeg._visited && seg._path !== nextSeg._path || !operator(nextSeg._winding) ? dir = 1 : (seg._visited = interSeg._visited, seg = interSeg, nextSeg._visited && (dir = 1))
                                } else dir = 1
                            }
                            handleOut = dir > 0 ? seg._handleOut : seg._handleIn
                        }
                        path.add(new Segment(seg._point, added && handleIn, handleOut)), added = !0, seg._visited = !0, seg = dir > 0 ? seg.getNext() : seg.getPrevious()
                    } while (seg && !seg._visited && seg !== startSeg && seg !== startInterSeg && (seg._intersection || operator(seg._winding)));
                    !seg || seg !== startSeg && seg !== startInterSeg ? path.lastSegment._handleOut.set(0, 0) : (path.firstSegment.setHandleIn((seg === startInterSeg ? startInterSeg : seg)._handleIn), path.setClosed(!0)), path._segments.length > (path._closed ? path.isPolygon() ? 2 : 0 : 1) && paths.push(path)
                }
            return paths
        }
        return {
            _getWinding: function (point, horizontal, testContains) {
                return getWinding(point, this._getMonoCurves(), horizontal, testContains)
            },
            unite: function (path) {
                return computeBoolean(this, path, function (w) {
                    return 1 === w || 0 === w
                }, !1)
            },
            intersect: function (path) {
                return computeBoolean(this, path, function (w) {
                    return 2 === w
                }, !1)
            },
            subtract: function (path) {
                return computeBoolean(this, path, function (w) {
                    return 1 === w
                }, !0)
            },
            exclude: function (path) {
                return new Group([this.subtract(path), path.subtract(this)])
            },
            divide: function (path) {
                return new Group([this.subtract(path), this.intersect(path)])
            }
        }
    }), Path.inject({
        _getMonoCurves: function () {
            function insertCurve(v) {
                var y0 = v[1],
                    y1 = v[7],
                    curve = {
                        values: v,
                        winding: y0 === y1 ? 0 : y0 > y1 ? -1 : 1,
                        previous: prevCurve,
                        next: null
                    };
                prevCurve && (prevCurve.next = curve), monoCurves.push(curve), prevCurve = curve
            }

            function handleCurve(v) {
                if (0 !== Curve.getLength(v)) {
                    var y0 = v[1],
                        y1 = v[3],
                        y2 = v[5],
                        y3 = v[7];
                    if (Curve.isLinear(v)) insertCurve(v);
                    else {
                        var a = 3 * (y1 - y2) - y0 + y3,
                            b = 2 * (y0 + y2) - 4 * y1,
                            c = y1 - y0,
                            TOLERANCE = 1e-5,
                            roots = [],
                            count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE, 1 - TOLERANCE);
                        if (0 === count) insertCurve(v);
                        else {
                            roots.sort();
                            var t = roots[0],
                                parts = Curve.subdivide(v, t);
                            insertCurve(parts[0]), count > 1 && (t = (roots[1] - t) / (1 - t), parts = Curve.subdivide(parts[1], t), insertCurve(parts[0])), insertCurve(parts[1])
                        }
                    }
                }
            }
            var prevCurve, monoCurves = this._monoCurves;
            if (!monoCurves) {
                monoCurves = this._monoCurves = [];
                for (var curves = this.getCurves(), segments = this._segments, i = 0, l = curves.length; l > i; i++) handleCurve(curves[i].getValues());
                if (!this._closed && segments.length > 1) {
                    var p1 = segments[segments.length - 1]._point,
                        p2 = segments[0]._point,
                        p1x = p1._x,
                        p1y = p1._y,
                        p2x = p2._x,
                        p2y = p2._y;
                    handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y])
                }
                if (monoCurves.length > 0) {
                    var first = monoCurves[0],
                        last = monoCurves[monoCurves.length - 1];
                    first.previous = last, last.next = first
                }
            }
            return monoCurves
        },
        getInteriorPoint: function () {
            var bounds = this.getBounds(),
                point = bounds.getCenter(!0);
            if (!this.contains(point)) {
                for (var curves = this._getMonoCurves(), roots = [], y = point.y, xIntercepts = [], i = 0, l = curves.length; l > i; i++) {
                    var values = curves[i].values;
                    if ((1 === curves[i].winding && y >= values[1] && y <= values[7] || y >= values[7] && y <= values[1]) && Curve.solveCubic(values, 1, y, roots, 0, 1) > 0)
                        for (var j = roots.length - 1; j >= 0; j--) xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
                    if (xIntercepts.length > 1) break
                }
                point.x = (xIntercepts[0] + xIntercepts[1]) / 2
            }
            return point
        },
        reorient: function () {
            return this.setClockwise(!0), this
        }
    }), CompoundPath.inject({
        _getMonoCurves: function () {
            for (var children = this._children, monoCurves = [], i = 0, l = children.length; l > i; i++) monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
            return monoCurves
        },
        reorient: function () {
            var children = this.removeChildren().sort(function (a, b) {
                return b.getBounds().getArea() - a.getBounds().getArea()
            });
            this.addChildren(children);
            for (var clockwise = children[0].isClockwise(), i = 1, l = children.length; l > i; i++) {
                for (var point = children[i].getInteriorPoint(), counters = 0, j = i - 1; j >= 0; j--) children[j].contains(point) && counters++;
                children[i].setClockwise(counters % 2 === 0 && clockwise)
            }
            return this
        }
    });
    var PathFlattener = Base.extend({
            initialize: function (path) {
                function addCurve(segment1, segment2) {
                    var curve = Curve.getValues(segment1, segment2);
                    that.curves.push(curve), that._computeParts(curve, segment1._index, 0, 1)
                }
                this.curves = [], this.parts = [], this.length = 0, this.index = 0;
                for (var segment2, segments = path._segments, segment1 = segments[0], that = this, i = 1, l = segments.length; l > i; i++) segment2 = segments[i], addCurve(segment1, segment2), segment1 = segment2;
                path._closed && addCurve(segment2, segments[0])
            },
            _computeParts: function (curve, index, minT, maxT) {
                if (maxT - minT > 1 / 32 && !Curve.isFlatEnough(curve, .25)) {
                    var curves = Curve.subdivide(curve),
                        halfT = (minT + maxT) / 2;
                    this._computeParts(curves[0], index, minT, halfT), this._computeParts(curves[1], index, halfT, maxT)
                } else {
                    var x = curve[6] - curve[0],
                        y = curve[7] - curve[1],
                        dist = Math.sqrt(x * x + y * y);
                    dist > 1e-5 && (this.length += dist, this.parts.push({
                        offset: this.length,
                        value: maxT,
                        index: index
                    }))
                }
            },
            getParameterAt: function (offset) {
                for (var i, j = this.index; i = j, !(0 == j || this.parts[--j].offset < offset););
                for (var l = this.parts.length; l > i; i++) {
                    var part = this.parts[i];
                    if (part.offset >= offset) {
                        this.index = i;
                        var prev = this.parts[i - 1],
                            prevVal = prev && prev.index == part.index ? prev.value : 0,
                            prevLen = prev ? prev.offset : 0;
                        return {
                            value: prevVal + (part.value - prevVal) * (offset - prevLen) / (part.offset - prevLen),
                            index: part.index
                        }
                    }
                }
                var part = this.parts[this.parts.length - 1];
                return {
                    value: 1,
                    index: part.index
                }
            },
            evaluate: function (offset, type) {
                var param = this.getParameterAt(offset);
                return Curve.evaluate(this.curves[param.index], param.value, type)
            },
            drawPart: function (ctx, from, to) {
                from = this.getParameterAt(from), to = this.getParameterAt(to);
                for (var i = from.index; i <= to.index; i++) {
                    var curve = Curve.getPart(this.curves[i], i == from.index ? from.value : 0, i == to.index ? to.value : 1);
                    i == from.index && ctx.moveTo(curve[0], curve[1]), ctx.bezierCurveTo.apply(ctx, curve.slice(2))
                }
            }
        }),
        PathFitter = Base.extend({
            initialize: function (path, error) {
                this.points = [];
                for (var prev, segments = path._segments, i = 0, l = segments.length; l > i; i++) {
                    var point = segments[i].point.clone();
                    prev && prev.equals(point) || (this.points.push(point), prev = point)
                }
                this.error = error
            },
            fit: function () {
                var points = this.points,
                    length = points.length;
                return this.segments = length > 0 ? [new Segment(points[0])] : [], length > 1 && this.fitCubic(0, length - 1, points[1].subtract(points[0]).normalize(), points[length - 2].subtract(points[length - 1]).normalize()), this.segments
            },
            fitCubic: function (first, last, tan1, tan2) {
                if (last - first == 1) {
                    var pt1 = this.points[first],
                        pt2 = this.points[last],
                        dist = pt1.getDistance(pt2) / 3;
                    return void this.addCurve([pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2])
                }
                for (var split, uPrime = this.chordLengthParameterize(first, last), maxError = Math.max(this.error, this.error * this.error), i = 0; 4 >= i; i++) {
                    var curve = this.generateBezier(first, last, uPrime, tan1, tan2),
                        max = this.findMaxError(first, last, curve, uPrime);
                    if (max.error < this.error) return void this.addCurve(curve);
                    if (split = max.index, max.error >= maxError) break;
                    this.reparameterize(first, last, uPrime, curve), maxError = max.error
                }
                var V1 = this.points[split - 1].subtract(this.points[split]),
                    V2 = this.points[split].subtract(this.points[split + 1]),
                    tanCenter = V1.add(V2).divide(2).normalize();
                this.fitCubic(first, split, tan1, tanCenter), this.fitCubic(split, last, tanCenter.negate(), tan2)
            },
            addCurve: function (curve) {
                var prev = this.segments[this.segments.length - 1];
                prev.setHandleOut(curve[1].subtract(curve[0])), this.segments.push(new Segment(curve[3], curve[2].subtract(curve[3])))
            },
            generateBezier: function (first, last, uPrime, tan1, tan2) {
                for (var epsilon = 1e-11, pt1 = this.points[first], pt2 = this.points[last], C = [
                    [0, 0],
                    [0, 0]
                ], X = [0, 0], i = 0, l = last - first + 1; l > i; i++) {
                    var u = uPrime[i],
                        t = 1 - u,
                        b = 3 * u * t,
                        b0 = t * t * t,
                        b1 = b * t,
                        b2 = b * u,
                        b3 = u * u * u,
                        a1 = tan1.normalize(b1),
                        a2 = tan2.normalize(b2),
                        tmp = this.points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
                    C[0][0] += a1.dot(a1), C[0][1] += a1.dot(a2), C[1][0] = C[0][1], C[1][1] += a2.dot(a2), X[0] += a1.dot(tmp), X[1] += a2.dot(tmp)
                }
                var alpha1, alpha2, detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
                if (Math.abs(detC0C1) > epsilon) {
                    var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
                        detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
                    alpha1 = detXC1 / detC0C1, alpha2 = detC0X / detC0C1
                } else {
                    var c0 = C[0][0] + C[0][1],
                        c1 = C[1][0] + C[1][1];
                    alpha1 = alpha2 = Math.abs(c0) > epsilon ? X[0] / c0 : Math.abs(c1) > epsilon ? X[1] / c1 : 0
                }
                var segLength = pt2.getDistance(pt1);
                return epsilon *= segLength, (epsilon > alpha1 || epsilon > alpha2) && (alpha1 = alpha2 = segLength / 3), [pt1, pt1.add(tan1.normalize(alpha1)), pt2.add(tan2.normalize(alpha2)), pt2]
            },
            reparameterize: function (first, last, u, curve) {
                for (var i = first; last >= i; i++) u[i - first] = this.findRoot(curve, this.points[i], u[i - first])
            },
            findRoot: function (curve, point, u) {
                for (var curve1 = [], curve2 = [], i = 0; 2 >= i; i++) curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
                for (var i = 0; 1 >= i; i++) curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
                var pt = this.evaluate(3, curve, u),
                    pt1 = this.evaluate(2, curve1, u),
                    pt2 = this.evaluate(1, curve2, u),
                    diff = pt.subtract(point),
                    df = pt1.dot(pt1) + diff.dot(pt2);
                return Math.abs(df) < 1e-5 ? u : u - diff.dot(pt1) / df
            },
            evaluate: function (degree, curve, t) {
                for (var tmp = curve.slice(), i = 1; degree >= i; i++)
                    for (var j = 0; degree - i >= j; j++) tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
                return tmp[0]
            },
            chordLengthParameterize: function (first, last) {
                for (var u = [0], i = first + 1; last >= i; i++) u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
                for (var i = 1, m = last - first; m >= i; i++) u[i] /= u[m];
                return u
            },
            findMaxError: function (first, last, curve, u) {
                for (var index = Math.floor((last - first + 1) / 2), maxDist = 0, i = first + 1; last > i; i++) {
                    var P = this.evaluate(3, curve, u[i - first]),
                        v = P.subtract(this.points[i]),
                        dist = v.x * v.x + v.y * v.y;
                    dist >= maxDist && (maxDist = dist, index = i)
                }
                return {
                    error: maxDist,
                    index: index
                }
            }
        }),
        TextItem = Item.extend({
            _class: "TextItem",
            _boundsSelected: !0,
            _applyMatrix: !1,
            _canApplyMatrix: !1,
            _serializeFields: {
                content: null
            },
            _boundsGetter: "getBounds",
            initialize: function (arg) {
                this._content = "", this._lines = [];
                var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;
                this._initialize(hasProps && arg, !hasProps && Point.read(arguments))
            },
            _equals: function (item) {
                return this._content === item._content
            },
            _clone: function _clone(copy) {
                return copy.setContent(this._content), _clone.base.call(this, copy)
            },
            getContent: function () {
                return this._content
            },
            setContent: function (content) {
                this._content = "" + content, this._lines = this._content.split(/\r\n|\n|\r/gm), this._changed(265)
            },
            isEmpty: function () {
                return !this._content
            },
            getCharacterStyle: "#getStyle",
            setCharacterStyle: "#setStyle",
            getParagraphStyle: "#getStyle",
            setParagraphStyle: "#setStyle"
        }),
        PointText = TextItem.extend({
            _class: "PointText",
            initialize: function () {
                TextItem.apply(this, arguments)
            },
            clone: function (insert) {
                return this._clone(new PointText(Item.NO_INSERT), insert)
            },
            getPoint: function () {
                var point = this._matrix.getTranslation();
                return new LinkedPoint(point.x, point.y, this, "setPoint")
            },
            setPoint: function () {
                var point = Point.read(arguments);
                this.translate(point.subtract(this._matrix.getTranslation()))
            },
            _draw: function (ctx) {
                if (this._content) {
                    this._setStyles(ctx);
                    var style = this._style,
                        lines = this._lines,
                        leading = style.getLeading(),
                        shadowColor = ctx.shadowColor;
                    ctx.font = style.getFontStyle(), ctx.textAlign = style.getJustification();
                    for (var i = 0, l = lines.length; l > i; i++) {
                        ctx.shadowColor = shadowColor;
                        var line = lines[i];
                        style.hasFill() && (ctx.fillText(line, 0, 0), ctx.shadowColor = "rgba(0,0,0,0)"), style.hasStroke() && ctx.strokeText(line, 0, 0), ctx.translate(0, leading)
                    }
                }
            },
            _getBounds: function (getter, matrix) {
                var style = this._style,
                    lines = this._lines,
                    numLines = lines.length,
                    justification = style.getJustification(),
                    leading = style.getLeading(),
                    width = this.getView().getTextWidth(style.getFontStyle(), lines),
                    x = 0;
                "left" !== justification && (x -= width / ("center" === justification ? 2 : 1));
                var bounds = new Rectangle(x, numLines ? -.75 * leading : 0, width, numLines * leading);
                return matrix ? matrix._transformBounds(bounds, bounds) : bounds
            }
        }),
        Color = Base.extend(new function () {
            function fromCSS(string) {
                var components, match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/);
                if (match) {
                    components = [0, 0, 0];
                    for (var i = 0; 3 > i; i++) {
                        var value = match[i + 1];
                        components[i] = parseInt(1 == value.length ? value + value : value, 16) / 255
                    }
                } else if (match = string.match(/^rgba?\((.*)\)$/)) {
                    components = match[1].split(",");
                    for (var i = 0, l = components.length; l > i; i++) {
                        var value = +components[i];
                        components[i] = 3 > i ? value / 255 : value
                    }
                } else {
                    var cached = colorCache[string];
                    if (!cached) {
                        colorCtx || (colorCtx = CanvasProvider.getContext(1, 1), colorCtx.globalCompositeOperation = "copy"), colorCtx.fillStyle = "rgba(0,0,0,0)", colorCtx.fillStyle = string, colorCtx.fillRect(0, 0, 1, 1);
                        var data = colorCtx.getImageData(0, 0, 1, 1).data;
                        cached = colorCache[string] = [data[0] / 255, data[1] / 255, data[2] / 255]
                    }
                    components = cached.slice()
                }
                return components
            }
            var colorCtx, types = {
                    gray: ["gray"],
                    rgb: ["red", "green", "blue"],
                    hsb: ["hue", "saturation", "brightness"],
                    hsl: ["hue", "saturation", "lightness"],
                    gradient: ["gradient", "origin", "destination", "highlight"]
                },
                componentParsers = {},
                colorCache = {},
                hsbIndices = [
                    [0, 3, 1],
                    [2, 0, 1],
                    [1, 0, 3],
                    [1, 2, 0],
                    [3, 1, 0],
                    [0, 1, 2]
                ],
                converters = {
                    "rgb-hsb": function (r, g, b) {
                        var max = Math.max(r, g, b),
                            min = Math.min(r, g, b),
                            delta = max - min,
                            h = 0 === delta ? 0 : 60 * (max == r ? (g - b) / delta + (b > g ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4);
                        return [h, 0 === max ? 0 : delta / max, max]
                    },
                    "hsb-rgb": function (h, s, b) {
                        h = (h / 60 % 6 + 6) % 6;
                        var i = Math.floor(h),
                            f = h - i,
                            i = hsbIndices[i],
                            v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
                        return [v[i[0]], v[i[1]], v[i[2]]]
                    },
                    "rgb-hsl": function (r, g, b) {
                        var max = Math.max(r, g, b),
                            min = Math.min(r, g, b),
                            delta = max - min,
                            achromatic = 0 === delta,
                            h = achromatic ? 0 : 60 * (max == r ? (g - b) / delta + (b > g ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4),
                            l = (max + min) / 2,
                            s = achromatic ? 0 : .5 > l ? delta / (max + min) : delta / (2 - max - min);
                        return [h, s, l]
                    },
                    "hsl-rgb": function (h, s, l) {
                        if (h = (h / 360 % 1 + 1) % 1, 0 === s) return [l, l, l];
                        for (var t3s = [h + 1 / 3, h, h - 1 / 3], t2 = .5 > l ? l * (1 + s) : l + s - l * s, t1 = 2 * l - t2, c = [], i = 0; 3 > i; i++) {
                            var t3 = t3s[i];
                            0 > t3 && (t3 += 1), t3 > 1 && (t3 -= 1), c[i] = 1 > 6 * t3 ? t1 + 6 * (t2 - t1) * t3 : 1 > 2 * t3 ? t2 : 2 > 3 * t3 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1
                        }
                        return c
                    },
                    "rgb-gray": function (r, g, b) {
                        return [.2989 * r + .587 * g + .114 * b]
                    },
                    "gray-rgb": function (g) {
                        return [g, g, g]
                    },
                    "gray-hsb": function (g) {
                        return [0, 0, g]
                    },
                    "gray-hsl": function (g) {
                        return [0, 0, g]
                    },
                    "gradient-rgb": function () {
                        return []
                    },
                    "rgb-gradient": function () {
                        return []
                    }
                };
            return Base.each(types, function (properties, type) {
                componentParsers[type] = [], Base.each(properties, function (name, index) {
                    var part = Base.capitalize(name),
                        hasOverlap = /^(hue|saturation)$/.test(name),
                        parser = componentParsers[type][index] = "gradient" === name ? function (value) {
                            var current = this._components[0];
                            return value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {
                                readNull: !0
                            }), current !== value && (current && current._removeOwner(this), value && value._addOwner(this)), value
                        } : "gradient" === type ? function () {
                            return Point.read(arguments, 0, {
                                readNull: "highlight" === name,
                                clone: !0
                            })
                        } : function (value) {
                            return null == value || isNaN(value) ? 0 : value
                        };
                    this["get" + part] = function () {
                        return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index]
                    }, this["set" + part] = function (value) {
                        this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) || (this._components = this._convert(type), this._properties = types[type], this._type = type), value = parser.call(this, value), null != value && (this._components[index] = value, this._changed())
                    }
                }, this)
            }, {
                _class: "Color",
                _readIndex: !0,
                initialize: function Color(arg) {
                    var type, components, alpha, values, slice = Array.prototype.slice,
                        args = arguments,
                        read = 0;
                    Array.isArray(arg) && (args = arg, arg = args[0]);
                    var argType = null != arg && typeof arg;
                    if ("string" === argType && arg in types && (type = arg, arg = args[1], Array.isArray(arg) ? (components = arg, alpha = args[2]) : (this.__read && (read = 1), args = slice.call(args, 1), argType = typeof arg)), !components) {
                        if (values = "number" === argType ? args : "object" === argType && null != arg.length ? arg : null) {
                            type || (type = values.length >= 3 ? "rgb" : "gray");
                            var length = types[type].length;
                            alpha = values[length], this.__read && (read += values === arguments ? length + (null != alpha ? 1 : 0) : 1), values.length > length && (values = slice.call(values, 0, length))
                        } else if ("string" === argType) type = "rgb", components = fromCSS(arg), 4 === components.length && (alpha = components[3], components.length--);
                        else if ("object" === argType)
                            if (arg.constructor === Color) {
                                if (type = arg._type, components = arg._components.slice(), alpha = arg._alpha, "gradient" === type)
                                    for (var i = 1, l = components.length; l > i; i++) {
                                        var point = components[i];
                                        point && (components[i] = point.clone())
                                    }
                            } else if (arg.constructor === Gradient) type = "gradient", values = args;
                        else {
                            type = "hue" in arg ? "lightness" in arg ? "hsl" : "hsb" : "gradient" in arg || "stops" in arg || "radial" in arg ? "gradient" : "gray" in arg ? "gray" : "rgb";
                            var properties = types[type];
                            parsers = componentParsers[type], this._components = components = [];
                            for (var i = 0, l = properties.length; l > i; i++) {
                                var value = arg[properties[i]];
                                null == value && 0 === i && "gradient" === type && "stops" in arg && (value = {
                                    stops: arg.stops,
                                    radial: arg.radial
                                }), value = parsers[i].call(this, value), null != value && (components[i] = value)
                            }
                            alpha = arg.alpha
                        }
                        this.__read && type && (read = 1)
                    }
                    if (this._type = type || "rgb", "gradient" === type && (this._id = Color._id = (Color._id || 0) + 1), !components) {
                        this._components = components = [];
                        for (var parsers = componentParsers[this._type], i = 0, l = parsers.length; l > i; i++) {
                            var value = parsers[i].call(this, values && values[i]);
                            null != value && (components[i] = value)
                        }
                    }
                    this._components = components, this._properties = types[this._type], this._alpha = alpha, this.__read && (this.__read = read)
                },
                _serialize: function (options, dictionary) {
                    var components = this.getComponents();
                    return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, !0, dictionary)
                },
                _changed: function () {
                    this._canvasStyle = null, this._owner && this._owner._changed(65)
                },
                _convert: function (type) {
                    var converter;
                    return this._type === type ? this._components.slice() : (converter = converters[this._type + "-" + type]) ? converter.apply(this, this._components) : converters["rgb-" + type].apply(this, converters[this._type + "-rgb"].apply(this, this._components))
                },
                convert: function (type) {
                    return new Color(type, this._convert(type), this._alpha)
                },
                getType: function () {
                    return this._type
                },
                setType: function (type) {
                    this._components = this._convert(type), this._properties = types[type], this._type = type
                },
                getComponents: function () {
                    var components = this._components.slice();
                    return null != this._alpha && components.push(this._alpha), components
                },
                getAlpha: function () {
                    return null != this._alpha ? this._alpha : 1
                },
                setAlpha: function (alpha) {
                    this._alpha = null == alpha ? null : Math.min(Math.max(alpha, 0), 1), this._changed()
                },
                hasAlpha: function () {
                    return null != this._alpha
                },
                equals: function (color) {
                    var col = Base.isPlainValue(color) ? Color.read(arguments) : color;
                    return col === this || col && this._class === col._class && this._type === col._type && this._alpha === col._alpha && Base.equals(this._components, col._components) || !1
                },
                toString: function () {
                    for (var properties = this._properties, parts = [], isGradient = "gradient" === this._type, f = Formatter.instance, i = 0, l = properties.length; l > i; i++) {
                        var value = this._components[i];
                        null != value && parts.push(properties[i] + ": " + (isGradient ? value : f.number(value)))
                    }
                    return null != this._alpha && parts.push("alpha: " + f.number(this._alpha)), "{ " + parts.join(", ") + " }"
                },
                toCSS: function (hex) {
                    function convert(val) {
                        return Math.round(255 * (0 > val ? 0 : val > 1 ? 1 : val))
                    }
                    var components = this._convert("rgb"),
                        alpha = hex || null == this._alpha ? 1 : this._alpha;
                    return components = [convert(components[0]), convert(components[1]), convert(components[2])], 1 > alpha && components.push(0 > alpha ? 0 : alpha), hex ? "#" + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (4 == components.length ? "rgba(" : "rgb(") + components.join(",") + ")"
                },
                toCanvasStyle: function (ctx) {
                    if (this._canvasStyle) return this._canvasStyle;
                    if ("gradient" !== this._type) return this._canvasStyle = this.toCSS();
                    var canvasGradient, components = this._components,
                        gradient = components[0],
                        stops = gradient._stops,
                        origin = components[1],
                        destination = components[2];
                    if (gradient._radial) {
                        var radius = destination.getDistance(origin),
                            highlight = components[3];
                        if (highlight) {
                            var vector = highlight.subtract(origin);
                            vector.getLength() > radius && (highlight = origin.add(vector.normalize(radius - .1)))
                        }
                        var start = highlight || origin;
                        canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius)
                    } else canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
                    for (var i = 0, l = stops.length; l > i; i++) {
                        var stop = stops[i];
                        canvasGradient.addColorStop(stop._rampPoint, stop._color.toCanvasStyle())
                    }
                    return this._canvasStyle = canvasGradient
                },
                transform: function (matrix) {
                    if ("gradient" === this._type) {
                        for (var components = this._components, i = 1, l = components.length; l > i; i++) {
                            var point = components[i];
                            matrix._transformPoint(point, point, !0)
                        }
                        this._changed()
                    }
                },
                statics: {
                    _types: types,
                    random: function () {
                        var random = Math.random;
                        return new Color(random(), random(), random())
                    }
                }
            })
        }, new function () {
            var operators = {
                add: function (a, b) {
                    return a + b
                },
                subtract: function (a, b) {
                    return a - b
                },
                multiply: function (a, b) {
                    return a * b
                },
                divide: function (a, b) {
                    return a / b
                }
            };
            return Base.each(operators, function (operator, name) {
                this[name] = function (color) {
                    color = Color.read(arguments);
                    for (var type = this._type, components1 = this._components, components2 = color._convert(type), i = 0, l = components1.length; l > i; i++) components2[i] = operator(components1[i], components2[i]);
                    return new Color(type, components2, null != this._alpha ? operator(this._alpha, color.getAlpha()) : null)
                }
            }, {})
        });
    Base.each(Color._types, function (properties, type) {
        var ctor = this[Base.capitalize(type) + "Color"] = function (arg) {
            var argType = null != arg && typeof arg,
                components = "object" === argType && null != arg.length ? arg : "string" === argType ? null : arguments;
            return components ? new Color(type, components) : new Color(arg)
        };
        if (3 == type.length) {
            var acronym = type.toUpperCase();
            Color[acronym] = this[acronym + "Color"] = ctor
        }
    }, Base.exports);
    var Gradient = Base.extend({
            _class: "Gradient",
            initialize: function Gradient(stops, radial) {
                this._id = Gradient._id = (Gradient._id || 0) + 1, stops && this._set(stops) && (stops = radial = null), this._stops || this.setStops(stops || ["white", "black"]), null == this._radial && this.setRadial("string" == typeof radial && "radial" === radial || radial || !1)
            },
            _serialize: function (options, dictionary) {
                return dictionary.add(this, function () {
                    return Base.serialize([this._stops, this._radial], options, !0, dictionary)
                })
            },
            _changed: function () {
                for (var i = 0, l = this._owners && this._owners.length; l > i; i++) this._owners[i]._changed()
            },
            _addOwner: function (color) {
                this._owners || (this._owners = []), this._owners.push(color)
            },
            _removeOwner: function (color) {
                var index = this._owners ? this._owners.indexOf(color) : -1; - 1 != index && (this._owners.splice(index, 1), 0 === this._owners.length && (this._owners = undefined))
            },
            clone: function () {
                for (var stops = [], i = 0, l = this._stops.length; l > i; i++) stops[i] = this._stops[i].clone();
                return new Gradient(stops)
            },
            getStops: function () {
                return this._stops
            },
            setStops: function (stops) {
                if (this.stops)
                    for (var i = 0, l = this._stops.length; l > i; i++) this._stops[i]._owner = undefined;
                if (stops.length < 2) throw new Error("Gradient stop list needs to contain at least two stops.");
                this._stops = GradientStop.readAll(stops, 0, {
                    clone: !0
                });
                for (var i = 0, l = this._stops.length; l > i; i++) {
                    var stop = this._stops[i];
                    stop._owner = this, stop._defaultRamp && stop.setRampPoint(i / (l - 1))
                }
                this._changed()
            },
            getRadial: function () {
                return this._radial
            },
            setRadial: function (radial) {
                this._radial = radial, this._changed()
            },
            equals: function (gradient) {
                if (gradient === this) return !0;
                if (gradient && this._class === gradient._class && this._stops.length === gradient._stops.length) {
                    for (var i = 0, l = this._stops.length; l > i; i++)
                        if (!this._stops[i].equals(gradient._stops[i])) return !1;
                    return !0
                }
                return !1
            }
        }),
        GradientStop = Base.extend({
            _class: "GradientStop",
            initialize: function (arg0, arg1) {
                if (arg0) {
                    var color, rampPoint;
                    arg1 === undefined && Array.isArray(arg0) ? (color = arg0[0], rampPoint = arg0[1]) : arg0.color ? (color = arg0.color, rampPoint = arg0.rampPoint) : (color = arg0, rampPoint = arg1), this.setColor(color), this.setRampPoint(rampPoint)
                }
            },
            clone: function () {
                return new GradientStop(this._color.clone(), this._rampPoint)
            },
            _serialize: function (options, dictionary) {
                return Base.serialize([this._color, this._rampPoint], options, !0, dictionary)
            },
            _changed: function () {
                this._owner && this._owner._changed(65)
            },
            getRampPoint: function () {
                return this._rampPoint
            },
            setRampPoint: function (rampPoint) {
                this._defaultRamp = null == rampPoint, this._rampPoint = rampPoint || 0, this._changed()
            },
            getColor: function () {
                return this._color
            },
            setColor: function (color) {
                this._color = Color.read(arguments), this._color === color && (this._color = color.clone()), this._color._owner = this, this._changed()
            },
            equals: function (stop) {
                return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._rampPoint == stop._rampPoint || !1
            }
        }),
        Style = Base.extend(new function () {
            var defaults = {
                    fillColor: undefined,
                    strokeColor: undefined,
                    strokeWidth: 1,
                    strokeCap: "butt",
                    strokeJoin: "miter",
                    miterLimit: 10,
                    dashOffset: 0,
                    dashArray: [],
                    windingRule: "nonzero",
                    shadowColor: undefined,
                    shadowBlur: 0,
                    shadowOffset: new Point,
                    selectedColor: undefined,
                    fontFamily: "sans-serif",
                    fontWeight: "normal",
                    fontSize: 12,
                    font: "sans-serif",
                    leading: null,
                    justification: "left"
                },
                flags = {
                    strokeWidth: 97,
                    strokeCap: 97,
                    strokeJoin: 97,
                    miterLimit: 97,
                    fontFamily: 9,
                    fontWeight: 9,
                    fontSize: 9,
                    font: 9,
                    leading: 9,
                    justification: 9
                },
                item = {},
                fields = {
                    _defaults: defaults,
                    _textDefaults: new Base(defaults, {
                        fillColor: new Color
                    }),
                    beans: !0
                };
            return Base.each(defaults, function (value, key) {
                var isColor = /Color$/.test(key),
                    part = Base.capitalize(key),
                    flag = flags[key],
                    set = "set" + part,
                    get = "get" + part;
                fields[set] = function (value) {
                    var owner = this._owner,
                        children = owner && owner._children;
                    if (children && children.length > 0 && !(owner instanceof CompoundPath))
                        for (var i = 0, l = children.length; l > i; i++) children[i]._style[set](value);
                    else {
                        var old = this._values[key];
                        old != value && (isColor && (old && (old._owner = undefined), value && value.constructor === Color && (value._owner && (value = value.clone()), value._owner = owner)), this._values[key] = value, owner && owner._changed(flag || 65))
                    }
                }, fields[get] = function (_dontMerge) {
                    var value, owner = this._owner,
                        children = owner && owner._children;
                    if (!children || 0 === children.length || _dontMerge || owner instanceof CompoundPath) {
                        var value = this._values[key];
                        return value === undefined ? (value = this._defaults[key], value && value.clone && (value = value.clone()), this._values[key] = value) : !isColor || value && value.constructor === Color || (this._values[key] = value = Color.read([value], 0, {
                            readNull: !0,
                            clone: !0
                        }), value && (value._owner = owner)), value
                    }
                    for (var i = 0, l = children.length; l > i; i++) {
                        var childValue = children[i]._style[get]();
                        if (0 === i) value = childValue;
                        else if (!Base.equals(value, childValue)) return undefined
                    }
                    return value
                }, item[get] = function () {
                    return this._style[get]()
                }, item[set] = function (value) {
                    this._style[set](value)
                }
            }), Item.inject(item), fields
        }, {
            _class: "Style",
            initialize: function (style, _owner, _project) {
                this._values = {}, this._owner = _owner, this._project = _owner && _owner._project || _project || paper.project, _owner instanceof TextItem && (this._defaults = this._textDefaults), style && this.set(style)
            },
            set: function (style) {
                var isStyle = style instanceof Style,
                    values = isStyle ? style._values : style;
                if (values)
                    for (var key in values)
                        if (key in this._defaults) {
                            var value = values[key];
                            this[key] = value && isStyle && value.clone ? value.clone() : value
                        }
            },
            equals: function (style) {
                return style === this || style && this._class === style._class && Base.equals(this._values, style._values) || !1
            },
            hasFill: function () {
                return !!this.getFillColor()
            },
            hasStroke: function () {
                return !!this.getStrokeColor() && this.getStrokeWidth() > 0
            },
            hasShadow: function () {
                return !!this.getShadowColor() && this.getShadowBlur() > 0
            },
            getView: function () {
                return this._project.getView()
            },
            getFontStyle: function () {
                var fontSize = this.getFontSize();
                return this.getFontWeight() + " " + fontSize + (/[a-z]/i.test(fontSize + "") ? " " : "px ") + this.getFontFamily()
            },
            getFont: "#getFontFamily",
            setFont: "#setFontFamily",
            getLeading: function getLeading() {
                var leading = getLeading.base.call(this),
                    fontSize = this.getFontSize();
                return /pt|em|%|px/.test(fontSize) && (fontSize = this.getView().getPixelSize(fontSize)), null != leading ? leading : 1.2 * fontSize
            }
        }),
        DomElement = new function () {
            function create(nodes, parent) {
                for (var res = [], i = 0, l = nodes && nodes.length; l > i;) {
                    var el = nodes[i++];
                    if ("string" == typeof el) el = document.createElement(el);
                    else if (!el || !el.nodeType) continue;
                    Base.isPlainObject(nodes[i]) && DomElement.set(el, nodes[i++]), Array.isArray(nodes[i]) && create(nodes[i++], el), parent && parent.appendChild(el), res.push(el)
                }
                return res
            }

            function handlePrefix(el, name, set, value) {
                for (var prefixes = ["webkit", "moz", "Moz", "ms", "o", ""], suffix = name[0].toUpperCase() + name.substring(1), i = 0; 6 > i; i++) {
                    var prefix = prefixes[i],
                        key = prefix ? prefix + suffix : name;
                    if (key in el) {
                        if (!set) return el[key];
                        el[key] = value;
                        break
                    }
                }
            }
            var special = /^(checked|value|selected|disabled)$/i,
                translated = {
                    text: "textContent",
                    html: "innerHTML"
                },
                unitless = {
                    lineHeight: 1,
                    zoom: 1,
                    zIndex: 1,
                    opacity: 1
                };
            return {
                create: function (nodes, parent) {
                    var isArray = Array.isArray(nodes),
                        res = create(isArray ? nodes : arguments, isArray ? parent : null);
                    return 1 == res.length ? res[0] : res
                },
                find: function (selector, root) {
                    return (root || document).querySelector(selector)
                },
                findAll: function (selector, root) {
                    return (root || document).querySelectorAll(selector)
                },
                get: function (el, key) {
                    return el ? special.test(key) ? "value" === key || "string" != typeof el[key] ? el[key] : !0 : key in translated ? el[translated[key]] : el.getAttribute(key) : null
                },
                set: function (el, key, value) {
                    if ("string" != typeof key)
                        for (var name in key) key.hasOwnProperty(name) && this.set(el, name, key[name]);
                    else {
                        if (!el || value === undefined) return el;
                        special.test(key) ? el[key] = value : key in translated ? el[translated[key]] = value : "style" === key ? this.setStyle(el, value) : "events" === key ? DomEvent.add(el, value) : el.setAttribute(key, value)
                    }
                    return el
                },
                getStyles: function (el) {
                    var doc = el && 9 !== el.nodeType ? el.ownerDocument : el,
                        view = doc && doc.defaultView;
                    return view && view.getComputedStyle(el, "")
                },
                getStyle: function (el, key) {
                    return el && el.style[key] || this.getStyles(el)[key] || null
                },
                setStyle: function (el, key, value) {
                    if ("string" != typeof key)
                        for (var name in key) key.hasOwnProperty(name) && this.setStyle(el, name, key[name]);
                    else !/^-?[\d\.]+$/.test(value) || key in unitless || (value += "px"), el.style[key] = value;
                    return el
                },
                hasClass: function (el, cls) {
                    return new RegExp("\\s*" + cls + "\\s*").test(el.className)
                },
                addClass: function (el, cls) {
                    el.className = (el.className + " " + cls).trim()
                },
                removeClass: function (el, cls) {
                    el.className = el.className.replace(new RegExp("\\s*" + cls + "\\s*"), " ").trim()
                },
                remove: function (el) {
                    el.parentNode && el.parentNode.removeChild(el)
                },
                removeChildren: function (el) {
                    for (; el.firstChild;) el.removeChild(el.firstChild)
                },
                getBounds: function (el, viewport) {
                    var rect, doc = el.ownerDocument,
                        body = doc.body,
                        html = doc.documentElement;
                    try {
                        rect = el.getBoundingClientRect()
                    } catch (e) {
                        rect = {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        }
                    }
                    var x = rect.left - (html.clientLeft || body.clientLeft || 0),
                        y = rect.top - (html.clientTop || body.clientTop || 0);
                    if (!viewport) {
                        var view = doc.defaultView;
                        x += view.pageXOffset || html.scrollLeft || body.scrollLeft, y += view.pageYOffset || html.scrollTop || body.scrollTop
                    }
                    return new Rectangle(x, y, rect.width, rect.height)
                },
                getViewportBounds: function (el) {
                    var doc = el.ownerDocument,
                        view = doc.defaultView,
                        html = doc.documentElement;
                    return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight)
                },
                getOffset: function (el, viewport) {
                    return this.getBounds(el, viewport).getPoint()
                },
                getSize: function (el) {
                    return this.getBounds(el, !0).getSize()
                },
                isInvisible: function (el) {
                    return this.getSize(el).equals(new Size(0, 0))
                },
                isInView: function (el) {
                    return !this.isInvisible(el) && this.getViewportBounds(el).intersects(this.getBounds(el, !0))
                },
                getPrefixed: function (el, name) {
                    return handlePrefix(el, name)
                },
                setPrefixed: function (el, name, value) {
                    if ("object" == typeof name)
                        for (var key in name) handlePrefix(el, key, !0, name[key]);
                    else handlePrefix(el, name, !0, value)
                }
            }
        },
        DomEvent = {
            add: function (el, events) {
                for (var type in events)
                    for (var func = events[type], parts = type.split(/[\s,]+/g), i = 0, l = parts.length; l > i; i++) el.addEventListener(parts[i], func, !1)
            },
            remove: function (el, events) {
                for (var type in events)
                    for (var func = events[type], parts = type.split(/[\s,]+/g), i = 0, l = parts.length; l > i; i++) el.removeEventListener(parts[i], func, !1)
            },
            getPoint: function (event) {
                var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
                return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop)
            },
            getTarget: function (event) {
                return event.target || event.srcElement
            },
            getRelatedTarget: function (event) {
                return event.relatedTarget || event.toElement
            },
            getOffset: function (event, target) {
                return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)))
            },
            stop: function (event) {
                event.stopPropagation(), event.preventDefault()
            }
        };
    DomEvent.requestAnimationFrame = new function () {
        function handleCallbacks() {
            for (var i = callbacks.length - 1; i >= 0; i--) {
                var entry = callbacks[i],
                    func = entry[0],
                    el = entry[1];
                (!el || ("true" == PaperScope.getAttribute(el, "keepalive") || focused) && DomElement.isInView(el)) && (callbacks.splice(i, 1), func())
            }
            nativeRequest && (callbacks.length ? nativeRequest(handleCallbacks) : requested = !1)
        }
        var timer, nativeRequest = DomElement.getPrefixed(window, "requestAnimationFrame"),
            requested = !1,
            callbacks = [],
            focused = !0;
        return DomEvent.add(window, {
                focus: function () {
                    focused = !0
                },
                blur: function () {
                    focused = !1
                }
            }),
            function (callback, element) {
                callbacks.push([callback, element]), nativeRequest ? requested || (nativeRequest(handleCallbacks), requested = !0) : timer || (timer = setInterval(handleCallbacks, 1e3 / 60))
            }
    };
    var View = Base.extend(Callback, {
            _class: "View",
            initialize: function View(project, element) {
                this._project = project, this._scope = project._scope, this._element = element;
                var size;
                this._pixelRatio || (this._pixelRatio = window.devicePixelRatio || 1), this._id = element.getAttribute("id"), null == this._id && element.setAttribute("id", this._id = "view-" + View._id++), DomEvent.add(element, this._viewEvents);
                var none = "none";
                if (DomElement.setPrefixed(element.style, {
                    userSelect: none,
                    touchAction: none,
                    touchCallout: none,
                    contentZooming: none,
                    userDrag: none,
                    tapHighlightColor: "rgba(0,0,0,0)"
                }), PaperScope.hasAttribute(element, "resize")) {
                    var offset = DomElement.getOffset(element, !0),
                        that = this;
                    size = DomElement.getViewportBounds(element).getSize().subtract(offset), this._windowEvents = {
                        resize: function () {
                            DomElement.isInvisible(element) || (offset = DomElement.getOffset(element, !0)), that.setViewSize(DomElement.getViewportBounds(element).getSize().subtract(offset))
                        }
                    }, DomEvent.add(window, this._windowEvents)
                } else if (size = DomElement.getSize(element), size.isNaN() || size.isZero()) {
                    var getSize = function (name) {
                        return element[name] || parseInt(element.getAttribute(name), 10)
                    };
                    size = new Size(getSize("width"), getSize("height"))
                }
                if (this._setViewSize(size), PaperScope.hasAttribute(element, "stats") && "undefined" != typeof Stats) {
                    this._stats = new Stats;
                    var stats = this._stats.domElement,
                        style = stats.style,
                        offset = DomElement.getOffset(element);
                    style.position = "absolute", style.left = offset.x + "px", style.top = offset.y + "px", document.body.appendChild(stats)
                }
                View._views.push(this), View._viewsById[this._id] = this, this._viewSize = size, (this._matrix = new Matrix)._owner = this, this._zoom = 1, View._focused || (View._focused = this), this._frameItems = {}, this._frameItemCount = 0
            },
            remove: function () {
                return this._project ? (View._focused === this && (View._focused = null), View._views.splice(View._views.indexOf(this), 1), delete View._viewsById[this._id], this._project._view === this && (this._project._view = null), DomEvent.remove(this._element, this._viewEvents), DomEvent.remove(window, this._windowEvents), this._element = this._project = null, this.detach("frame"), this._animate = !1, this._frameItems = {}, !0) : !1
            },
            _events: {
                onFrame: {
                    install: function () {
                        this.play()
                    },
                    uninstall: function () {
                        this.pause()
                    }
                },
                onResize: {}
            },
            _animate: !1,
            _time: 0,
            _count: 0,
            _requestFrame: function () {
                var that = this;
                DomEvent.requestAnimationFrame(function () {
                    that._requested = !1, that._animate && (that._requestFrame(), that._handleFrame())
                }, this._element), this._requested = !0
            },
            _handleFrame: function () {
                paper = this._scope;
                var now = Date.now() / 1e3,
                    delta = this._before ? now - this._before : 0;
                this._before = now, this._handlingFrame = !0, this.fire("frame", new Base({
                    delta: delta,
                    time: this._time += delta,
                    count: this._count++
                })), this._stats && this._stats.update(), this._handlingFrame = !1, this.update()
            },
            _animateItem: function (item, animate) {
                var items = this._frameItems;
                animate ? (items[item._id] = {
                    item: item,
                    time: 0,
                    count: 0
                }, 1 === ++this._frameItemCount && this.attach("frame", this._handleFrameItems)) : (delete items[item._id], 0 === --this._frameItemCount && this.detach("frame", this._handleFrameItems))
            },
            _handleFrameItems: function (event) {
                for (var i in this._frameItems) {
                    var entry = this._frameItems[i];
                    entry.item.fire("frame", new Base(event, {
                        time: entry.time += event.delta,
                        count: entry.count++
                    }))
                }
            },
            _update: function () {
                this._project._needsUpdate = !0, this._handlingFrame || (this._animate ? this._handleFrame() : this.update())
            },
            _changed: function (flags) {
                1 & flags && (this._project._needsUpdate = !0)
            },
            _transform: function (matrix) {
                this._matrix.concatenate(matrix), this._bounds = null, this._update()
            },
            getElement: function () {
                return this._element
            },
            getPixelRatio: function () {
                return this._pixelRatio
            },
            getResolution: function () {
                return 72 * this._pixelRatio
            },
            getViewSize: function () {
                var size = this._viewSize;
                return new LinkedSize(size.width, size.height, this, "setViewSize")
            },
            setViewSize: function () {
                var size = Size.read(arguments),
                    delta = size.subtract(this._viewSize);
                delta.isZero() || (this._viewSize.set(size.width, size.height), this._setViewSize(size), this._bounds = null, this.fire("resize", {
                    size: size,
                    delta: delta
                }), this._update())
            },
            _setViewSize: function (size) {
                var element = this._element;
                element.width = size.width, element.height = size.height
            },
            getBounds: function () {
                return this._bounds || (this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point, this._viewSize))), this._bounds
            },
            getSize: function () {
                return this.getBounds().getSize()
            },
            getCenter: function () {
                return this.getBounds().getCenter()
            },
            setCenter: function (center) {
                center = Point.read(arguments), this.scrollBy(center.subtract(this.getCenter()))
            },
            getZoom: function () {
                return this._zoom
            },
            setZoom: function (zoom) {
                this._transform((new Matrix).scale(zoom / this._zoom, this.getCenter())), this._zoom = zoom
            },
            isVisible: function () {
                return DomElement.isInView(this._element)
            },
            scrollBy: function () {
                this._transform((new Matrix).translate(Point.read(arguments).negate()))
            },
            play: function () {
                this._animate = !0, this._requested || this._requestFrame()
            },
            pause: function () {
                this._animate = !1
            },
            draw: function () {
                this.update()
            },
            projectToView: function () {
                return this._matrix._transformPoint(Point.read(arguments))
            },
            viewToProject: function () {
                return this._matrix._inverseTransform(Point.read(arguments))
            }
        }, {
            statics: {
                _views: [],
                _viewsById: {},
                _id: 0,
                create: function (project, element) {
                    return "string" == typeof element && (element = document.getElementById(element)), new CanvasView(project, element)
                }
            }
        }, new function () {
            function getView(event) {
                var target = DomEvent.getTarget(event);
                return target.getAttribute && View._viewsById[target.getAttribute("id")]
            }

            function viewToProject(view, event) {
                return view.viewToProject(DomEvent.getOffset(event, view._element))
            }

            function updateFocus() {
                if (!View._focused || !View._focused.isVisible())
                    for (var i = 0, l = View._views.length; l > i; i++) {
                        var view = View._views[i];
                        if (view && view.isVisible()) {
                            View._focused = tempFocus = view;
                            break
                        }
                    }
            }

            function handleMouseMove(view, point, event) {
                view._handleEvent("mousemove", point, event);
                var tool = view._scope.tool;
                return tool && tool._handleEvent(dragging && tool.responds("mousedrag") ? "mousedrag" : "mousemove", point, event), view.update(), tool
            }
            var tool, prevFocus, tempFocus, mousedown, mousemove, mouseup, dragging = !1,
                navigator = window.navigator;
            navigator.pointerEnabled || navigator.msPointerEnabled ? (mousedown = "pointerdown MSPointerDown", mousemove = "pointermove MSPointerMove", mouseup = "pointerup pointercancel MSPointerUp MSPointerCancel") : (mousedown = "touchstart", mousemove = "touchmove", mouseup = "touchend touchcancel", "ontouchstart" in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i) || (mousedown += " mousedown", mousemove += " mousemove", mouseup += " mouseup"));
            var viewEvents = {
                    "selectstart dragstart": function (event) {
                        dragging && event.preventDefault()
                    }
                },
                docEvents = {
                    mouseout: function (event) {
                        var view = View._focused,
                            target = DomEvent.getRelatedTarget(event);
                        !view || target && "HTML" !== target.nodeName || handleMouseMove(view, viewToProject(view, event), event)
                    },
                    scroll: updateFocus
                };
            return viewEvents[mousedown] = function (event) {
                var view = View._focused = getView(event),
                    point = viewToProject(view, event);
                dragging = !0, view._handleEvent("mousedown", point, event), (tool = view._scope.tool) && tool._handleEvent("mousedown", point, event), view.update()
            }, docEvents[mousemove] = function (event) {
                var view = View._focused;
                if (!dragging) {
                    var target = getView(event);
                    target ? (view !== target && handleMouseMove(view, viewToProject(view, event), event), prevFocus = view, view = View._focused = tempFocus = target) : tempFocus && tempFocus === view && (view = View._focused = prevFocus, updateFocus())
                }
                if (view) {
                    var point = viewToProject(view, event);
                    (dragging || view.getBounds().contains(point)) && (tool = handleMouseMove(view, point, event))
                }
            }, docEvents[mouseup] = function (event) {
                var view = View._focused;
                if (view && dragging) {
                    var point = viewToProject(view, event);
                    dragging = !1, view._handleEvent("mouseup", point, event), tool && tool._handleEvent("mouseup", point, event), view.update()
                }
            }, DomEvent.add(document, docEvents), DomEvent.add(window, {
                load: updateFocus
            }), {
                _viewEvents: viewEvents,
                _handleEvent: function () {},
                statics: {
                    updateFocus: updateFocus
                }
            }
        }),
        CanvasView = View.extend({
            _class: "CanvasView",
            initialize: function (project, canvas) {
                if (!(canvas instanceof HTMLCanvasElement)) {
                    var size = Size.read(arguments);
                    if (size.isZero()) throw new Error("Cannot create CanvasView with the provided argument: " + canvas);
                    canvas = CanvasProvider.getCanvas(size)
                }
                if (this._context = canvas.getContext("2d"), this._eventCounters = {}, this._pixelRatio = 1, "off" !== PaperScope.getAttribute(canvas, "hidpi")) {
                    var deviceRatio = window.devicePixelRatio || 1,
                        backingStoreRatio = DomElement.getPrefixed(this._context, "backingStorePixelRatio") || 1;
                    this._pixelRatio = deviceRatio / backingStoreRatio
                }
                View.call(this, project, canvas)
            },
            _setViewSize: function (size) {
                var width = size.width,
                    height = size.height,
                    pixelRatio = this._pixelRatio,
                    element = this._element,
                    style = element.style;
                element.width = width * pixelRatio, element.height = height * pixelRatio, 1 !== pixelRatio && (style.width = width + "px", style.height = height + "px", this._context.scale(pixelRatio, pixelRatio))
            },
            getPixelSize: function (size) {
                var ctx = this._context,
                    prevFont = ctx.font;
                return ctx.font = size + " serif", size = parseFloat(ctx.font), ctx.font = prevFont, size
            },
            getTextWidth: function (font, lines) {
                var ctx = this._context,
                    prevFont = ctx.font,
                    width = 0;
                ctx.font = font;
                for (var i = 0, l = lines.length; l > i; i++) width = Math.max(width, ctx.measureText(lines[i]).width);
                return ctx.font = prevFont, width
            },
            update: function () {
                var project = this._project;
                if (!project || !project._needsUpdate) return !1;
                var ctx = this._context,
                    size = this._viewSize;
                return ctx.clearRect(0, 0, size.width + 1, size.height + 1), project.draw(ctx, this._matrix, this._pixelRatio), project._needsUpdate = !1, !0
            }
        }, new function () {
            function callEvent(view, type, event, point, target, lastPoint) {
                function call(obj) {
                    return obj.responds(type) && (mouseEvent || (mouseEvent = new MouseEvent(type, event, point, target, lastPoint ? point.subtract(lastPoint) : null)), obj.fire(type, mouseEvent) && mouseEvent.isStopped) ? (event.preventDefault(), !0) : void 0
                }
                for (var mouseEvent, item = target; item;) {
                    if (call(item)) return !0;
                    item = item.getParent()
                }
                return call(view) ? !0 : !1
            }
            var downPoint, lastPoint, overPoint, downItem, lastItem, overItem, dragItem, dblClick, clickTime;
            return {
                _handleEvent: function (type, point, event) {
                    if (this._eventCounters[type]) {
                        var project = this._project,
                            hit = project.hitTest(point, {
                                tolerance: this._scope.settings.hitTolerance,
                                fill: !0,
                                stroke: !0
                            }),
                            item = hit && hit.item,
                            stopped = !1;
                        switch (type) {
                        case "mousedown":
                            for (stopped = callEvent(this, type, event, point, item), dblClick = lastItem == item && Date.now() - clickTime < 300, downItem = lastItem = item, downPoint = lastPoint = overPoint = point, dragItem = !stopped && item; dragItem && !dragItem.responds("mousedrag");) dragItem = dragItem._parent;
                            break;
                        case "mouseup":
                            stopped = callEvent(this, type, event, point, item, downPoint), dragItem && (lastPoint && !lastPoint.equals(point) && callEvent(this, "mousedrag", event, point, dragItem, lastPoint), item !== dragItem && (overPoint = point, callEvent(this, "mousemove", event, point, item, overPoint))), !stopped && item && item === downItem && (clickTime = Date.now(), callEvent(this, dblClick && downItem.responds("doubleclick") ? "doubleclick" : "click", event, downPoint, item), dblClick = !1), downItem = dragItem = null;
                            break;
                        case "mousemove":
                            dragItem && (stopped = callEvent(this, "mousedrag", event, point, dragItem, lastPoint)), stopped || (item !== overItem && (overPoint = point), stopped = callEvent(this, type, event, point, item, overPoint)), lastPoint = overPoint = point, item !== overItem && (callEvent(this, "mouseleave", event, point, overItem), overItem = item, callEvent(this, "mouseenter", event, point, item))
                        }
                        return stopped
                    }
                }
            }
        }),
        Event = Base.extend({
            _class: "Event",
            initialize: function (event) {
                this.event = event
            },
            isPrevented: !1,
            isStopped: !1,
            preventDefault: function () {
                this.isPrevented = !0, this.event.preventDefault()
            },
            stopPropagation: function () {
                this.isStopped = !0, this.event.stopPropagation()
            },
            stop: function () {
                this.stopPropagation(), this.preventDefault()
            },
            getModifiers: function () {
                return Key.modifiers
            }
        }),
        KeyEvent = Event.extend({
            _class: "KeyEvent",
            initialize: function (down, key, character, event) {
                Event.call(this, event), this.type = down ? "keydown" : "keyup", this.key = key, this.character = character
            },
            toString: function () {
                return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }"
            }
        }),
        Key = new function () {
            function handleKey(down, keyCode, charCode, event) {
                var name, character = charCode ? String.fromCharCode(charCode) : "",
                    specialKey = specialKeys[keyCode],
                    key = specialKey || character.toLowerCase(),
                    type = down ? "keydown" : "keyup",
                    view = View._focused,
                    scope = view && view.isVisible() && view._scope,
                    tool = scope && scope.tool;
                keyMap[key] = down, specialKey && (name = Base.camelize(specialKey)) in modifiers && (modifiers[name] = down), down ? charCodeMap[keyCode] = charCode : delete charCodeMap[keyCode], tool && tool.responds(type) && (paper = scope, tool.fire(type, new KeyEvent(down, key, character, event)), view && view.update())
            }
            var downCode, specialKeys = {
                    8: "backspace",
                    9: "tab",
                    13: "enter",
                    16: "shift",
                    17: "control",
                    18: "option",
                    19: "pause",
                    20: "caps-lock",
                    27: "escape",
                    32: "space",
                    35: "end",
                    36: "home",
                    37: "left",
                    38: "up",
                    39: "right",
                    40: "down",
                    46: "delete",
                    91: "command",
                    93: "command",
                    224: "command"
                },
                specialChars = {
                    9: !0,
                    13: !0,
                    32: !0
                },
                modifiers = new Base({
                    shift: !1,
                    control: !1,
                    option: !1,
                    command: !1,
                    capsLock: !1,
                    space: !1
                }),
                charCodeMap = {},
                keyMap = {};
            return DomEvent.add(document, {
                keydown: function (event) {
                    var code = event.which || event.keyCode;
                    code in specialKeys || modifiers.command ? handleKey(!0, code, code in specialChars || modifiers.command ? code : 0, event) : downCode = code
                },
                keypress: function (event) {
                    null != downCode && (handleKey(!0, downCode, event.which || event.keyCode, event), downCode = null)
                },
                keyup: function (event) {
                    var code = event.which || event.keyCode;
                    code in charCodeMap && handleKey(!1, code, charCodeMap[code], event)
                }
            }), DomEvent.add(window, {
                blur: function (event) {
                    for (var code in charCodeMap) handleKey(!1, code, charCodeMap[code], event)
                }
            }), {
                modifiers: modifiers,
                isDown: function (key) {
                    return !!keyMap[key]
                }
            }
        },
        MouseEvent = Event.extend({
            _class: "MouseEvent",
            initialize: function (type, event, point, target, delta) {
                Event.call(this, event), this.type = type, this.point = point, this.target = target, this.delta = delta
            },
            toString: function () {
                return "{ type: '" + this.type + "', point: " + this.point + ", target: " + this.target + (this.delta ? ", delta: " + this.delta : "") + ", modifiers: " + this.getModifiers() + " }"
            }
        });
    Base.extend(Callback, {
        _class: "Palette",
        _events: ["onChange"],
        initialize: function (title, components, values) {
            var parent = DomElement.find(".palettejs-panel") || DomElement.find("body").appendChild(DomElement.create("div", {
                "class": "palettejs-panel"
            }));
            this._element = parent.appendChild(DomElement.create("table", {
                "class": "palettejs-pane"
            })), this._title = title, values || (values = {});
            for (var name in this.components = components) {
                var component = components[name];
                component instanceof Component || (null == component.value && (component.value = values[name]), component.name = name, component = components[name] = new Component(component)), this._element.appendChild(component._element), component._palette = this, values[name] === undefined && (values[name] = component.value)
            }
            this.values = Base.each(values, function (value, name) {
                var component = components[name];
                component && Base.define(values, name, {
                    enumerable: !0,
                    configurable: !0,
                    get: function () {
                        return component._value
                    },
                    set: function (val) {
                        component.setValue(val)
                    }
                })
            }), window.paper && paper.palettes.push(this)
        },
        reset: function () {
            for (var i in this.components) this.components[i].reset()
        },
        remove: function () {
            DomElement.remove(this._element)
        }
    });
    var Component = Base.extend(Callback, {
            _class: "Component",
            _events: ["onChange", "onClick"],
            _types: {
                "boolean": {
                    type: "checkbox",
                    value: "checked"
                },
                string: {
                    type: "text"
                },
                number: {
                    type: "number",
                    number: !0
                },
                button: {
                    type: "button"
                },
                text: {
                    tag: "div",
                    value: "text"
                },
                slider: {
                    type: "range",
                    number: !0
                },
                list: {
                    tag: "select",
                    setOptions: function () {
                        DomElement.removeChildren(this._input), DomElement.create(Base.each(this._options, function (option) {
                            this.push("option", {
                                value: option,
                                text: option
                            })
                        }, []), this._input)
                    }
                },
                color: {
                    type: "color",
                    getValue: function (value) {
                        return new Color(value)
                    },
                    setValue: function (value) {
                        return new Color(value).toCSS("color" === DomElement.get(this._input, "type"))
                    }
                }
            },
            initialize: function Component(obj) {
                this._id = Component._id = (Component._id || 0) + 1, this._type = obj.type in this._types ? obj.type : "options" in obj ? "list" : "onClick" in obj ? "button" : typeof obj.value, this._meta = this._types[this._type] || {
                    type: this._type
                };
                var that = this,
                    id = "component-" + this._id;
                this._dontFire = !0, this._input = DomElement.create(this._meta.tag || "input", {
                    id: id,
                    type: this._meta.type,
                    events: {
                        change: function () {
                            that.setValue(DomElement.get(this, that._meta.value || "value"))
                        },
                        click: function () {
                            that.fire("click")
                        }
                    }
                }), this.attach("change", function (value) {
                    this._dontFire || this._palette.fire("change", this, this.name, value)
                }), this._element = DomElement.create("tr", ["td", [this._label = DomElement.create("label", {
                    "for": id
                })], "td", [this._input]]), Base.each(obj, function (value, key) {
                    this[key] = value
                }, this), this._defaultValue = this._value, this._dontFire = !1
            },
            getType: function () {
                return this._type
            },
            getLabel: function () {
                return this.__label
            },
            setLabel: function (label) {
                this.__label = label, DomElement.set(this._label, "text", label + ":")
            },
            getOptions: function () {
                return this._options
            },
            setOptions: function (options) {
                this._options = options;
                var setOptions = this._meta.setOptions;
                setOptions && setOptions.call(this)
            },
            getValue: function () {
                var value = this._value,
                    getValue = this._meta.getValue;
                return getValue ? getValue.call(this, value) : value
            },
            setValue: function (value) {
                var key = this._meta.value || "value",
                    setValue = this._meta.setValue;
                setValue && (value = setValue.call(this, value)), DomElement.set(this._input, key, value), value = DomElement.get(this._input, key), this._meta.number && (value = parseFloat(value, 10)), this._value !== value && (this._value = value, this._dontFire || this.fire("change", this.getValue()))
            },
            getRange: function () {
                return [parseFloat(DomElement.get(this._input, "min")), parseFloat(DomElement.get(this._input, "max"))]
            },
            setRange: function (min, max) {
                var range = Array.isArray(min) ? min : [min, max];
                DomElement.set(this._input, {
                    min: range[0],
                    max: range[1]
                })
            },
            getMin: function () {
                return this.getRange()[0]
            },
            setMin: function (min) {
                this.setRange(min, this.getMax())
            },
            getMax: function () {
                return this.getRange()[1]
            },
            setMax: function (max) {
                this.setRange(this.getMin(), max)
            },
            getStep: function () {
                return parseFloat(DomElement.get(this._input, "step"))
            },
            setStep: function (step) {
                DomElement.set(this._input, "step", step)
            },
            reset: function () {
                this.setValue(this._defaultValue)
            }
        }),
        ToolEvent = Event.extend({
            _class: "ToolEvent",
            _item: null,
            initialize: function (tool, type, event) {
                this.tool = tool, this.type = type, this.event = event
            },
            _choosePoint: function (point, toolPoint) {
                return point ? point : toolPoint ? toolPoint.clone() : null
            },
            getPoint: function () {
                return this._choosePoint(this._point, this.tool._point)
            },
            setPoint: function (point) {
                this._point = point
            },
            getLastPoint: function () {
                return this._choosePoint(this._lastPoint, this.tool._lastPoint)
            },
            setLastPoint: function (lastPoint) {
                this._lastPoint = lastPoint
            },
            getDownPoint: function () {
                return this._choosePoint(this._downPoint, this.tool._downPoint)
            },
            setDownPoint: function (downPoint) {
                this._downPoint = downPoint
            },
            getMiddlePoint: function () {
                return !this._middlePoint && this.tool._lastPoint ? this.tool._point.add(this.tool._lastPoint).divide(2) : this._middlePoint
            },
            setMiddlePoint: function (middlePoint) {
                this._middlePoint = middlePoint
            },
            getDelta: function () {
                return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta
            },
            setDelta: function (delta) {
                this._delta = delta
            },
            getCount: function () {
                return /^mouse(down|up)$/.test(this.type) ? this.tool._downCount : this.tool._count
            },
            setCount: function (count) {
                this.tool[/^mouse(down|up)$/.test(this.type) ? "downCount" : "count"] = count
            },
            getItem: function () {
                if (!this._item) {
                    var result = this.tool._scope.project.hitTest(this.getPoint());
                    if (result) {
                        for (var item = result.item, parent = item._parent;
                            /^(Group|CompoundPath)$/.test(parent._class);) item = parent, parent = parent._parent;
                        this._item = item
                    }
                }
                return this._item
            },
            setItem: function (item) {
                this._item = item
            },
            toString: function () {
                return "{ type: " + this.type + ", point: " + this.getPoint() + ", count: " + this.getCount() + ", modifiers: " + this.getModifiers() + " }"
            }
        }),
        Tool = PaperScopeItem.extend({
            _class: "Tool",
            _list: "tools",
            _reference: "tool",
            _events: ["onActivate", "onDeactivate", "onEditOptions", "onMouseDown", "onMouseUp", "onMouseDrag", "onMouseMove", "onKeyDown", "onKeyUp"],
            initialize: function (props) {
                PaperScopeItem.call(this), this._firstMove = !0, this._count = 0, this._downCount = 0, this._set(props)
            },
            getMinDistance: function () {
                return this._minDistance
            },
            setMinDistance: function (minDistance) {
                this._minDistance = minDistance, null != this._minDistance && null != this._maxDistance && this._minDistance > this._maxDistance && (this._maxDistance = this._minDistance)
            },
            getMaxDistance: function () {
                return this._maxDistance
            },
            setMaxDistance: function (maxDistance) {
                this._maxDistance = maxDistance, null != this._minDistance && null != this._maxDistance && this._maxDistance < this._minDistance && (this._minDistance = maxDistance)
            },
            getFixedDistance: function () {
                return this._minDistance == this._maxDistance ? this._minDistance : null
            },
            setFixedDistance: function (distance) {
                this._minDistance = distance, this._maxDistance = distance
            },
            _updateEvent: function (type, point, minDistance, maxDistance, start, needsChange, matchMaxDistance) {
                if (!start) {
                    if (null != minDistance || null != maxDistance) {
                        var minDist = null != minDistance ? minDistance : 0,
                            vector = point.subtract(this._point),
                            distance = vector.getLength();
                        if (minDist > distance) return !1;
                        var maxDist = null != maxDistance ? maxDistance : 0;
                        if (0 != maxDist)
                            if (distance > maxDist) point = this._point.add(vector.normalize(maxDist));
                            else if (matchMaxDistance) return !1
                    }
                    if (needsChange && point.equals(this._point)) return !1
                }
                switch (this._lastPoint = start && "mousemove" == type ? point : this._point, this._point = point, type) {
                case "mousedown":
                    this._lastPoint = this._downPoint, this._downPoint = this._point, this._downCount++;
                    break;
                case "mouseup":
                    this._lastPoint = this._downPoint
                }
                return this._count = start ? 0 : this._count + 1, !0
            },
            _fireEvent: function (type, event) {
                var sets = paper.project._removeSets;
                if (sets) {
                    "mouseup" === type && (sets.mousedrag = null);
                    var set = sets[type];
                    if (set) {
                        for (var id in set) {
                            var item = set [id];
                            for (var key in sets) {
                                var other = sets[key];
                                other && other != set && delete other[item._id]
                            }
                            item.remove()
                        }
                        sets[type] = null
                    }
                }
                return this.responds(type) && this.fire(type, new ToolEvent(this, type, event))
            },
            _handleEvent: function (type, point, event) {
                paper = this._scope;
                var called = !1;
                switch (type) {
                case "mousedown":
                    this._updateEvent(type, point, null, null, !0, !1, !1), called = this._fireEvent(type, event);
                    break;
                case "mousedrag":
                    for (var needsChange = !1, matchMaxDistance = !1; this._updateEvent(type, point, this.minDistance, this.maxDistance, !1, needsChange, matchMaxDistance);) called = this._fireEvent(type, event) || called, needsChange = !0, matchMaxDistance = !0;
                    break;
                case "mouseup":
                    !point.equals(this._point) && this._updateEvent("mousedrag", point, this.minDistance, this.maxDistance, !1, !1, !1) && (called = this._fireEvent("mousedrag", event)), this._updateEvent(type, point, null, this.maxDistance, !1, !1, !1), called = this._fireEvent(type, event) || called, this._updateEvent(type, point, null, null, !0, !1, !1), this._firstMove = !0;
                    break;
                case "mousemove":
                    for (; this._updateEvent(type, point, this.minDistance, this.maxDistance, this._firstMove, !0, !1);) called = this._fireEvent(type, event) || called, this._firstMove = !1
                }
                return called && event.preventDefault(), called
            }
        }),
        Http = {
            request: function (method, url, callback) {
                var xhr = new(window.ActiveXObject || XMLHttpRequest)("Microsoft.XMLHTTP");
                return xhr.open(method.toUpperCase(), url, !0), "overrideMimeType" in xhr && xhr.overrideMimeType("text/plain"), xhr.onreadystatechange = function () {
                    if (4 === xhr.readyState) {
                        var status = xhr.status;
                        if (0 !== status && 200 !== status) throw new Error("Could not load " + url + " (Error " + status + ")");
                        callback.call(xhr, xhr.responseText)
                    }
                }, xhr.send(null)
            }
        },
        CanvasProvider = {
            canvases: [],
            getCanvas: function (width, height, pixelRatio) {
                var canvas, init = !0;
                "object" == typeof width && (pixelRatio = height, height = width.height, width = width.width), pixelRatio ? 1 !== pixelRatio && (width *= pixelRatio, height *= pixelRatio) : pixelRatio = 1, canvas = this.canvases.length ? this.canvases.pop() : document.createElement("canvas");
                var ctx = canvas.getContext("2d");
                return canvas.width === width && canvas.height === height ? init && ctx.clearRect(0, 0, width + 1, height + 1) : (canvas.width = width, canvas.height = height), ctx.save(), 1 !== pixelRatio && ctx.scale(pixelRatio, pixelRatio), canvas
            },
            getContext: function (width, height, pixelRatio) {
                return this.getCanvas(width, height, pixelRatio).getContext("2d")
            },
            release: function (obj) {
                var canvas = obj.canvas ? obj.canvas : obj;
                canvas.getContext("2d").restore(), this.canvases.push(canvas)
            }
        },
        BlendMode = new function () {
            function getLum(r, g, b) {
                return .2989 * r + .587 * g + .114 * b
            }

            function setLum(r, g, b, l) {
                var d = l - getLum(r, g, b);
                dr = r + d, dg = g + d, db = b + d;
                var l = getLum(dr, dg, db),
                    mn = min(dr, dg, db),
                    mx = max(dr, dg, db);
                if (0 > mn) {
                    var lmn = l - mn;
                    dr = l + (dr - l) * l / lmn, dg = l + (dg - l) * l / lmn, db = l + (db - l) * l / lmn
                }
                if (mx > 255) {
                    var ln = 255 - l,
                        mxl = mx - l;
                    dr = l + (dr - l) * ln / mxl, dg = l + (dg - l) * ln / mxl, db = l + (db - l) * ln / mxl
                }
            }

            function getSat(r, g, b) {
                return max(r, g, b) - min(r, g, b)
            }

            function setSat(r, g, b, s) {
                var md, col = [r, g, b],
                    mx = max(r, g, b),
                    mn = min(r, g, b);
                mn = mn === r ? 0 : mn === g ? 1 : 2, mx = mx === r ? 0 : mx === g ? 1 : 2, md = 0 === min(mn, mx) ? 1 === max(mn, mx) ? 2 : 1 : 0, col[mx] > col[mn] ? (col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]), col[mx] = s) : col[md] = col[mx] = 0, col[mn] = 0, dr = col[0], dg = col[1], db = col[2]
            }
            var sr, sg, sb, sa, br, bg, bb, ba, dr, dg, db, min = Math.min,
                max = Math.max,
                abs = Math.abs,
                modes = {
                    multiply: function () {
                        dr = br * sr / 255, dg = bg * sg / 255, db = bb * sb / 255
                    },
                    screen: function () {
                        dr = br + sr - br * sr / 255, dg = bg + sg - bg * sg / 255, db = bb + sb - bb * sb / 255
                    },
                    overlay: function () {
                        dr = 128 > br ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255, dg = 128 > bg ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255, db = 128 > bb ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255
                    },
                    "soft-light": function () {
                        var t = sr * br / 255;
                        dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255, t = sg * bg / 255, dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255, t = sb * bb / 255, db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255
                    },
                    "hard-light": function () {
                        dr = 128 > sr ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255, dg = 128 > sg ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255, db = 128 > sb ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255
                    },
                    "color-dodge": function () {
                        dr = 0 === br ? 0 : 255 === sr ? 255 : min(255, 255 * br / (255 - sr)), dg = 0 === bg ? 0 : 255 === sg ? 255 : min(255, 255 * bg / (255 - sg)), db = 0 === bb ? 0 : 255 === sb ? 255 : min(255, 255 * bb / (255 - sb))
                    },
                    "color-burn": function () {
                        dr = 255 === br ? 255 : 0 === sr ? 0 : max(0, 255 - 255 * (255 - br) / sr), dg = 255 === bg ? 255 : 0 === sg ? 0 : max(0, 255 - 255 * (255 - bg) / sg), db = 255 === bb ? 255 : 0 === sb ? 0 : max(0, 255 - 255 * (255 - bb) / sb)
                    },
                    darken: function () {
                        dr = sr > br ? br : sr, dg = sg > bg ? bg : sg, db = sb > bb ? bb : sb
                    },
                    lighten: function () {
                        dr = br > sr ? br : sr, dg = bg > sg ? bg : sg, db = bb > sb ? bb : sb
                    },
                    difference: function () {
                        dr = br - sr, 0 > dr && (dr = -dr), dg = bg - sg, 0 > dg && (dg = -dg), db = bb - sb, 0 > db && (db = -db)
                    },
                    exclusion: function () {
                        dr = br + sr * (255 - br - br) / 255, dg = bg + sg * (255 - bg - bg) / 255, db = bb + sb * (255 - bb - bb) / 255
                    },
                    hue: function () {
                        setSat(sr, sg, sb, getSat(br, bg, bb)), setLum(dr, dg, db, getLum(br, bg, bb))
                    },
                    saturation: function () {
                        setSat(br, bg, bb, getSat(sr, sg, sb)), setLum(dr, dg, db, getLum(br, bg, bb))
                    },
                    luminosity: function () {
                        setLum(br, bg, bb, getLum(sr, sg, sb))
                    },
                    color: function () {
                        setLum(sr, sg, sb, getLum(br, bg, bb))
                    },
                    add: function () {
                        dr = min(br + sr, 255), dg = min(bg + sg, 255), db = min(bb + sb, 255)
                    },
                    subtract: function () {
                        dr = max(br - sr, 0), dg = max(bg - sg, 0), db = max(bb - sb, 0)
                    },
                    average: function () {
                        dr = (br + sr) / 2, dg = (bg + sg) / 2, db = (bb + sb) / 2
                    },
                    negation: function () {
                        dr = 255 - abs(255 - sr - br), dg = 255 - abs(255 - sg - bg), db = 255 - abs(255 - sb - bb)
                    }
                },
                nativeModes = this.nativeModes = Base.each(["source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "lighter", "darker", "copy", "xor"], function (mode) {
                    this[mode] = !0
                }, {}),
                ctx = CanvasProvider.getContext(1, 1);
            Base.each(modes, function (func, mode) {
                var darken = "darken" === mode,
                    ok = !1;
                ctx.save();
                try {
                    ctx.fillStyle = darken ? "#300" : "#a00", ctx.fillRect(0, 0, 1, 1), ctx.globalCompositeOperation = mode, ctx.globalCompositeOperation === mode && (ctx.fillStyle = darken ? "#a00" : "#300", ctx.fillRect(0, 0, 1, 1), ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51)
                } catch (e) {}
                ctx.restore(), nativeModes[mode] = ok
            }), CanvasProvider.release(ctx), this.process = function (mode, srcContext, dstContext, alpha, offset) {
                var srcCanvas = srcContext.canvas,
                    normal = "normal" === mode;
                if (normal || nativeModes[mode]) dstContext.save(), dstContext.setTransform(1, 0, 0, 1, 0, 0), dstContext.globalAlpha = alpha, normal || (dstContext.globalCompositeOperation = mode), dstContext.drawImage(srcCanvas, offset.x, offset.y), dstContext.restore();
                else {
                    var process = modes[mode];
                    if (!process) return;
                    for (var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height), dst = dstData.data, src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data, i = 0, l = dst.length; l > i; i += 4) {
                        sr = src[i], br = dst[i], sg = src[i + 1], bg = dst[i + 1], sb = src[i + 2], bb = dst[i + 2], sa = src[i + 3], ba = dst[i + 3], process();
                        var a1 = sa * alpha / 255,
                            a2 = 1 - a1;
                        dst[i] = a1 * dr + a2 * br, dst[i + 1] = a1 * dg + a2 * bg, dst[i + 2] = a1 * db + a2 * bb, dst[i + 3] = sa * alpha + a2 * ba
                    }
                    dstContext.putImageData(dstData, offset.x, offset.y)
                }
            }
        },
        SVGStyles = Base.each({
            fillColor: ["fill", "color"],
            strokeColor: ["stroke", "color"],
            strokeWidth: ["stroke-width", "number"],
            strokeCap: ["stroke-linecap", "string"],
            strokeJoin: ["stroke-linejoin", "string"],
            miterLimit: ["stroke-miterlimit", "number"],
            dashArray: ["stroke-dasharray", "array"],
            dashOffset: ["stroke-dashoffset", "number"],
            fontFamily: ["font-family", "string"],
            fontWeight: ["font-weight", "string"],
            fontSize: ["font-size", "number"],
            justification: ["text-anchor", "lookup", {
                left: "start",
                center: "middle",
                right: "end"
            }],
            opacity: ["opacity", "number"],
            blendMode: ["mix-blend-mode", "string"]
        }, function (entry, key) {
            var part = Base.capitalize(key),
                lookup = entry[2];
            this[key] = {
                type: entry[1],
                property: key,
                attribute: entry[0],
                toSVG: lookup,
                fromSVG: lookup && Base.each(lookup, function (value, name) {
                    this[value] = name
                }, {}),
                get: "get" + part,
                set: "set" + part
            }
        }, {}),
        SVGNamespaces = {
            href: "http://www.w3.org/1999/xlink",
            xlink: "http://www.w3.org/2000/xmlns"
        };
    return new function () {
        function setAttributes(node, attrs) {
            for (var key in attrs) {
                var val = attrs[key],
                    namespace = SVGNamespaces[key];
                "number" == typeof val && (val = formatter.number(val)), namespace ? node.setAttributeNS(namespace, key, val) : node.setAttribute(key, val)
            }
            return node
        }

        function createElement(tag, attrs) {
            return setAttributes(document.createElementNS("http://www.w3.org/2000/svg", tag), attrs)
        }

        function getTransform(item, coordinates, center) {
            var matrix = item._matrix,
                trans = matrix.getTranslation(),
                attrs = {};
            if (coordinates) {
                matrix = matrix.shiftless();
                var point = matrix._inverseTransform(trans);
                attrs[center ? "cx" : "x"] = point.x, attrs[center ? "cy" : "y"] = point.y, trans = null
            }
            if (!matrix.isIdentity()) {
                var decomposed = matrix.decompose();
                if (decomposed && !decomposed.shearing) {
                    var parts = [],
                        angle = decomposed.rotation,
                        scale = decomposed.scaling;
                    trans && !trans.isZero() && parts.push("translate(" + formatter.point(trans) + ")"), angle && parts.push("rotate(" + formatter.number(angle) + ")"), Numerical.isZero(scale.x - 1) && Numerical.isZero(scale.y - 1) || parts.push("scale(" + formatter.point(scale) + ")"), attrs.transform = parts.join(" ")
                } else attrs.transform = "matrix(" + matrix.getValues().join(",") + ")"
            }
            return attrs
        }

        function exportGroup(item, options) {
            for (var attrs = getTransform(item), children = item._children, node = createElement("g", attrs), i = 0, l = children.length; l > i; i++) {
                var child = children[i],
                    childNode = exportSVG(child, options);
                if (childNode)
                    if (child.isClipMask()) {
                        var clip = createElement("clipPath");
                        clip.appendChild(childNode), setDefinition(child, clip, "clip"), setAttributes(node, {
                            "clip-path": "url(#" + clip.id + ")"
                        })
                    } else node.appendChild(childNode)
            }
            return node
        }

        function exportRaster(item) {
            var attrs = getTransform(item, !0),
                size = item.getSize();
            return attrs.x -= size.width / 2, attrs.y -= size.height / 2, attrs.width = size.width, attrs.height = size.height, attrs.href = item.toDataURL(), createElement("image", attrs)
        }

        function exportPath(item, options) {
            if (options.matchShapes) {
                var shape = item.toShape(!1);
                if (shape) return exportShape(shape, options)
            }
            var type, attrs, segments = item._segments;
            if (0 === segments.length) return null;
            if (item.isPolygon())
                if (segments.length >= 3) {
                    type = item._closed ? "polygon" : "polyline";
                    var parts = [];
                    for (i = 0, l = segments.length; l > i; i++) parts.push(formatter.point(segments[i]._point));
                    attrs = {
                        points: parts.join(" ")
                    }
                } else {
                    type = "line";
                    var first = segments[0]._point,
                        last = segments[segments.length - 1]._point;
                    attrs = {
                        x1: first.x,
                        y1: first.y,
                        x2: last.x,
                        y2: last.y
                    }
                } else {
                type = "path";
                var data = item.getPathData();
                attrs = data && {
                    d: data
                }
            }
            return createElement(type, attrs)
        }

        function exportShape(item) {
            var type = item._type,
                radius = item._radius,
                attrs = getTransform(item, !0, "rectangle" !== type);
            if ("rectangle" === type) {
                type = "rect";
                var size = item._size,
                    width = size.width,
                    height = size.height;
                attrs.x -= width / 2, attrs.y -= height / 2, attrs.width = width, attrs.height = height, radius.isZero() && (radius = null)
            }
            return radius && ("circle" === type ? attrs.r = radius : (attrs.rx = radius.width, attrs.ry = radius.height)), createElement(type, attrs)
        }

        function exportCompoundPath(item) {
            var attrs = getTransform(item, !0),
                data = item.getPathData();
            return data && (attrs.d = data), createElement("path", attrs)
        }

        function exportPlacedSymbol(item, options) {
            var attrs = getTransform(item, !0),
                symbol = item.getSymbol(),
                symbolNode = getDefinition(symbol, "symbol"),
                definition = symbol.getDefinition(),
                bounds = definition.getBounds();
            return symbolNode || (symbolNode = createElement("symbol", {
                viewBox: formatter.rectangle(bounds)
            }), symbolNode.appendChild(exportSVG(definition, options)), setDefinition(symbol, symbolNode, "symbol")), attrs.href = "#" + symbolNode.id, attrs.x += bounds.x, attrs.y += bounds.y, attrs.width = formatter.number(bounds.width), attrs.height = formatter.number(bounds.height), createElement("use", attrs)
        }

        function exportGradient(color) {
            var gradientNode = getDefinition(color, "color");
            if (!gradientNode) {
                var attrs, gradient = color.getGradient(),
                    radial = gradient._radial,
                    origin = color.getOrigin().transform(),
                    destination = color.getDestination().transform();
                if (radial) {
                    attrs = {
                        cx: origin.x,
                        cy: origin.y,
                        r: origin.getDistance(destination)
                    };
                    var highlight = color.getHighlight();
                    highlight && (highlight = highlight.transform(), attrs.fx = highlight.x, attrs.fy = highlight.y)
                } else attrs = {
                    x1: origin.x,
                    y1: origin.y,
                    x2: destination.x,
                    y2: destination.y
                };
                attrs.gradientUnits = "userSpaceOnUse", gradientNode = createElement((radial ? "radial" : "linear") + "Gradient", attrs);
                for (var stops = gradient._stops, i = 0, l = stops.length; l > i; i++) {
                    var stop = stops[i],
                        stopColor = stop._color,
                        alpha = stopColor.getAlpha();
                    attrs = {
                        offset: stop._rampPoint,
                        "stop-color": stopColor.toCSS(!0)
                    }, 1 > alpha && (attrs["stop-opacity"] = alpha), gradientNode.appendChild(createElement("stop", attrs))
                }
                setDefinition(color, gradientNode, "color")
            }
            return "url(#" + gradientNode.id + ")"
        }

        function exportText(item) {
            var node = createElement("text", getTransform(item, !0));
            return node.textContent = item._content, node
        }

        function applyStyle(item, node) {
            var attrs = {},
                parent = item.getParent();
            return null != item._name && (attrs.id = item._name), Base.each(SVGStyles, function (entry) {
                var get = entry.get, type = entry.type, value = item[get]();
                if (!parent || !Base.equals(parent[get](), value)) {
                    if ("color" === type && null != value) {
                        var alpha = value.getAlpha();
                        1 > alpha && (attrs[entry.attribute + "-opacity"] = alpha)
                    }
                    attrs[entry.attribute] = null == value ? "none" : "number" === type ? formatter.number(value) : "color" === type ? value.gradient ? exportGradient(value, item) : value.toCSS(!0) : "array" === type ? value.join(",") : "lookup" === type ? entry.toSVG[value] : value
                }
            }), 1 === attrs.opacity && delete attrs.opacity, item._visible || (attrs.visibility = "hidden"), setAttributes(node, attrs)
        }

        function getDefinition(item, type) {
            return definitions || (definitions = {
                ids: {},
                svgs: {}
            }), item && definitions.svgs[type + "-" + item._id]
        }

        function setDefinition(item, node, type) {
            definitions || getDefinition();
            var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
            node.id = type + "-" + id, definitions.svgs[type + "-" + item._id] = node
        }

        function exportDefinitions(node, options) {
            var svg = node,
                defs = null;
            if (definitions) {
                svg = "svg" === node.nodeName.toLowerCase() && node;
                for (var i in definitions.svgs) defs || (svg || (svg = createElement("svg"), svg.appendChild(node)), defs = svg.insertBefore(createElement("defs"), svg.firstChild)), defs.appendChild(definitions.svgs[i]);
                definitions = null
            }
            return options.asString ? (new XMLSerializer).serializeToString(svg) : svg
        }

        function exportSVG(item, options) {
            var exporter = exporters[item._class],
                node = exporter && exporter(item, options);
            if (node && item._data) {
                var data = JSON.stringify(item._data);
                "{}" !== data && node.setAttribute("data-paper-data", data)
            }
            return node && applyStyle(item, node)
        }

        function setOptions(options) {
            return options || (options = {}), formatter = new Formatter(options.precision), options
        }
        var formatter, definitions, exporters = {
            Group: exportGroup,
            Layer: exportGroup,
            Raster: exportRaster,
            Path: exportPath,
            Shape: exportShape,
            CompoundPath: exportCompoundPath,
            PlacedSymbol: exportPlacedSymbol,
            PointText: exportText
        };
        Item.inject({
            exportSVG: function (options) {
                return options = setOptions(options), exportDefinitions(exportSVG(this, options), options)
            }
        }), Project.inject({
            exportSVG: function (options) {
                options = setOptions(options);
                for (var layers = this.layers, size = this.getView().getSize(), node = createElement("svg", {
                    x: 0,
                    y: 0,
                    width: size.width,
                    height: size.height,
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    "xmlns:xlink": "http://www.w3.org/1999/xlink"
                }), i = 0, l = layers.length; l > i; i++) node.appendChild(exportSVG(layers[i], options));
                return exportDefinitions(node, options)
            }
        })
    }, new function () {
        function getValue(node, name, isString, allowNull) {
            var namespace = SVGNamespaces[name],
                value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
            return "null" === value && (value = null), null == value ? allowNull ? null : isString ? "" : 0 : isString ? value : parseFloat(value)
        }

        function getPoint(node, x, y, allowNull) {
            return x = getValue(node, x, !1, allowNull), y = getValue(node, y, !1, allowNull), !allowNull || null != x && null != y ? new Point(x, y) : null
        }

        function getSize(node, w, h, allowNull) {
            return w = getValue(node, w, !1, allowNull), h = getValue(node, h, !1, allowNull), !allowNull || null != w && null != h ? new Size(w, h) : null
        }

        function convertValue(value, type, lookup) {
            return "none" === value ? null : "number" === type ? parseFloat(value) : "array" === type ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : "color" === type ? getDefinition(value) || value : "lookup" === type ? lookup[value] : value
        }

        function importGroup(node, type, isRoot, options) {
            var nodes = node.childNodes,
                isClip = "clippath" === type,
                item = new Group,
                project = item._project,
                currentStyle = project._currentStyle,
                children = [];
            isClip || (item = applyAttributes(item, node, isRoot), project._currentStyle = item._style.clone());
            for (var i = 0, l = nodes.length; l > i; i++) {
                var child, childNode = nodes[i];
                1 !== childNode.nodeType || !(child = importSVG(childNode, !1, options)) || child instanceof Symbol || children.push(child)
            }
            return item.addChildren(children), isClip && (item = applyAttributes(item.reduce(), node, isRoot)), project._currentStyle = currentStyle, (isClip || "defs" === type) && (item.remove(), item = null), item
        }

        function importPoly(node, type) {
            for (var coords = node.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g), points = [], i = 0, l = coords.length; l > i; i += 2) points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));
            var path = new Path(points);
            return "polygon" === type && path.closePath(), path
        }

        function importPath(node) {
            var data = node.getAttribute("d"),
                param = {
                    pathData: data
                };
            return data.match(/m/gi).length > 1 || /z\S+/i.test(data) ? new CompoundPath(param) : new Path(param)
        }

        function importGradient(node, type) {
            var gradient, id = (getValue(node, "href", !0) || "").substring(1),
                isRadial = "radialgradient" === type;
            if (id) gradient = definitions[id].getGradient();
            else {
                for (var nodes = node.childNodes, stops = [], i = 0, l = nodes.length; l > i; i++) {
                    var child = nodes[i];
                    1 === child.nodeType && stops.push(applyAttributes(new GradientStop, child))
                }
                gradient = new Gradient(stops, isRadial)
            }
            var origin, destination, highlight;
            return isRadial ? (origin = getPoint(node, "cx", "cy"), destination = origin.add(getValue(node, "r"), 0), highlight = getPoint(node, "fx", "fy", !0)) : (origin = getPoint(node, "x1", "y1"), destination = getPoint(node, "x2", "y2")), applyAttributes(new Color(gradient, origin, destination, highlight), node), null
        }

        function applyTransform(item, value, name, node) {
            for (var transforms = (node.getAttribute(name) || "").split(/\)\s*/g), matrix = new Matrix, i = 0, l = transforms.length; l > i; i++) {
                var transform = transforms[i];
                if (!transform) break;
                for (var parts = transform.split("("), command = parts[0], v = parts[1].split(/[\s,]+/g), j = 0, m = v.length; m > j; j++) v[j] = parseFloat(v[j]);
                switch (command) {
                case "matrix":
                    matrix.concatenate(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
                    break;
                case "rotate":
                    matrix.rotate(v[0], v[1], v[2]);
                    break;
                case "translate":
                    matrix.translate(v[0], v[1]);
                    break;
                case "scale":
                    matrix.scale(v);
                    break;
                case "skewX":
                    matrix.skew(v[0], 0);
                    break;
                case "skewY":
                    matrix.skew(0, v[0])
                }
            }
            item.transform(matrix)
        }

        function applyOpacity(item, value, name) {
            var color = item["fill-opacity" === name ? "getFillColor" : "getStrokeColor"]();
            color && color.setAlpha(parseFloat(value))
        }

        function getAttribute(node, name, styles) {
            var attr = node.attributes[name],
                value = attr && attr.value;
            if (!value) {
                var style = Base.camelize(name);
                value = node.style[style], value || styles.node[style] === styles.parent[style] || (value = styles.node[style])
            }
            return value ? "none" === value ? null : value : undefined
        }

        function applyAttributes(item, node, isRoot) {
            var styles = {
                node: DomElement.getStyles(node) || {},
                parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
            };
            return Base.each(attributes, function (apply, name) {
                var value = getAttribute(node, name, styles);
                value !== undefined && (item = Base.pick(apply(item, value, name, node, styles), item))
            }), item
        }

        function getDefinition(value) {
            var match = value && value.match(/\((?:#|)([^)']+)/);
            return match && definitions[match[1]]
        }

        function importSVG(source, isRoot, options) {
            function onLoadCallback(svg) {
                paper = scope;
                var item = importSVG(svg, isRoot, options),
                    onLoad = options.onLoad,
                    view = scope.project && scope.getView();
                onLoad && onLoad.call(this, item), view.update()
            }
            if (!source) return null;
            options ? "function" == typeof options && (options = {
                onLoad: options
            }) : options = {};
            var node = source,
                scope = paper;
            if (isRoot)
                if ("string" != typeof source || /^.*</.test(source)) {
                    if ("undefined" != typeof File && source instanceof File) {
                        var reader = new FileReader;
                        return reader.onload = function () {
                            onLoadCallback(reader.result)
                        }, reader.readAsText(source)
                    }
                } else {
                    if (node = document.getElementById(source), !node) return Http.request("get", source, onLoadCallback);
                    source = null
                }
            if ("string" == typeof source && (node = (new DOMParser).parseFromString(source, "image/svg+xml")), !node.nodeName) throw new Error("Unsupported SVG source: " + source);
            var item, type = node.nodeName.toLowerCase(),
                importer = importers[type],
                data = node.getAttribute && node.getAttribute("data-paper-data"),
                settings = scope.settings,
                prevApplyMatrix = settings.applyMatrix;
            return settings.applyMatrix = !1, item = importer && importer(node, type, isRoot, options) || null, settings.applyMatrix = prevApplyMatrix, item && (item instanceof Group || (item = applyAttributes(item, node, isRoot)), options.expandShapes && item instanceof Shape && (item.remove(), item = item.toPath()), data && (item._data = JSON.parse(data))), isRoot && (definitions = {}), item
        }
        var importers = {
                "#document": function (node, type, isRoot, options) {
                    for (var nodes = node.childNodes, i = 0, l = nodes.length; l > i; i++) {
                        var child = nodes[i];
                        if (1 === child.nodeType) {
                            var next = child.nextSibling;
                            document.body.appendChild(child);
                            var item = importSVG(child, isRoot, options);
                            return next ? node.insertBefore(child, next) : node.appendChild(child), item
                        }
                    }
                },
                g: importGroup,
                svg: importGroup,
                clippath: importGroup,
                polygon: importPoly,
                polyline: importPoly,
                path: importPath,
                lineargradient: importGradient,
                radialgradient: importGradient,
                image: function (node) {
                    var raster = new Raster(getValue(node, "href", !0));
                    return raster.attach("load", function () {
                        var size = getSize(node, "width", "height");
                        this.setSize(size);
                        var center = this._matrix._transformPoint(getPoint(node, "x", "y").add(size.divide(2)));
                        this.translate(center)
                    }), raster
                },
                symbol: function (node, type, isRoot, options) {
                    return new Symbol(importGroup(node, type, isRoot, options), !0)
                },
                defs: importGroup,
                use: function (node) {
                    var id = (getValue(node, "href", !0) || "").substring(1),
                        definition = definitions[id],
                        point = getPoint(node, "x", "y");
                    return definition ? definition instanceof Symbol ? definition.place(point) : definition.clone().translate(point) : null
                },
                circle: function (node) {
                    return new Shape.Circle(getPoint(node, "cx", "cy"), getValue(node, "r"))
                },
                ellipse: function (node) {
                    return new Shape.Ellipse({
                        center: getPoint(node, "cx", "cy"),
                        radius: getSize(node, "rx", "ry")
                    })
                },
                rect: function (node) {
                    var point = getPoint(node, "x", "y"),
                        size = getSize(node, "width", "height"),
                        radius = getSize(node, "rx", "ry");
                    return new Shape.Rectangle(new Rectangle(point, size), radius)
                },
                line: function (node) {
                    return new Path.Line(getPoint(node, "x1", "y1"), getPoint(node, "x2", "y2"))
                },
                text: function (node) {
                    var text = new PointText(getPoint(node, "x", "y").add(getPoint(node, "dx", "dy")));
                    return text.setContent(node.textContent.trim() || ""), text
                }
            },
            attributes = Base.each(SVGStyles, function (entry) {
                this[entry.attribute] = function (item, value) {
                    if (item[entry.set](convertValue(value, entry.type, entry.fromSVG)), "color" === entry.type && item instanceof Shape) {
                        var color = item[entry.get]();
                        color && color.transform((new Matrix).translate(item.getPosition(!0).negate()))
                    }
                }
            }, {
                id: function (item, value) {
                    definitions[value] = item, item.setName && item.setName(value)
                },
                "clip-path": function (item, value) {
                    var clip = getDefinition(value);
                    if (clip) {
                        if (clip = clip.clone(), clip.setClipMask(!0), !(item instanceof Group)) return new Group(clip, item);
                        item.insertChild(0, clip)
                    }
                },
                gradientTransform: applyTransform,
                transform: applyTransform,
                "fill-opacity": applyOpacity,
                "stroke-opacity": applyOpacity,
                visibility: function (item, value) {
                    item.setVisible("visible" === value)
                },
                "stop-color": function (item, value) {
                    item.setColor && item.setColor(value)
                },
                "stop-opacity": function (item, value) {
                    item._color && item._color.setAlpha(parseFloat(value))
                },
                offset: function (item, value) {
                    var percentage = value.match(/(.*)%$/);
                    item.setRampPoint(percentage ? percentage[1] / 100 : parseFloat(value))
                },
                viewBox: function (item, value, name, node, styles) {
                    var rect = new Rectangle(convertValue(value, "array")),
                        size = getSize(node, "width", "height", !0);
                    if (item instanceof Group) {
                        var scale = size ? rect.getSize().divide(size) : 1,
                            matrix = (new Matrix).translate(rect.getPoint()).scale(scale);
                        item.transform(matrix.inverted())
                    } else if (item instanceof Symbol) {
                        size && rect.setSize(size);
                        var clip = "visible" != getAttribute(node, "overflow", styles),
                            group = item._definition;
                        clip && !rect.contains(group.getBounds()) && (clip = new Shape.Rectangle(rect).transform(group._matrix), clip.setClipMask(!0), group.addChild(clip))
                    }
                }
            }),
            definitions = {};
        Item.inject({
            importSVG: function (node, options) {
                return this.addChild(importSVG(node, !0, options))
            }
        }), Project.inject({
            importSVG: function (node, options) {
                return this.activate(), importSVG(node, !0, options)
            }
        })
    }, Base.exports.PaperScript = function () {
        function _$_(left, operator, right) {
            var handler = binaryOperators[operator];
            if (left && left[handler]) {
                var res = left[handler](right);
                return "!=" === operator ? !res : res
            }
            switch (operator) {
            case "+":
                return left + right;
            case "-":
                return left - right;
            case "*":
                return left * right;
            case "/":
                return left / right;
            case "%":
                return left % right;
            case "==":
                return left == right;
            case "!=":
                return left != right
            }
        }

        function $_(operator, value) {
            var handler = unaryOperators[operator];
            if (handler && value && value[handler]) return value[handler]();
            switch (operator) {
            case "+":
                return +value;
            case "-":
                return -value
            }
        }

        function compile(code) {
            function getOffset(offset) {
                for (var i = 0, l = insertions.length; l > i; i++) {
                    var insertion = insertions[i];
                    if (insertion[0] >= offset) break;
                    offset += insertion[1]
                }
                return offset
            }

            function getCode(node) {
                return code.substring(getOffset(node.range[0]), getOffset(node.range[1]))
            }

            function replaceCode(node, str) {
                for (var start = getOffset(node.range[0]), end = getOffset(node.range[1]), insert = 0, i = insertions.length - 1; i >= 0; i--)
                    if (start > insertions[i][0]) {
                        insert = i + 1;
                        break
                    }
                insertions.splice(insert, 0, [start, str.length - end + start]), code = code.substring(0, start) + str + code.substring(end)
            }

            function walkAST(node, parent) {
                if (node) {
                    for (var key in node)
                        if ("range" !== key) {
                            var value = node[key];
                            if (Array.isArray(value))
                                for (var i = 0, l = value.length; l > i; i++) walkAST(value[i], node);
                            else value && "object" == typeof value && walkAST(value, node)
                        }
                    switch (node && node.type) {
                    case "UnaryExpression":
                        if (node.operator in unaryOperators && "Literal" !== node.argument.type) {
                            var arg = getCode(node.argument);
                            replaceCode(node, '$_("' + node.operator + '", ' + arg + ")")
                        }
                        break;
                    case "BinaryExpression":
                        if (node.operator in binaryOperators && "Literal" !== node.left.type) {
                            var left = getCode(node.left),
                                right = getCode(node.right);
                            replaceCode(node, "_$_(" + left + ', "' + node.operator + '", ' + right + ")")
                        }
                        break;
                    case "UpdateExpression":
                    case "AssignmentExpression":
                        if (!parent || !("ForStatement" === parent.type || "BinaryExpression" === parent.type && /^[=!<>]/.test(parent.operator) || "MemberExpression" === parent.type && parent.computed))
                            if ("UpdateExpression" === node.type) {
                                if (!node.prefix) {
                                    var arg = getCode(node.argument);
                                    replaceCode(node, arg + " = _$_(" + arg + ', "' + node.operator[0] + '", 1)')
                                }
                            } else if (/^.=$/.test(node.operator) && "Literal" !== node.left.type) {
                            var left = getCode(node.left),
                                right = getCode(node.right);
                            replaceCode(node, left + " = _$_(" + left + ', "' + node.operator[0] + '", ' + right + ")")
                        }
                    }
                }
            }
            var insertions = [];
            return walkAST(scope.acorn.parse(code, {
                ranges: !0
            })), code
        }

        function execute(code, scope) {
            function expose(scope, hidden) {
                for (var key in scope)!hidden && /^_/.test(key) || !new RegExp("\\b" + key.replace(/\$/g, "\\$") + "\\b").test(code) || (params.push(key), args.push(scope[key]))
            }
            paper = scope;
            var func, view = scope.getView(),
                tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) ? new Tool : null,
                toolHandlers = tool ? tool._events : [],
                handlers = ["onFrame", "onResize"].concat(toolHandlers),
                params = [],
                args = [];
            code = compile(code), expose({
                _$_: _$_,
                $_: $_,
                view: view,
                tool: tool
            }, !0), expose(scope), handlers = Base.each(handlers, function (key) {
                new RegExp("\\s+" + key + "\\b").test(code) && (params.push(key), this.push(key + ": " + key))
            }, []).join(", "), handlers && (code += "\nreturn { " + handlers + " };");
            var firefox = window.InstallTrigger;
            if (firefox || window.chrome) {
                var script = document.createElement("script"),
                    head = document.head;
                firefox && (code = "\n" + code), script.appendChild(document.createTextNode("paper._execute = function(" + params + ") {" + code + "\n}")), head.appendChild(script), func = paper._execute, delete paper._execute, head.removeChild(script)
            } else func = Function(params, code);
            var res = func.apply(scope, args) || {};
            Base.each(toolHandlers, function (key) {
                var value = res[key];
                value && (tool[key] = value)
            }), view && (res.onResize && view.setOnResize(res.onResize), view.fire("resize", {
                size: view.size,
                delta: new Point
            }), res.onFrame && view.setOnFrame(res.onFrame), view.update())
        }

        function load() {
            Base.each(document.getElementsByTagName("script"), function (script) {
                if (/^text\/(?:x-|)paperscript$/.test(script.type) && !script.getAttribute("data-paper-ignore")) {
                    var canvas = PaperScope.getAttribute(script, "canvas"),
                        scope = PaperScope.get(canvas) || new PaperScope(script).setup(canvas),
                        src = script.src;
                    src ? Http.request("get", src, function (code) {
                        execute(code, scope)
                    }) : execute(script.innerHTML, scope), script.setAttribute("data-paper-ignore", !0)
                }
            }, this)
        }
        var exports, define, scope = this;
        ! function (e, r) {
            return "object" == typeof exports && "object" == typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : void r(e.acorn || (e.acorn = {}))
        }(this, function (e) {
            "use strict";

            function r(e) {
                fr = e || {};
                for (var r in hr) Object.prototype.hasOwnProperty.call(fr, r) || (fr[r] = hr[r]);
                mr = fr.sourceFile || null
            }

            function t(e, r) {
                var t = vr(pr, e);
                r += " (" + t.line + ":" + t.column + ")";
                var n = new SyntaxError(r);
                throw n.pos = e, n.loc = t, n.raisedAt = br, n
            }

            function n(e) {
                function r(e) {
                    if (1 == e.length) return t += "return str === " + JSON.stringify(e[0]) + ";";
                    t += "switch(str){";
                    for (var r = 0; r < e.length; ++r) t += "case " + JSON.stringify(e[r]) + ":";
                    t += "return true}return false;"
                }
                e = e.split(" ");
                var t = "",
                    n = [];
                e: for (var a = 0; a < e.length; ++a) {
                    for (var o = 0; o < n.length; ++o)
                        if (n[o][0].length == e[a].length) {
                            n[o].push(e[a]);
                            continue e
                        }
                    n.push([e[a]])
                }
                if (n.length > 3) {
                    n.sort(function (e, r) {
                        return r.length - e.length
                    }), t += "switch(str.length){";
                    for (var a = 0; a < n.length; ++a) {
                        var i = n[a];
                        t += "case " + i[0].length + ":", r(i)
                    }
                    t += "}"
                } else r(e);
                return new Function("str", t)
            }

            function a() {
                this.line = Ar, this.column = br - Sr
            }

            function o() {
                Ar = 1, br = Sr = 0, Er = !0, u()
            }

            function i(e, r) {
                gr = br, fr.locations && (kr = new a), wr = e, u(), Cr = r, Er = e.beforeExpr
            }

            function s() {
                var e = fr.onComment && fr.locations && new a,
                    r = br,
                    n = pr.indexOf("*/", br += 2);
                if (-1 === n && t(br - 2, "Unterminated comment"), br = n + 2, fr.locations) {
                    Kt.lastIndex = r;
                    for (var o;
                        (o = Kt.exec(pr)) && o.index < br;)++Ar, Sr = o.index + o[0].length
                }
                fr.onComment && fr.onComment(!0, pr.slice(r + 2, n), r, br, e, fr.locations && new a)
            }

            function c() {
                for (var e = br, r = fr.onComment && fr.locations && new a, t = pr.charCodeAt(br += 2); dr > br && 10 !== t && 13 !== t && 8232 !== t && 8329 !== t;)++br, t = pr.charCodeAt(br);
                fr.onComment && fr.onComment(!1, pr.slice(e + 2, br), e, br, r, fr.locations && new a)
            }

            function u() {
                for (; dr > br;) {
                    var e = pr.charCodeAt(br);
                    if (32 === e)++br;
                    else if (13 === e) {
                        ++br;
                        var r = pr.charCodeAt(br);
                        10 === r && ++br, fr.locations && (++Ar, Sr = br)
                    } else if (10 === e)++br, ++Ar, Sr = br;
                    else if (14 > e && e > 8)++br;
                    else if (47 === e) {
                        var r = pr.charCodeAt(br + 1);
                        if (42 === r) s();
                        else {
                            if (47 !== r) break;
                            c()
                        }
                    } else if (160 === e)++br;
                    else {
                        if (!(e >= 5760 && Jt.test(String.fromCharCode(e)))) break;
                        ++br
                    }
                }
            }

            function l() {
                var e = pr.charCodeAt(br + 1);
                return e >= 48 && 57 >= e ? E(!0) : (++br, i(xt))
            }

            function f() {
                var e = pr.charCodeAt(br + 1);
                return Er ? (++br, k()) : 61 === e ? x(Et, 2) : x(wt, 1)
            }

            function p() {
                var e = pr.charCodeAt(br + 1);
                return 61 === e ? x(Et, 2) : x(Ft, 1)
            }

            function d(e) {
                var r = pr.charCodeAt(br + 1);
                return r === e ? x(124 === e ? Lt : Ut, 2) : 61 === r ? x(Et, 2) : x(124 === e ? Rt : Vt, 1)
            }

            function m() {
                var e = pr.charCodeAt(br + 1);
                return 61 === e ? x(Et, 2) : x(Tt, 1)
            }

            function h(e) {
                var r = pr.charCodeAt(br + 1);
                return r === e ? x(St, 2) : 61 === r ? x(Et, 2) : x(At, 1)
            }

            function v(e) {
                var r = pr.charCodeAt(br + 1),
                    t = 1;
                return r === e ? (t = 62 === e && 62 === pr.charCodeAt(br + 2) ? 3 : 2, 61 === pr.charCodeAt(br + t) ? x(Et, t + 1) : x(jt, t)) : (61 === r && (t = 61 === pr.charCodeAt(br + 2) ? 3 : 2), x(Ot, t))
            }

            function b(e) {
                var r = pr.charCodeAt(br + 1);
                return 61 === r ? x(qt, 61 === pr.charCodeAt(br + 2) ? 3 : 2) : x(61 === e ? Ct : It, 1)
            }

            function y(e) {
                switch (e) {
                case 46:
                    return l();
                case 40:
                    return ++br, i(ht);
                case 41:
                    return ++br, i(vt);
                case 59:
                    return ++br, i(yt);
                case 44:
                    return ++br, i(bt);
                case 91:
                    return ++br, i(ft);
                case 93:
                    return ++br, i(pt);
                case 123:
                    return ++br, i(dt);
                case 125:
                    return ++br, i(mt);
                case 58:
                    return ++br, i(gt);
                case 63:
                    return ++br, i(kt);
                case 48:
                    var r = pr.charCodeAt(br + 1);
                    if (120 === r || 88 === r) return C();
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    return E(!1);
                case 34:
                case 39:
                    return A(e);
                case 47:
                    return f(e);
                case 37:
                case 42:
                    return p();
                case 124:
                case 38:
                    return d(e);
                case 94:
                    return m();
                case 43:
                case 45:
                    return h(e);
                case 60:
                case 62:
                    return v(e);
                case 61:
                case 33:
                    return b(e);
                case 126:
                    return x(It, 1)
                }
                return !1
            }

            function g(e) {
                if (e ? br = yr + 1 : yr = br, fr.locations && (xr = new a), e) return k();
                if (br >= dr) return i(Br);
                var r = pr.charCodeAt(br);
                if (Qt(r) || 92 === r) return L();
                var n = y(r);
                if (n === !1) {
                    var o = String.fromCharCode(r);
                    if ("\\" === o || $t.test(o)) return L();
                    t(br, "Unexpected character '" + o + "'")
                }
                return n
            }

            function x(e, r) {
                var t = pr.slice(br, br + r);
                br += r, i(e, t)
            }

            function k() {
                for (var e, r, n = "", a = br;;) {
                    br >= dr && t(a, "Unterminated regular expression");
                    var o = pr.charAt(br);
                    if (Gt.test(o) && t(a, "Unterminated regular expression"), e) e = !1;
                    else {
                        if ("[" === o) r = !0;
                        else if ("]" === o && r) r = !1;
                        else if ("/" === o && !r) break;
                        e = "\\" === o
                    }++br
                }
                var n = pr.slice(a, br);
                ++br;
                var s = I();
                return s && !/^[gmsiy]*$/.test(s) && t(a, "Invalid regexp flag"), i(jr, new RegExp(n, s))
            }

            function w(e, r) {
                for (var t = br, n = 0, a = 0, o = null == r ? 1 / 0 : r; o > a; ++a) {
                    var i, s = pr.charCodeAt(br);
                    if (i = s >= 97 ? s - 97 + 10 : s >= 65 ? s - 65 + 10 : s >= 48 && 57 >= s ? s - 48 : 1 / 0, i >= e) break;
                    ++br, n = n * e + i
                }
                return br === t || null != r && br - t !== r ? null : n
            }

            function C() {
                br += 2;
                var e = w(16);
                return null == e && t(yr + 2, "Expected hexadecimal number"), Qt(pr.charCodeAt(br)) && t(br, "Identifier directly after number"), i(Or, e)
            }

            function E(e) {
                var r = br,
                    n = !1,
                    a = 48 === pr.charCodeAt(br);
                e || null !== w(10) || t(r, "Invalid number"), 46 === pr.charCodeAt(br) && (++br, w(10), n = !0);
                var o = pr.charCodeAt(br);
                (69 === o || 101 === o) && (o = pr.charCodeAt(++br), (43 === o || 45 === o) && ++br, null === w(10) && t(r, "Invalid number"), n = !0), Qt(pr.charCodeAt(br)) && t(br, "Identifier directly after number");
                var s, c = pr.slice(r, br);
                return n ? s = parseFloat(c) : a && 1 !== c.length ? /[89]/.test(c) || Vr ? t(r, "Invalid number") : s = parseInt(c, 8) : s = parseInt(c, 10), i(Or, s)
            }

            function A(e) {
                br++;
                for (var r = "";;) {
                    br >= dr && t(yr, "Unterminated string constant");
                    var n = pr.charCodeAt(br);
                    if (n === e) return ++br, i(Fr, r);
                    if (92 === n) {
                        n = pr.charCodeAt(++br);
                        var a = /^[0-7]+/.exec(pr.slice(br, br + 3));
                        for (a && (a = a[0]); a && parseInt(a, 8) > 255;) a = a.slice(0, a.length - 1);
                        if ("0" === a && (a = null), ++br, a) Vr && t(br - 2, "Octal literal in strict mode"), r += String.fromCharCode(parseInt(a, 8)), br += a.length - 1;
                        else switch (n) {
                        case 110:
                            r += "\n";
                            break;
                        case 114:
                            r += "\r";
                            break;
                        case 120:
                            r += String.fromCharCode(S(2));
                            break;
                        case 117:
                            r += String.fromCharCode(S(4));
                            break;
                        case 85:
                            r += String.fromCharCode(S(8));
                            break;
                        case 116:
                            r += "  ";
                            break;
                        case 98:
                            r += "\b";
                            break;
                        case 118:
                            r += "";
                            break;
                        case 102:
                            r += "\f";
                            break;
                        case 48:
                            r += "\x00";
                            break;
                        case 13:
                            10 === pr.charCodeAt(br) && ++br;
                        case 10:
                            fr.locations && (Sr = br, ++Ar);
                            break;
                        default:
                            r += String.fromCharCode(n)
                        }
                    } else(13 === n || 10 === n || 8232 === n || 8329 === n) && t(yr, "Unterminated string constant"), r += String.fromCharCode(n), ++br
                }
            }

            function S(e) {
                var r = w(16, e);
                return null === r && t(yr, "Bad character escape sequence"), r
            }

            function I() {
                Bt = !1;
                for (var e, r = !0, n = br;;) {
                    var a = pr.charCodeAt(br);
                    if (Yt(a)) Bt && (e += pr.charAt(br)), ++br;
                    else {
                        if (92 !== a) break;
                        Bt || (e = pr.slice(n, br)), Bt = !0, 117 != pr.charCodeAt(++br) && t(br, "Expecting Unicode escape sequence \\uXXXX"), ++br;
                        var o = S(4),
                            i = String.fromCharCode(o);
                        i || t(br - 1, "Invalid Unicode escape"), (r ? Qt(o) : Yt(o)) || t(br - 4, "Invalid Unicode escape"), e += i
                    }
                    r = !1
                }
                return Bt ? e : pr.slice(n, br)
            }

            function L() {
                var e = I(),
                    r = Dr;
                return Bt || (Wt(e) ? r = lt[e] : (fr.forbidReserved && (3 === fr.ecmaVersion ? Mt : zt)(e) || Vr && Xt(e)) && t(yr, "The keyword '" + e + "' is reserved")), i(r, e)
            }

            function U() {
                Ir = yr, Lr = gr, Ur = kr, g()
            }

            function R(e) {
                for (Vr = e, br = Lr; Sr > br;) Sr = pr.lastIndexOf("\n", Sr - 2) + 1, --Ar;
                u(), g()
            }

            function T() {
                this.type = null, this.start = yr, this.end = null
            }

            function V() {
                this.start = xr, this.end = null, null !== mr && (this.source = mr)
            }

            function q() {
                var e = new T;
                return fr.locations && (e.loc = new V), fr.ranges && (e.range = [yr, 0]), e
            }

            function O(e) {
                var r = new T;
                return r.start = e.start, fr.locations && (r.loc = new V, r.loc.start = e.loc.start), fr.ranges && (r.range = [e.range[0], 0]), r
            }

            function j(e, r) {
                return e.type = r, e.end = Lr, fr.locations && (e.loc.end = Ur), fr.ranges && (e.range[1] = Lr), e
            }

            function F(e) {
                return fr.ecmaVersion >= 5 && "ExpressionStatement" === e.type && "Literal" === e.expression.type && "use strict" === e.expression.value
            }

            function D(e) {
                return wr === e ? (U(), !0) : void 0
            }

            function B() {
                return !fr.strictSemicolons && (wr === Br || wr === mt || Gt.test(pr.slice(Lr, yr)))
            }

            function M() {
                D(yt) || B() || X()
            }

            function z(e) {
                wr === e ? U() : X()
            }

            function X() {
                t(yr, "Unexpected token")
            }

            function N(e) {
                "Identifier" !== e.type && "MemberExpression" !== e.type && t(e.start, "Assigning to rvalue"), Vr && "Identifier" === e.type && Nt(e.name) && t(e.start, "Assigning to " + e.name + " in strict mode")
            }

            function W(e) {
                Ir = Lr = br, fr.locations && (Ur = new a), Rr = Vr = null, Tr = [], g();
                var r = e || q(),
                    t = !0;
                for (e || (r.body = []); wr !== Br;) {
                    var n = J();
                    r.body.push(n), t && F(n) && R(!0), t = !1
                }
                return j(r, "Program")
            }

            function J() {
                wr === wt && g(!0);
                var e = wr,
                    r = q();
                switch (e) {
                case Mr:
                case Nr:
                    U();
                    var n = e === Mr;
                    D(yt) || B() ? r.label = null : wr !== Dr ? X() : (r.label = lr(), M());
                    for (var a = 0; a < Tr.length; ++a) {
                        var o = Tr[a];
                        if (null == r.label || o.name === r.label.name) {
                            if (null != o.kind && (n || "loop" === o.kind)) break;
                            if (r.label && n) break
                        }
                    }
                    return a === Tr.length && t(r.start, "Unsyntactic " + e.keyword), j(r, n ? "BreakStatement" : "ContinueStatement");
                case Wr:
                    return U(), M(), j(r, "DebuggerStatement");
                case Pr:
                    return U(), Tr.push(Zt), r.body = J(), Tr.pop(), z(tt), r.test = P(), M(), j(r, "DoWhileStatement");
                case _r:
                    if (U(), Tr.push(Zt), z(ht), wr === yt) return $(r, null);
                    if (wr === rt) {
                        var i = q();
                        return U(), G(i, !0), 1 === i.declarations.length && D(ut) ? _(r, i) : $(r, i)
                    }
                    var i = K(!1, !0);
                    return D(ut) ? (N(i), _(r, i)) : $(r, i);
                case Gr:
                    return U(), cr(r, !0);
                case Kr:
                    return U(), r.test = P(), r.consequent = J(), r.alternate = D(Hr) ? J() : null, j(r, "IfStatement");
                case Qr:
                    return Rr || t(yr, "'return' outside of function"), U(), D(yt) || B() ? r.argument = null : (r.argument = K(), M()), j(r, "ReturnStatement");
                case Yr:
                    U(), r.discriminant = P(), r.cases = [], z(dt), Tr.push(en);
                    for (var s, c; wr != mt;)
                        if (wr === zr || wr === Jr) {
                            var u = wr === zr;
                            s && j(s, "SwitchCase"), r.cases.push(s = q()), s.consequent = [], U(), u ? s.test = K() : (c && t(Ir, "Multiple default clauses"), c = !0, s.test = null), z(gt)
                        } else s || X(), s.consequent.push(J());
                    return s && j(s, "SwitchCase"), U(), Tr.pop(), j(r, "SwitchStatement");
                case Zr:
                    return U(), Gt.test(pr.slice(Lr, yr)) && t(Lr, "Illegal newline after throw"), r.argument = K(), M(), j(r, "ThrowStatement");
                case et:
                    if (U(), r.block = H(), r.handler = null, wr === Xr) {
                        var l = q();
                        U(), z(ht), l.param = lr(), Vr && Nt(l.param.name) && t(l.param.start, "Binding " + l.param.name + " in strict mode"), z(vt), l.guard = null, l.body = H(), r.handler = j(l, "CatchClause")
                    }
                    return r.guardedHandlers = qr, r.finalizer = D($r) ? H() : null, r.handler || r.finalizer || t(r.start, "Missing catch or finally clause"), j(r, "TryStatement");
                case rt:
                    return U(), r = G(r), M(), r;
                case tt:
                    return U(), r.test = P(), Tr.push(Zt), r.body = J(), Tr.pop(), j(r, "WhileStatement");
                case nt:
                    return Vr && t(yr, "'with' in strict mode"), U(), r.object = P(), r.body = J(), j(r, "WithStatement");
                case dt:
                    return H();
                case yt:
                    return U(), j(r, "EmptyStatement");
                default:
                    var f = Cr,
                        p = K();
                    if (e === Dr && "Identifier" === p.type && D(gt)) {
                        for (var a = 0; a < Tr.length; ++a) Tr[a].name === f && t(p.start, "Label '" + f + "' is already declared");
                        var d = wr.isLoop ? "loop" : wr === Yr ? "switch" : null;
                        return Tr.push({
                            name: f,
                            kind: d
                        }), r.body = J(), Tr.pop(), r.label = p, j(r, "LabeledStatement")
                    }
                    return r.expression = p, M(), j(r, "ExpressionStatement")
                }
            }

            function P() {
                z(ht);
                var e = K();
                return z(vt), e
            }

            function H(e) {
                var r, t = q(),
                    n = !0,
                    a = !1;
                for (t.body = [], z(dt); !D(mt);) {
                    var o = J();
                    t.body.push(o), n && e && F(o) && (r = a, R(a = !0)), n = !1
                }
                return a && !r && R(!1), j(t, "BlockStatement")
            }

            function $(e, r) {
                return e.init = r, z(yt), e.test = wr === yt ? null : K(), z(yt), e.update = wr === vt ? null : K(), z(vt), e.body = J(), Tr.pop(), j(e, "ForStatement")
            }

            function _(e, r) {
                return e.left = r, e.right = K(), z(vt), e.body = J(), Tr.pop(), j(e, "ForInStatement")
            }

            function G(e, r) {
                for (e.declarations = [], e.kind = "var";;) {
                    var n = q();
                    if (n.id = lr(), Vr && Nt(n.id.name) && t(n.id.start, "Binding " + n.id.name + " in strict mode"), n.init = D(Ct) ? K(!0, r) : null, e.declarations.push(j(n, "VariableDeclarator")), !D(bt)) break
                }
                return j(e, "VariableDeclaration")
            }

            function K(e, r) {
                var t = Q(r);
                if (!e && wr === bt) {
                    var n = O(t);
                    for (n.expressions = [t]; D(bt);) n.expressions.push(Q(r));
                    return j(n, "SequenceExpression")
                }
                return t
            }

            function Q(e) {
                var r = Y(e);
                if (wr.isAssign) {
                    var t = O(r);
                    return t.operator = Cr, t.left = r, U(), t.right = Q(e), N(r), j(t, "AssignmentExpression")
                }
                return r
            }

            function Y(e) {
                var r = Z(e);
                if (D(kt)) {
                    var t = O(r);
                    return t.test = r, t.consequent = K(!0), z(gt), t.alternate = K(!0, e), j(t, "ConditionalExpression")
                }
                return r
            }

            function Z(e) {
                return er(rr(), -1, e)
            }

            function er(e, r, t) {
                var n = wr.binop;
                if (null != n && (!t || wr !== ut) && n > r) {
                    var a = O(e);
                    a.left = e, a.operator = Cr, U(), a.right = er(rr(), n, t);
                    var a = j(a, /&&|\|\|/.test(a.operator) ? "LogicalExpression" : "BinaryExpression");
                    return er(a, r, t)
                }
                return e
            }

            function rr() {
                if (wr.prefix) {
                    var e = q(),
                        r = wr.isUpdate;
                    return e.operator = Cr, e.prefix = !0, U(), e.argument = rr(), r ? N(e.argument) : Vr && "delete" === e.operator && "Identifier" === e.argument.type && t(e.start, "Deleting local variable in strict mode"), j(e, r ? "UpdateExpression" : "UnaryExpression")
                }
                for (var n = tr(); wr.postfix && !B();) {
                    var e = O(n);
                    e.operator = Cr, e.prefix = !1, e.argument = n, N(n), U(), n = j(e, "UpdateExpression")
                }
                return n
            }

            function tr() {
                return nr(ar())
            }

            function nr(e, r) {
                if (D(xt)) {
                    var t = O(e);
                    return t.object = e, t.property = lr(!0), t.computed = !1, nr(j(t, "MemberExpression"), r)
                }
                if (D(ft)) {
                    var t = O(e);
                    return t.object = e, t.property = K(), t.computed = !0, z(pt), nr(j(t, "MemberExpression"), r)
                }
                if (!r && D(ht)) {
                    var t = O(e);
                    return t.callee = e, t.arguments = ur(vt, !1), nr(j(t, "CallExpression"), r)
                }
                return e
            }

            function ar() {
                switch (wr) {
                case ot:
                    var e = q();
                    return U(), j(e, "ThisExpression");
                case Dr:
                    return lr();
                case Or:
                case Fr:
                case jr:
                    var e = q();
                    return e.value = Cr, e.raw = pr.slice(yr, gr), U(), j(e, "Literal");
                case it:
                case st:
                case ct:
                    var e = q();
                    return e.value = wr.atomValue, e.raw = wr.keyword, U(), j(e, "Literal");
                case ht:
                    var r = xr,
                        t = yr;
                    U();
                    var n = K();
                    return n.start = t, n.end = gr, fr.locations && (n.loc.start = r, n.loc.end = kr), fr.ranges && (n.range = [t, gr]), z(vt), n;
                case ft:
                    var e = q();
                    return U(), e.elements = ur(pt, !0, !0), j(e, "ArrayExpression");
                case dt:
                    return ir();
                case Gr:
                    var e = q();
                    return U(), cr(e, !1);
                case at:
                    return or();
                default:
                    X()
                }
            }

            function or() {
                var e = q();
                return U(), e.callee = nr(ar(), !0), e.arguments = D(ht) ? ur(vt, !1) : qr, j(e, "NewExpression")
            }

            function ir() {
                var e = q(),
                    r = !0,
                    n = !1;
                for (e.properties = [], U(); !D(mt);) {
                    if (r) r = !1;
                    else if (z(bt), fr.allowTrailingCommas && D(mt)) break;
                    var a, o = {
                            key: sr()
                        },
                        i = !1;
                    if (D(gt) ? (o.value = K(!0), a = o.kind = "init") : fr.ecmaVersion >= 5 && "Identifier" === o.key.type && ("get" === o.key.name || "set" === o.key.name) ? (i = n = !0, a = o.kind = o.key.name, o.key = sr(), wr !== ht && X(), o.value = cr(q(), !1)) : X(), "Identifier" === o.key.type && (Vr || n))
                        for (var s = 0; s < e.properties.length; ++s) {
                            var c = e.properties[s];
                            if (c.key.name === o.key.name) {
                                var u = a == c.kind || i && "init" === c.kind || "init" === a && ("get" === c.kind || "set" === c.kind);
                                u && !Vr && "init" === a && "init" === c.kind && (u = !1), u && t(o.key.start, "Redefinition of property")
                            }
                        }
                    e.properties.push(o)
                }
                return j(e, "ObjectExpression")
            }

            function sr() {
                return wr === Or || wr === Fr ? ar() : lr(!0)
            }

            function cr(e, r) {
                wr === Dr ? e.id = lr() : r ? X() : e.id = null, e.params = [];
                var n = !0;
                for (z(ht); !D(vt);) n ? n = !1 : z(bt), e.params.push(lr());
                var a = Rr,
                    o = Tr;
                if (Rr = !0, Tr = [], e.body = H(!0), Rr = a, Tr = o, Vr || e.body.body.length && F(e.body.body[0]))
                    for (var i = e.id ? -1 : 0; i < e.params.length; ++i) {
                        var s = 0 > i ? e.id : e.params[i];
                        if ((Xt(s.name) || Nt(s.name)) && t(s.start, "Defining '" + s.name + "' in strict mode"), i >= 0)
                            for (var c = 0; i > c; ++c) s.name === e.params[c].name && t(s.start, "Argument name clash in strict mode")
                    }
                return j(e, r ? "FunctionDeclaration" : "FunctionExpression")
            }

            function ur(e, r, t) {
                for (var n = [], a = !0; !D(e);) {
                    if (a) a = !1;
                    else if (z(bt), r && fr.allowTrailingCommas && D(e)) break;
                    n.push(t && wr === bt ? null : K(!0))
                }
                return n
            }

            function lr(e) {
                var r = q();
                return r.name = wr === Dr ? Cr : e && !fr.forbidReserved && wr.keyword || X(), U(), j(r, "Identifier")
            }
            e.version = "0.3.2";
            var fr, pr, dr, mr;
            e.parse = function (e, t) {
                return pr = String(e), dr = pr.length, r(t), o(), W(fr.program)
            };
            var hr = e.defaultOptions = {
                    ecmaVersion: 5,
                    strictSemicolons: !1,
                    allowTrailingCommas: !0,
                    forbidReserved: !1,
                    locations: !1,
                    onComment: null,
                    ranges: !1,
                    program: null,
                    sourceFile: null
                },
                vr = e.getLineInfo = function (e, r) {
                    for (var t = 1, n = 0;;) {
                        Kt.lastIndex = n;
                        var a = Kt.exec(e);
                        if (!(a && a.index < r)) break;
                        ++t, n = a.index + a[0].length
                    }
                    return {
                        line: t,
                        column: r - n
                    }
                };
            e.tokenize = function (e, t) {
                function n(e) {
                    return g(e), a.start = yr, a.end = gr, a.startLoc = xr, a.endLoc = kr, a.type = wr, a.value = Cr, a
                }
                pr = String(e), dr = pr.length, r(t), o();
                var a = {};
                return n.jumpTo = function (e, r) {
                    if (br = e, fr.locations) {
                        Ar = 1, Sr = Kt.lastIndex = 0;
                        for (var t;
                            (t = Kt.exec(pr)) && t.index < e;)++Ar, Sr = t.index + t[0].length
                    }
                    Er = r, u()
                }, n
            };
            var br, yr, gr, xr, kr, wr, Cr, Er, Ar, Sr, Ir, Lr, Ur, Rr, Tr, Vr, qr = [],
                Or = {
                    type: "num"
                },
                jr = {
                    type: "regexp"
                },
                Fr = {
                    type: "string"
                },
                Dr = {
                    type: "name"
                },
                Br = {
                    type: "eof"
                },
                Mr = {
                    keyword: "break"
                },
                zr = {
                    keyword: "case",
                    beforeExpr: !0
                },
                Xr = {
                    keyword: "catch"
                },
                Nr = {
                    keyword: "continue"
                },
                Wr = {
                    keyword: "debugger"
                },
                Jr = {
                    keyword: "default"
                },
                Pr = {
                    keyword: "do",
                    isLoop: !0
                },
                Hr = {
                    keyword: "else",
                    beforeExpr: !0
                },
                $r = {
                    keyword: "finally"
                },
                _r = {
                    keyword: "for",
                    isLoop: !0
                },
                Gr = {
                    keyword: "function"
                },
                Kr = {
                    keyword: "if"
                },
                Qr = {
                    keyword: "return",
                    beforeExpr: !0
                },
                Yr = {
                    keyword: "switch"
                },
                Zr = {
                    keyword: "throw",
                    beforeExpr: !0
                },
                et = {
                    keyword: "try"
                },
                rt = {
                    keyword: "var"
                },
                tt = {
                    keyword: "while",
                    isLoop: !0
                },
                nt = {
                    keyword: "with"
                },
                at = {
                    keyword: "new",
                    beforeExpr: !0
                },
                ot = {
                    keyword: "this"
                },
                it = {
                    keyword: "null",
                    atomValue: null
                },
                st = {
                    keyword: "true",
                    atomValue: !0
                },
                ct = {
                    keyword: "false",
                    atomValue: !1
                },
                ut = {
                    keyword: "in",
                    binop: 7,
                    beforeExpr: !0
                },
                lt = {
                    "break": Mr,
                    "case": zr,
                    "catch": Xr,
                    "continue": Nr,
                    "debugger": Wr,
                    "default": Jr,
                    "do": Pr,
                    "else": Hr,
                    "finally": $r,
                    "for": _r,
                    "function": Gr,
                    "if": Kr,
                    "return": Qr,
                    "switch": Yr,
                    "throw": Zr,
                    "try": et,
                    "var": rt,
                    "while": tt,
                    "with": nt,
                    "null": it,
                    "true": st,
                    "false": ct,
                    "new": at,
                    "in": ut,
                    "instanceof": {
                        keyword: "instanceof",
                        binop: 7,
                        beforeExpr: !0
                    },
                    "this": ot,
                    "typeof": {
                        keyword: "typeof",
                        prefix: !0,
                        beforeExpr: !0
                    },
                    "void": {
                        keyword: "void",
                        prefix: !0,
                        beforeExpr: !0
                    },
                    "delete": {
                        keyword: "delete",
                        prefix: !0,
                        beforeExpr: !0
                    }
                },
                ft = {
                    type: "[",
                    beforeExpr: !0
                },
                pt = {
                    type: "]"
                },
                dt = {
                    type: "{",
                    beforeExpr: !0
                },
                mt = {
                    type: "}"
                },
                ht = {
                    type: "(",
                    beforeExpr: !0
                },
                vt = {
                    type: ")"
                },
                bt = {
                    type: ",",
                    beforeExpr: !0
                },
                yt = {
                    type: ";",
                    beforeExpr: !0
                },
                gt = {
                    type: ":",
                    beforeExpr: !0
                },
                xt = {
                    type: "."
                },
                kt = {
                    type: "?",
                    beforeExpr: !0
                },
                wt = {
                    binop: 10,
                    beforeExpr: !0
                },
                Ct = {
                    isAssign: !0,
                    beforeExpr: !0
                },
                Et = {
                    isAssign: !0,
                    beforeExpr: !0
                },
                At = {
                    binop: 9,
                    prefix: !0,
                    beforeExpr: !0
                },
                St = {
                    postfix: !0,
                    prefix: !0,
                    isUpdate: !0
                },
                It = {
                    prefix: !0,
                    beforeExpr: !0
                },
                Lt = {
                    binop: 1,
                    beforeExpr: !0
                },
                Ut = {
                    binop: 2,
                    beforeExpr: !0
                },
                Rt = {
                    binop: 3,
                    beforeExpr: !0
                },
                Tt = {
                    binop: 4,
                    beforeExpr: !0
                },
                Vt = {
                    binop: 5,
                    beforeExpr: !0
                },
                qt = {
                    binop: 6,
                    beforeExpr: !0
                },
                Ot = {
                    binop: 7,
                    beforeExpr: !0
                },
                jt = {
                    binop: 8,
                    beforeExpr: !0
                },
                Ft = {
                    binop: 10,
                    beforeExpr: !0
                };
            e.tokTypes = {
                bracketL: ft,
                bracketR: pt,
                braceL: dt,
                braceR: mt,
                parenL: ht,
                parenR: vt,
                comma: bt,
                semi: yt,
                colon: gt,
                dot: xt,
                question: kt,
                slash: wt,
                eq: Ct,
                name: Dr,
                eof: Br,
                num: Or,
                regexp: jr,
                string: Fr
            };
            for (var Dt in lt) e.tokTypes["_" + Dt] = lt[Dt];
            var Bt, Mt = n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
                zt = n("class enum extends super const export import"),
                Xt = n("implements interface let package private protected public static yield"),
                Nt = n("eval arguments"),
                Wt = n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),
                Jt = /[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/,
                Pt = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",
                Ht = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",
                $t = new RegExp("[" + Pt + "]"),
                _t = new RegExp("[" + Pt + Ht + "]"),
                Gt = /[\n\r\u2028\u2029]/,
                Kt = /\r\n|[\n\r\u2028\u2029]/g,
                Qt = e.isIdentifierStart = function (e) {
                    return 65 > e ? 36 === e : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && $t.test(String.fromCharCode(e))
                },
                Yt = e.isIdentifierChar = function (e) {
                    return 48 > e ? 36 === e : 58 > e ? !0 : 65 > e ? !1 : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && _t.test(String.fromCharCode(e))
                },
                Zt = {
                    kind: "loop"
                },
                en = {
                    kind: "switch"
                }
        });
        var binaryOperators = {
                "+": "__add",
                "-": "__subtract",
                "*": "__multiply",
                "/": "__divide",
                "%": "__modulo",
                "==": "equals",
                "!=": "equals"
            },
            unaryOperators = {
                "-": "__negate",
                "+": null
            },
            fields = Base.each(["add", "subtract", "multiply", "divide", "modulo", "negate"], function (name) {
                this["__" + name] = "#" + name
            }, {});
        return Point.inject(fields), Size.inject(fields), Color.inject(fields), "complete" === document.readyState ? setTimeout(load) : DomEvent.add(window, {
            load: load
        }), {
            compile: compile,
            execute: execute,
            load: load,
            lineNumberBase: 0
        }
    }.call(this), paper = new(PaperScope.inject(Base.exports, {
        enumerable: !0,
        Base: Base,
        Numerical: Numerical,
        DomElement: DomElement,
        DomEvent: DomEvent,
        Http: Http,
        Key: Key
    })), "function" == typeof define && define.amd && define("paper", paper), paper
};
/*!
 * VERSION: 1.11.6
 * DATE: 2014-03-26
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
(window._gsQueue || (window._gsQueue = [])).push(function () {
        "use strict";
        window._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
                var s = [].slice,
                    r = function (t, e, s) {
                        i.call(this, t, e, s), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = r.prototype.render
                    },
                    n = 1e-10,
                    a = i._internals.isSelector,
                    o = i._internals.isArray,
                    h = r.prototype = i.to({}, .1, {}),
                    l = [];
                r.version = "1.11.6", h.constructor = r, h.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = i.killTweensOf, r.getTweensOf = i.getTweensOf, r.ticker = i.ticker, h.invalidate = function () {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this)
                }, h.updateTo = function (t, e) {
                    var s, r = this.ratio;
                    e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                    for (s in t) this.vars[s] = t[s];
                    if (this._initted)
                        if (e) this._initted = !1;
                        else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                        var n = this._time;
                        this.render(0, !0, !1), this._initted = !1, this.render(n, !0, !1)
                    } else if (this._time > 0) {
                        this._initted = !1, this._init();
                        for (var a, o = 1 / (1 - r), h = this._firstPT; h;) a = h.s + h.c, h.c *= o, h.s = a - h.c, h = h._next
                    }
                    return this
                }, h.render = function (t, e, i) {
                    this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                    var s, r, a, o, h, _, u, p, c = this._dirty ? this.totalDuration() : this._totalDuration,
                        f = this._time,
                        m = this._totalTime,
                        d = this._cycle,
                        g = this._duration;
                    if (t >= c ? (this._totalTime = c, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (s = !0, r = "onComplete"), 0 === g && (p = this._rawPrevTime, this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > p || p === n) && p !== t && (i = !0, p > n && (r = "onReverseComplete")), this._rawPrevTime = p = !e || t || this._rawPrevTime === t ? t : n)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === g && this._rawPrevTime > 0 && this._rawPrevTime !== n) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === g && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = p = !e || t || this._rawPrevTime === t ? t : n)) : this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (o = g + this._repeatDelay, this._cycle = this._totalTime / o >> 0, 0 !== this._cycle && this._cycle === this._totalTime / o && this._cycle--, this._time = this._totalTime - this._cycle * o, this._yoyo && 0 !== (1 & this._cycle) && (this._time = g - this._time), this._time > g ? this._time = g : 0 > this._time && (this._time = 0)), this._easeType ? (h = this._time / g, _ = this._easeType, u = this._easePower, (1 === _ || 3 === _ && h >= .5) && (h = 1 - h), 3 === _ && (h *= 2), 1 === u ? h *= h : 2 === u ? h *= h * h : 3 === u ? h *= h * h * h : 4 === u && (h *= h * h * h * h), this.ratio = 1 === _ ? 1 - h : 2 === _ ? h : .5 > this._time / g ? h / 2 : 1 - h / 2) : this.ratio = this._ease.getRatio(this._time / g)), f === this._time && !i && d === this._cycle) return void(m !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)));
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        this._time && !s ? this.ratio = this._ease.getRatio(this._time / g) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._active || !this._paused && this._time !== f && t >= 0 && (this._active = !0), 0 === m && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === g) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || l))), a = this._firstPT; a;) a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next;
                    this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._totalTime !== m || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || l)), this._cycle !== d && (e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || l)), r && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || l), 0 === g && this._rawPrevTime === n && p !== n && (this._rawPrevTime = 0)))
                }, r.to = function (t, e, i) {
                    return new r(t, e, i)
                }, r.from = function (t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new r(t, e, i)
                }, r.fromTo = function (t, e, i, s) {
                    return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new r(t, e, s)
                }, r.staggerTo = r.allTo = function (t, e, n, h, _, u, p) {
                    h = h || 0;
                    var c, f, m, d, g = n.delay || 0,
                        v = [],
                        y = function () {
                            n.onComplete && n.onComplete.apply(n.onCompleteScope || this, arguments), _.apply(p || this, u || l)
                        };
                    for (o(t) || ("string" == typeof t && (t = i.selector(t) || t), a(t) && (t = s.call(t, 0))), c = t.length, m = 0; c > m; m++) {
                        f = {};
                        for (d in n) f[d] = n[d];
                        f.delay = g, m === c - 1 && _ && (f.onComplete = y), v[m] = new r(t[m], e, f), g += h
                    }
                    return v
                }, r.staggerFrom = r.allFrom = function (t, e, i, s, n, a, o) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, r.staggerTo(t, e, i, s, n, a, o)
                }, r.staggerFromTo = r.allFromTo = function (t, e, i, s, n, a, o, h) {
                    return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, r.staggerTo(t, e, s, n, a, o, h)
                }, r.delayedCall = function (t, e, i, s, n) {
                    return new r(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        onCompleteScope: s,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        onReverseCompleteScope: s,
                        immediateRender: !1,
                        useFrames: n,
                        overwrite: 0
                    })
                }, r.set = function (t, e) {
                    return new r(t, 0, e)
                }, r.isTweening = function (t) {
                    return i.getTweensOf(t, !0).length > 0
                };
                var _ = function (t, e) {
                        for (var s = [], r = 0, n = t._first; n;) n instanceof i ? s[r++] = n : (e && (s[r++] = n), s = s.concat(_(n, e)), r = s.length), n = n._next;
                        return s
                    },
                    u = r.getAllTweens = function (e) {
                        return _(t._rootTimeline, e).concat(_(t._rootFramesTimeline, e))
                    };
                r.killAll = function (t, i, s, r) {
                    null == i && (i = !0), null == s && (s = !0);
                    var n, a, o, h = u(0 != r),
                        l = h.length,
                        _ = i && s && r;
                    for (o = 0; l > o; o++) a = h[o], (_ || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && (t ? a.totalTime(a.totalDuration()) : a._enabled(!1, !1))
                }, r.killChildTweensOf = function (t, e) {
                    if (null != t) {
                        var n, h, l, _, u, p = i._tweenLookup;
                        if ("string" == typeof t && (t = i.selector(t) || t), a(t) && (t = s.call(t, 0)), o(t))
                            for (_ = t.length; --_ > -1;) r.killChildTweensOf(t[_], e);
                        else {
                            n = [];
                            for (l in p)
                                for (h = p[l].target.parentNode; h;) h === t && (n = n.concat(p[l].tweens)), h = h.parentNode;
                            for (u = n.length, _ = 0; u > _; _++) e && n[_].totalTime(n[_].totalDuration()), n[_]._enabled(!1, !1)
                        }
                    }
                };
                var p = function (t, i, s, r) {
                    i = i !== !1, s = s !== !1, r = r !== !1;
                    for (var n, a, o = u(r), h = i && s && r, l = o.length; --l > -1;) a = o[l], (h || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && a.paused(t)
                };
                return r.pauseAll = function (t, e, i) {
                    p(!0, t, e, i)
                }, r.resumeAll = function (t, e, i) {
                    p(!1, t, e, i)
                }, r.globalTimeScale = function (e) {
                    var s = t._rootTimeline,
                        r = i.ticker.time;
                    return arguments.length ? (e = e || n, s._startTime = r - (r - s._startTime) * s._timeScale / e, s = t._rootFramesTimeline, r = i.ticker.frame, s._startTime = r - (r - s._startTime) * s._timeScale / e, s._timeScale = t._rootTimeline._timeScale = e, e) : s._timeScale
                }, h.progress = function (t) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
                }, h.totalProgress = function (t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration()
                }, h.time = function (t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                }, h.duration = function (e) {
                    return arguments.length ? t.prototype.duration.call(this, e) : this._duration
                }, h.totalDuration = function (t) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                }, h.repeat = function (t) {
                    return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                }, h.repeatDelay = function (t) {
                    return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                }, h.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, r
            }, !0), window._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
                var s = function (t) {
                        e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                        var i, s, r = this.vars;
                        for (s in r) i = r[s], a(i) && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i));
                        a(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                    },
                    r = 1e-10,
                    n = i._internals.isSelector,
                    a = i._internals.isArray,
                    o = [],
                    h = function (t) {
                        var e, i = {};
                        for (e in t) i[e] = t[e];
                        return i
                    },
                    l = function (t, e, i, s) {
                        t._timeline.pause(t._startTime), e && e.apply(s || t._timeline, i || o)
                    },
                    _ = o.slice,
                    u = s.prototype = new e;
                return s.version = "1.11.6", u.constructor = s, u.kill()._gc = !1, u.to = function (t, e, s, r) {
                    return e ? this.add(new i(t, e, s), r) : this.set(t, s, r)
                }, u.from = function (t, e, s, r) {
                    return this.add(i.from(t, e, s), r)
                }, u.fromTo = function (t, e, s, r, n) {
                    return e ? this.add(i.fromTo(t, e, s, r), n) : this.set(t, r, n)
                }, u.staggerTo = function (t, e, r, a, o, l, u, p) {
                    var c, f = new s({
                        onComplete: l,
                        onCompleteParams: u,
                        onCompleteScope: p,
                        smoothChildTiming: this.smoothChildTiming
                    });
                    for ("string" == typeof t && (t = i.selector(t) || t), n(t) && (t = _.call(t, 0)), a = a || 0, c = 0; t.length > c; c++) r.startAt && (r.startAt = h(r.startAt)), f.to(t[c], e, h(r), c * a);
                    return this.add(f, o)
                }, u.staggerFrom = function (t, e, i, s, r, n, a, o) {
                    return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o)
                }, u.staggerFromTo = function (t, e, i, s, r, n, a, o, h) {
                    return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h)
                }, u.call = function (t, e, s, r) {
                    return this.add(i.delayedCall(0, t, e, s), r)
                }, u.set = function (t, e, s) {
                    return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s)
                }, s.exportRoot = function (t, e) {
                    t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
                    var r, n, a = new s(t),
                        o = a._timeline;
                    for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;) n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n;
                    return o.add(a, 0), a
                }, u.add = function (r, n, o, h) {
                    var l, _, u, p, c, f;
                    if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) {
                        if (r instanceof Array || r && r.push && a(r)) {
                            for (o = o || "normal", h = h || 0, l = n, _ = r.length, u = 0; _ > u; u++) a(p = r[u]) && (p = new s({
                                tweens: p
                            })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === o ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === o && (p._startTime -= p.delay())), l += h;
                            return this._uncache(!0)
                        }
                        if ("string" == typeof r) return this.addLabel(r, n);
                        if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                        r = i.delayedCall(0, r)
                    }
                    if (e.prototype.add.call(this, r, n), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                        for (c = this, f = c.rawTime() > r._startTime; c._timeline;) f && c._timeline.smoothChildTiming ? c.totalTime(c._totalTime, !0) : c._gc && c._enabled(!0, !1), c = c._timeline;
                    return this
                }, u.remove = function (e) {
                    if (e instanceof t) return this._remove(e, !1);
                    if (e instanceof Array || e && e.push && a(e)) {
                        for (var i = e.length; --i > -1;) this.remove(e[i]);
                        return this
                    }
                    return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
                }, u._remove = function (t, i) {
                    e.prototype._remove.call(this, t, i);
                    var s = this._last;
                    return s ? this._time > s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                }, u.append = function (t, e) {
                    return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
                }, u.insert = u.insertMultiple = function (t, e, i, s) {
                    return this.add(t, e || 0, i, s)
                }, u.appendMultiple = function (t, e, i, s) {
                    return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s)
                }, u.addLabel = function (t, e) {
                    return this._labels[t] = this._parseTimeOrLabel(e), this
                }, u.addPause = function (t, e, i, s) {
                    return this.call(l, ["{self}", e, i, s], this, t)
                }, u.removeLabel = function (t) {
                    return delete this._labels[t], this
                }, u.getLabelTime = function (t) {
                    return null != this._labels[t] ? this._labels[t] : -1
                }, u._parseTimeOrLabel = function (e, i, s, r) {
                    var n;
                    if (r instanceof t && r.timeline === this) this.remove(r);
                    else if (r && (r instanceof Array || r.push && a(r)))
                        for (n = r.length; --n > -1;) r[n] instanceof t && r[n].timeline === this && this.remove(r[n]);
                    if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s);
                    if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration());
                    else {
                        if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
                        i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration()
                    }
                    return Number(e) + i
                }, u.seek = function (t, e) {
                    return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
                }, u.stop = function () {
                    return this.paused(!0)
                }, u.gotoAndPlay = function (t, e) {
                    return this.play(t, e)
                }, u.gotoAndStop = function (t, e) {
                    return this.pause(t, e)
                }, u.render = function (t, e, i) {
                    this._gc && this._enabled(!0, !1);
                    var s, n, a, h, l, _ = this._dirty ? this.totalDuration() : this._totalDuration,
                        u = this._time,
                        p = this._startTime,
                        c = this._timeScale,
                        f = this._paused;
                    if (t >= _ ? (this._totalTime = this._time = _, this._reversed || this._hasPausedChild() || (n = !0, h = "onComplete", 0 === this._duration && (0 === t || 0 > this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > r && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = _ + 1e-4) : 1e-7 > t ? (this._totalTime = this._time = 0, (0 !== u || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (h = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t) : (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (l = !0))) : this._totalTime = this._time = this._rawPrevTime = t, this._time !== u && this._first || i || l) {
                        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== u && t > 0 && (this._active = !0), 0 === u && this.vars.onStart && 0 !== this._time && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || o)), this._time >= u)
                            for (s = this._first; s && (a = s._next, !this._paused || f);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
                        else
                            for (s = this._last; s && (a = s._prev, !this._paused || f);)(s._active || u >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
                        this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || o)), h && (this._gc || (p === this._startTime || c !== this._timeScale) && (0 === this._time || _ >= this.totalDuration()) && (n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this.vars[h].apply(this.vars[h + "Scope"] || this, this.vars[h + "Params"] || o)))
                    }
                }, u._hasPausedChild = function () {
                    for (var t = this._first; t;) {
                        if (t._paused || t instanceof s && t._hasPausedChild()) return !0;
                        t = t._next
                    }
                    return !1
                }, u.getChildren = function (t, e, s, r) {
                    r = r || -9999999999;
                    for (var n = [], a = this._first, o = 0; a;) r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next;
                    return n
                }, u.getTweensOf = function (t, e) {
                    for (var s = i.getTweensOf(t), r = s.length, n = [], a = 0; --r > -1;)(s[r].timeline === this || e && this._contains(s[r])) && (n[a++] = s[r]);
                    return n
                }, u._contains = function (t) {
                    for (var e = t.timeline; e;) {
                        if (e === this) return !0;
                        e = e.timeline
                    }
                    return !1
                }, u.shiftChildren = function (t, e, i) {
                    i = i || 0;
                    for (var s, r = this._first, n = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                    if (e)
                        for (s in n) n[s] >= i && (n[s] += t);
                    return this._uncache(!0)
                }, u._kill = function (t, e) {
                    if (!t && !e) return this._enabled(!1, !1);
                    for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;) i[s]._kill(t, e) && (r = !0);
                    return r
                }, u.clear = function (t) {
                    var e = this.getChildren(!1, !0, !0),
                        i = e.length;
                    for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                    return t !== !1 && (this._labels = {}), this._uncache(!0)
                }, u.invalidate = function () {
                    for (var t = this._first; t;) t.invalidate(), t = t._next;
                    return this
                }, u._enabled = function (t, i) {
                    if (t === this._gc)
                        for (var s = this._first; s;) s._enabled(t, !0), s = s._next;
                    return e.prototype._enabled.call(this, t, i)
                }, u.duration = function (t) {
                    return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
                }, u.totalDuration = function (t) {
                    if (!arguments.length) {
                        if (this._dirty) {
                            for (var e, i, s = 0, r = this._last, n = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e;
                            this._duration = this._totalDuration = s, this._dirty = !1
                        }
                        return this._totalDuration
                    }
                    return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this
                }, u.usesFrames = function () {
                    for (var e = this._timeline; e._timeline;) e = e._timeline;
                    return e === t._rootFramesTimeline
                }, u.rawTime = function () {
                    return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
                }, s
            }, !0), window._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) {
                var s = function (e) {
                        t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                    },
                    r = 1e-10,
                    n = [],
                    a = new i(null, null, 1, 0),
                    o = s.prototype = new t;
                return o.constructor = s, o.kill()._gc = !1, s.version = "1.11.6", o.invalidate = function () {
                    return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
                }, o.addCallback = function (t, i, s, r) {
                    return this.add(e.delayedCall(0, t, s, r), i)
                }, o.removeCallback = function (t, e) {
                    if (t)
                        if (null == e) this._kill(null, t);
                        else
                            for (var i = this.getTweensOf(t, !1), s = i.length, r = this._parseTimeOrLabel(e); --s > -1;) i[s]._startTime === r && i[s]._enabled(!1, !1);
                    return this
                }, o.tweenTo = function (t, i) {
                    i = i || {};
                    var s, r, o, h = {
                        ease: a,
                        overwrite: 2,
                        useFrames: this.usesFrames(),
                        immediateRender: !1
                    };
                    for (r in i) h[r] = i[r];
                    return h.time = this._parseTimeOrLabel(t), s = Math.abs(Number(h.time) - this._time) / this._timeScale || .001, o = new e(this, s, h), h.onStart = function () {
                        o.target.paused(!0), o.vars.time !== o.target.time() && s === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || o, i.onStartParams || n)
                    }, o
                }, o.tweenFromTo = function (t, e, i) {
                    i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                        onComplete: this.seek,
                        onCompleteParams: [t],
                        onCompleteScope: this
                    }, i.immediateRender = i.immediateRender !== !1;
                    var s = this.tweenTo(e, i);
                    return s.duration(Math.abs(s.vars.time - t) / this._timeScale || .001)
                }, o.render = function (t, e, i) {
                    this._gc && this._enabled(!0, !1);
                    var s, a, o, h, l, _, u = this._dirty ? this.totalDuration() : this._totalDuration,
                        p = this._duration,
                        c = this._time,
                        f = this._totalTime,
                        m = this._startTime,
                        d = this._timeScale,
                        g = this._rawPrevTime,
                        v = this._paused,
                        y = this._cycle;
                    if (t >= u ? (this._locked || (this._totalTime = u, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, h = "onComplete", 0 === this._duration && (0 === t || 0 > g || g === r) && g !== t && this._first && (l = !0, g > r && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = p, t = p + 1e-4)) : 1e-7 > t ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== c || 0 === p && g !== r && (g > 0 || 0 > t && g >= 0) && !this._locked) && (h = "onReverseComplete", a = this._reversed), 0 > t ? (this._active = !1, 0 === p && g >= 0 && this._first && (l = !0), this._rawPrevTime = t) : (this._rawPrevTime = p || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (l = !0))) : (0 === p && 0 > g && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (_ = p + this._repeatDelay, this._cycle = this._totalTime / _ >> 0, 0 !== this._cycle && this._cycle === this._totalTime / _ && this._cycle--, this._time = this._totalTime - this._cycle * _, this._yoyo && 0 !== (1 & this._cycle) && (this._time = p - this._time), this._time > p ? (this._time = p, t = p + 1e-4) : 0 > this._time ? this._time = t = 0 : t = this._time))), this._cycle !== y && !this._locked) {
                        var T = this._yoyo && 0 !== (1 & y),
                            w = T === (this._yoyo && 0 !== (1 & this._cycle)),
                            x = this._totalTime,
                            b = this._cycle,
                            P = this._rawPrevTime,
                            S = this._time;
                        if (this._totalTime = y * p, y > this._cycle ? T = !T : this._totalTime += p, this._time = c, this._rawPrevTime = 0 === p ? g - 1e-4 : g, this._cycle = y, this._locked = !0, c = T ? 0 : p, this.render(c, e, 0 === p), e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || n), w && (c = T ? p + 1e-4 : -1e-4, this.render(c, !0, !1)), this._locked = !1, this._paused && !v) return;
                        this._time = S, this._totalTime = x, this._cycle = b, this._rawPrevTime = P
                    }
                    if (!(this._time !== c && this._first || i || l)) return void(f !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n)));
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== f && t > 0 && (this._active = !0), 0 === f && this.vars.onStart && 0 !== this._totalTime && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || n)), this._time >= c)
                        for (s = this._first; s && (o = s._next, !this._paused || v);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = o;
                    else
                        for (s = this._last; s && (o = s._prev, !this._paused || v);)(s._active || c >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = o;
                    this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n)), h && (this._locked || this._gc || (m === this._startTime || d !== this._timeScale) && (0 === this._time || u >= this.totalDuration()) && (a && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this.vars[h].apply(this.vars[h + "Scope"] || this, this.vars[h + "Params"] || n)))
                }, o.getActive = function (t, e, i) {
                    null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
                    var s, r, n = [],
                        a = this.getChildren(t, e, i),
                        o = 0,
                        h = a.length;
                    for (s = 0; h > s; s++) r = a[s], r.isActive() && (n[o++] = r);
                    return n
                }, o.getLabelAfter = function (t) {
                    t || 0 !== t && (t = this._time);
                    var e, i = this.getLabelsArray(),
                        s = i.length;
                    for (e = 0; s > e; e++)
                        if (i[e].time > t) return i[e].name;
                    return null
                }, o.getLabelBefore = function (t) {
                    null == t && (t = this._time);
                    for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                        if (t > e[i].time) return e[i].name;
                    return null
                }, o.getLabelsArray = function () {
                    var t, e = [],
                        i = 0;
                    for (t in this._labels) e[i++] = {
                        time: this._labels[t],
                        name: t
                    };
                    return e.sort(function (t, e) {
                        return t.time - e.time
                    }), e
                }, o.progress = function (t) {
                    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
                }, o.totalProgress = function (t) {
                    return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration()
                }, o.totalDuration = function (e) {
                    return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                }, o.time = function (t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
                }, o.repeat = function (t) {
                    return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
                }, o.repeatDelay = function (t) {
                    return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
                }, o.yoyo = function (t) {
                    return arguments.length ? (this._yoyo = t, this) : this._yoyo
                }, o.currentLabel = function (t) {
                    return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
                }, s
            }, !0),
            function () {
                var t = 180 / Math.PI,
                    e = [],
                    i = [],
                    s = [],
                    r = {},
                    n = function (t, e, i, s) {
                        this.a = t, this.b = e, this.c = i, this.d = s, this.da = s - t, this.ca = i - t, this.ba = e - t
                    },
                    a = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                    o = function (t, e, i, s) {
                        var r = {
                                a: t
                            },
                            n = {},
                            a = {},
                            o = {
                                c: s
                            },
                            h = (t + e) / 2,
                            l = (e + i) / 2,
                            _ = (i + s) / 2,
                            u = (h + l) / 2,
                            p = (l + _) / 2,
                            c = (p - u) / 8;
                        return r.b = h + (t - h) / 4, n.b = u + c, r.c = n.a = (r.b + n.b) / 2, n.c = a.a = (u + p) / 2, a.b = p - c, o.b = _ + (s - _) / 4, a.c = o.a = (a.b + o.b) / 2, [r, n, a, o]
                    },
                    h = function (t, r, n, a, h) {
                        var l, _, u, p, c, f, m, d, g, v, y, T, w, x = t.length - 1,
                            b = 0,
                            P = t[0].a;
                        for (l = 0; x > l; l++) c = t[b], _ = c.a, u = c.d, p = t[b + 1].d, h ? (y = e[l], T = i[l], w = .25 * (T + y) * r / (a ? .5 : s[l] || .5), f = u - (u - _) * (a ? .5 * r : 0 !== y ? w / y : 0), m = u + (p - u) * (a ? .5 * r : 0 !== T ? w / T : 0), d = u - (f + ((m - f) * (3 * y / (y + T) + .5) / 4 || 0))) : (f = u - .5 * (u - _) * r, m = u + .5 * (p - u) * r, d = u - (f + m) / 2), f += d, m += d, c.c = g = f, c.b = 0 !== l ? P : P = c.a + .6 * (c.c - c.a), c.da = u - _, c.ca = g - _, c.ba = P - _, n ? (v = o(_, P, g, u), t.splice(b, 1, v[0], v[1], v[2], v[3]), b += 4) : b++, P = m;
                        c = t[b], c.b = P, c.c = P + .4 * (c.d - P), c.da = c.d - c.a, c.ca = c.c - c.a, c.ba = P - c.a, n && (v = o(c.a, P, c.c, c.d), t.splice(b, 1, v[0], v[1], v[2], v[3]))
                    },
                    l = function (t, s, r, a) {
                        var o, h, l, _, u, p, c = [];
                        if (a)
                            for (t = [a].concat(t), h = t.length; --h > -1;) "string" == typeof (p = t[h][s]) && "=" === p.charAt(1) && (t[h][s] = a[s] + Number(p.charAt(0) + p.substr(2)));
                        if (o = t.length - 2, 0 > o) return c[0] = new n(t[0][s], 0, 0, t[-1 > o ? 0 : 1][s]), c;
                        for (h = 0; o > h; h++) l = t[h][s], _ = t[h + 1][s], c[h] = new n(l, 0, 0, _), r && (u = t[h + 2][s], e[h] = (e[h] || 0) + (_ - l) * (_ - l), i[h] = (i[h] || 0) + (u - _) * (u - _));
                        return c[h] = new n(t[h][s], 0, 0, t[h + 1][s]), c
                    },
                    _ = function (t, n, o, _, u, p) {
                        var c, f, m, d, g, v, y, T, w = {},
                            x = [],
                            b = p || t[0];
                        u = "string" == typeof u ? "," + u + "," : a, null == n && (n = 1);
                        for (f in t[0]) x.push(f);
                        if (t.length > 1) {
                            for (T = t[t.length - 1], y = !0, c = x.length; --c > -1;)
                                if (f = x[c], Math.abs(b[f] - T[f]) > .05) {
                                    y = !1;
                                    break
                                }
                            y && (t = t.concat(), p && t.unshift(p), t.push(t[1]), p = t[t.length - 3])
                        }
                        for (e.length = i.length = s.length = 0, c = x.length; --c > -1;) f = x[c], r[f] = -1 !== u.indexOf("," + f + ","), w[f] = l(t, f, r[f], p);
                        for (c = e.length; --c > -1;) e[c] = Math.sqrt(e[c]), i[c] = Math.sqrt(i[c]);
                        if (!_) {
                            for (c = x.length; --c > -1;)
                                if (r[f])
                                    for (m = w[x[c]], v = m.length - 1, d = 0; v > d; d++) g = m[d + 1].da / i[d] + m[d].da / e[d], s[d] = (s[d] || 0) + g * g;
                            for (c = s.length; --c > -1;) s[c] = Math.sqrt(s[c])
                        }
                        for (c = x.length, d = o ? 4 : 1; --c > -1;) f = x[c], m = w[f], h(m, n, o, _, r[f]), y && (m.splice(0, d), m.splice(m.length - d, d));
                        return w
                    },
                    u = function (t, e, i) {
                        e = e || "soft";
                        var s, r, a, o, h, l, _, u, p, c, f, m = {},
                            d = "cubic" === e ? 3 : 2,
                            g = "soft" === e,
                            v = [];
                        if (g && i && (t = [i].concat(t)), null == t || d + 1 > t.length) throw "invalid Bezier data";
                        for (p in t[0]) v.push(p);
                        for (l = v.length; --l > -1;) {
                            for (p = v[l], m[p] = h = [], c = 0, u = t.length, _ = 0; u > _; _++) s = null == i ? t[_][p] : "string" == typeof (f = t[_][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && _ > 1 && u - 1 > _ && (h[c++] = (s + h[c - 2]) / 2), h[c++] = s;
                            for (u = c - d + 1, c = 0, _ = 0; u > _; _ += d) s = h[_], r = h[_ + 1], a = h[_ + 2], o = 2 === d ? 0 : h[_ + 3], h[c++] = f = 3 === d ? new n(s, r, a, o) : new n(s, (2 * r + s) / 3, (2 * r + a) / 3, a);
                            h.length = c
                        }
                        return m
                    },
                    p = function (t, e, i) {
                        for (var s, r, n, a, o, h, l, _, u, p, c, f = 1 / i, m = t.length; --m > -1;)
                            for (p = t[m], n = p.a, a = p.d - n, o = p.c - n, h = p.b - n, s = r = 0, _ = 1; i >= _; _++) l = f * _, u = 1 - l, s = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), c = m * i + _ - 1, e[c] = (e[c] || 0) + s * s
                    },
                    c = function (t, e) {
                        e = e >> 0 || 6;
                        var i, s, r, n, a = [],
                            o = [],
                            h = 0,
                            l = 0,
                            _ = e - 1,
                            u = [],
                            c = [];
                        for (i in t) p(t[i], a, e);
                        for (r = a.length, s = 0; r > s; s++) h += Math.sqrt(a[s]), n = s % e, c[n] = h, n === _ && (l += h, n = s / e >> 0, u[n] = c, o[n] = l, h = 0, c = []);
                        return {
                            length: l,
                            lengths: o,
                            segments: u
                        }
                    },
                    f = window._gsDefine.plugin({
                        propName: "bezier",
                        priority: -1,
                        version: "1.3.1",
                        API: 2,
                        global: !0,
                        init: function (t, e, i) {
                            this._target = t, e instanceof Array && (e = {
                                values: e
                            }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                            var s, r, n, a, o, h = e.values || [],
                                l = {},
                                p = h[0],
                                f = e.autoRotate || i.vars.orientToBezier;
                            this._autoRotate = f ? f instanceof Array ? f : [
                                ["x", "y", "rotation", f === !0 ? 0 : Number(f) || 0]
                            ] : null;
                            for (s in p) this._props.push(s);
                            for (n = this._props.length; --n > -1;) s = this._props[n], this._overwriteProps.push(s), r = this._func[s] = "function" == typeof t[s], l[s] = r ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), o || l[s] !== h[0][s] && (o = l);
                            if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? _(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : u(h, e.type, l), this._segCount = this._beziers[s].length, this._timeRes) {
                                var m = c(this._beziers, this._timeRes);
                                this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                            }
                            if (f = this._autoRotate)
                                for (this._initialRotations = [], f[0] instanceof Array || (this._autoRotate = f = [f]), n = f.length; --n > -1;) {
                                    for (a = 0; 3 > a; a++) s = f[n][a], this._func[s] = "function" == typeof t[s] ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)] : !1;
                                    s = f[n][2], this._initialRotations[n] = this._func[s] ? this._func[s].call(this._target) : this._target[s]
                                }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                        },
                        set: function (e) {
                            var i, s, r, n, a, o, h, l, _, u, p = this._segCount,
                                c = this._func,
                                f = this._target,
                                m = e !== this._startRatio;
                            if (this._timeRes) {
                                if (_ = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && p - 1 > r) {
                                    for (l = p - 1; l > r && e >= (this._l2 = _[++r]););
                                    this._l1 = _[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                                } else if (this._l1 > e && r > 0) {
                                    for (; r > 0 && (this._l1 = _[--r]) >= e;);
                                    0 === r && this._l1 > e ? this._l1 = 0 : r++, this._l2 = _[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                }
                                if (i = r, e -= this._l1, r = this._si, e > this._s2 && u.length - 1 > r) {
                                    for (l = u.length - 1; l > r && e >= (this._s2 = u[++r]););
                                    this._s1 = u[r - 1], this._si = r
                                } else if (this._s1 > e && r > 0) {
                                    for (; r > 0 && (this._s1 = u[--r]) >= e;);
                                    0 === r && this._s1 > e ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                                }
                                o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec
                            } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, o = (e - i * (1 / p)) * p;
                            for (s = 1 - o, r = this._props.length; --r > -1;) n = this._props[r], a = this._beziers[n][i], h = (o * o * a.da + 3 * s * (o * a.ca + s * a.ba)) * o + a.a, this._round[n] && (h = h + (h > 0 ? .5 : -.5) >> 0), c[n] ? f[n](h) : f[n] = h;
                            if (this._autoRotate) {
                                var d, g, v, y, T, w, x, b = this._autoRotate;
                                for (r = b.length; --r > -1;) n = b[r][2], w = b[r][3] || 0, x = b[r][4] === !0 ? 1 : t, a = this._beziers[b[r][0]], d = this._beziers[b[r][1]], a && d && (a = a[i], d = d[i], g = a.a + (a.b - a.a) * o, y = a.b + (a.c - a.b) * o, g += (y - g) * o, y += (a.c + (a.d - a.c) * o - y) * o, v = d.a + (d.b - d.a) * o, T = d.b + (d.c - d.b) * o, v += (T - v) * o, T += (d.c + (d.d - d.c) * o - T) * o, h = m ? Math.atan2(T - v, y - g) * x + w : this._initialRotations[r], c[n] ? f[n](h) : f[n] = h)
                            }
                        }
                    }),
                    m = f.prototype;
                f.bezierThrough = _, f.cubicToQuadratic = o, f._autoCSS = !0, f.quadraticToCubic = function (t, e, i) {
                    return new n(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
                }, f._cssRegister = function () {
                    var t = window._gsDefine.globals.CSSPlugin;
                    if (t) {
                        var e = t._internals,
                            i = e._parseToProxy,
                            s = e._setPluginRatio,
                            r = e.CSSPropTween;
                        e._registerComplexSpecialProp("bezier", {
                            parser: function (t, e, n, a, o, h) {
                                e instanceof Array && (e = {
                                    values: e
                                }), h = new f;
                                var l, _, u, p = e.values,
                                    c = p.length - 1,
                                    m = [],
                                    d = {};
                                if (0 > c) return o;
                                for (l = 0; c >= l; l++) u = i(t, p[l], a, o, h, c !== l), m[l] = u.end;
                                for (_ in e) d[_] = e[_];
                                return d.values = m, o = new r(t, "bezier", 0, 0, u.pt, 2), o.data = u, o.plugin = h, o.setRatio = s, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (l = d.autoRotate === !0 ? 0 : Number(d.autoRotate), d.autoRotate = null != u.end.left ? [
                                    ["left", "top", "rotation", l, !1]
                                ] : null != u.end.x ? [
                                    ["x", "y", "rotation", l, !1]
                                ] : !1), d.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform), h._onInitTween(u.proxy, d, a._tween), o
                            }
                        })
                    }
                }, m._roundProps = function (t, e) {
                    for (var i = this._overwriteProps, s = i.length; --s > -1;)(t[i[s]] || t.bezier || t.bezierThrough) && (this._round[i[s]] = e)
                }, m._kill = function (t) {
                    var e, i, s = this._props;
                    for (e in this._beziers)
                        if (e in t)
                            for (delete this._beziers[e], delete this._func[e], i = s.length; --i > -1;) s[i] === e && s.splice(i, 1);
                    return this._super._kill.call(this, t)
                }
            }(), window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
                var i, s, r, n, a = function () {
                        t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio
                    },
                    o = {},
                    h = a.prototype = new t("css");
                h.constructor = a, a.version = "1.11.6", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", h = "px", a.suffixMap = {
                    top: h,
                    right: h,
                    bottom: h,
                    left: h,
                    width: h,
                    height: h,
                    fontSize: h,
                    padding: h,
                    margin: h,
                    perspective: h,
                    lineHeight: ""
                };
                var l, _, u, p, c, f, m = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                    d = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                    g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                    v = /[^\d\-\.]/g,
                    y = /(?:\d|\-|\+|=|#|\.)*/g,
                    T = /opacity *= *([^)]*)/,
                    w = /opacity:([^;]*)/,
                    x = /alpha\(opacity *=.+?\)/i,
                    b = /^(rgb|hsl)/,
                    P = /([A-Z])/g,
                    S = /-([a-z])/gi,
                    k = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                    R = function (t, e) {
                        return e.toUpperCase()
                    },
                    A = /(?:Left|Right|Width)/i,
                    C = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                    O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                    D = /,(?=[^\)]*(?:\(|$))/gi,
                    M = Math.PI / 180,
                    I = 180 / Math.PI,
                    E = {},
                    N = document,
                    F = N.createElement("div"),
                    L = N.createElement("img"),
                    X = a._internals = {
                        _specialProps: o
                    },
                    z = navigator.userAgent,
                    U = function () {
                        var t, e = z.indexOf("Android"),
                            i = N.createElement("div");
                        return u = -1 !== z.indexOf("Safari") && -1 === z.indexOf("Chrome") && (-1 === e || Number(z.substr(e + 8, 1)) > 3), c = u && 6 > Number(z.substr(z.indexOf("Version/") + 8, 1)), p = -1 !== z.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(z) && (f = parseFloat(RegExp.$1)), i.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", t = i.getElementsByTagName("a")[0], t ? /^0.55/.test(t.style.opacity) : !1
                    }(),
                    Y = function (t) {
                        return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                    },
                    j = function (t) {
                        window.console && console.log(t)
                    },
                    B = "",
                    q = "",
                    V = function (t, e) {
                        e = e || F;
                        var i, s, r = e.style;
                        if (void 0 !== r[t]) return t;
                        for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];);
                        return s >= 0 ? (q = 3 === s ? "ms" : i[s], B = "-" + q.toLowerCase() + "-", q + t) : null
                    },
                    W = N.defaultView ? N.defaultView.getComputedStyle : function () {},
                    G = a.getStyle = function (t, e, i, s, r) {
                        var n;
                        return U || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || W(t, null)) ? (t = i.getPropertyValue(e.replace(P, "-$1").toLowerCase()), n = t || i.length ? t : i[e]) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : Y(t)
                    },
                    $ = X.convertToPixels = function (t, e, i, s, r) {
                        if ("px" === s || !s) return i;
                        if ("auto" === s || !i) return 0;
                        var n, a = A.test(e),
                            o = t,
                            h = F.style,
                            l = 0 > i;
                        return l && (i = -i), "%" === s && -1 !== e.indexOf("border") ? n = i / 100 * (a ? t.clientWidth : t.clientHeight) : (h.cssText = "border:0 solid red;position:" + G(t, "position") + ";line-height:0;", "%" !== s && o.appendChild ? h[a ? "borderLeftWidth" : "borderTopWidth"] = i + s : (o = t.parentNode || N.body, h[a ? "width" : "height"] = i + s), o.appendChild(F), n = parseFloat(F[a ? "offsetWidth" : "offsetHeight"]), o.removeChild(F), 0 !== n || r || (n = $(t, e, i, s, !0))), l ? -n : n
                    },
                    Z = X.calculateOffset = function (t, e, i) {
                        if ("absolute" !== G(t, "position", i)) return 0;
                        var s = "left" === e ? "Left" : "Top",
                            r = G(t, "margin" + s, i);
                        return t["offset" + s] - ($(t, e, parseFloat(r), r.replace(y, "")) || 0)
                    },
                    Q = function (t, e) {
                        var i, s, r = {};
                        if (e = e || W(t, null))
                            if (i = e.length)
                                for (; --i > -1;) r[e[i].replace(S, R)] = e.getPropertyValue(e[i]);
                            else
                                for (i in e) r[i] = e[i];
                        else if (e = t.currentStyle || t.style)
                            for (i in e) "string" == typeof i && void 0 === r[i] && (r[i.replace(S, R)] = e[i]);
                        return U || (r.opacity = Y(t)), s = Pe(t, e, !1), r.rotation = s.rotation, r.skewX = s.skewX, r.scaleX = s.scaleX, r.scaleY = s.scaleY, r.x = s.x, r.y = s.y, xe && (r.z = s.z, r.rotationX = s.rotationX, r.rotationY = s.rotationY, r.scaleZ = s.scaleZ), r.filters && delete r.filters, r
                    },
                    H = function (t, e, i, s, r) {
                        var n, a, o, h = {},
                            l = t.style;
                        for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (h[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(v, "") ? n : 0 : Z(t, a), void 0 !== l[a] && (o = new ue(l, a, l[a], o)));
                        if (s)
                            for (a in s) "className" !== a && (h[a] = s[a]);
                        return {
                            difs: h,
                            firstMPT: o
                        }
                    },
                    K = {
                        width: ["Left", "Right"],
                        height: ["Top", "Bottom"]
                    },
                    J = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                    te = function (t, e, i) {
                        var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                            r = K[e],
                            n = r.length;
                        for (i = i || W(t, null); --n > -1;) s -= parseFloat(G(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(G(t, "border" + r[n] + "Width", i, !0)) || 0;
                        return s
                    },
                    ee = function (t, e) {
                        (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0");
                        var i = t.split(" "),
                            s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
                            r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
                        return null == r ? r = "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(v, "")), e.oy = parseFloat(r.replace(v, ""))), s + " " + r + (i.length > 2 ? " " + i[2] : "")
                    },
                    ie = function (t, e) {
                        return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e)
                    },
                    se = function (t, e) {
                        return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * Number(t.substr(2)) + e : parseFloat(t)
                    },
                    re = function (t, e, i, s) {
                        var r, n, a, o, h = 1e-6;
                        return null == t ? o = e : "number" == typeof t ? o = t : (r = 360, n = t.split("_"), a = Number(n[0].replace(v, "")) * (-1 === t.indexOf("rad") ? 1 : I) - ("=" === t.charAt(1) ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), h > o && o > -h && (o = 0), o
                    },
                    ne = {
                        aqua: [0, 255, 255],
                        lime: [0, 255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, 255],
                        navy: [0, 0, 128],
                        white: [255, 255, 255],
                        fuchsia: [255, 0, 255],
                        olive: [128, 128, 0],
                        yellow: [255, 255, 0],
                        orange: [255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [255, 0, 0],
                        pink: [255, 192, 203],
                        cyan: [0, 255, 255],
                        transparent: [255, 255, 255, 0]
                    },
                    ae = function (t, e, i) {
                        return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5
                    },
                    oe = function (t) {
                        var e, i, s, r, n, a;
                        return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ne[t] ? ne[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(m), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = ae(r + 1 / 3, e, i), t[1] = ae(r, e, i), t[2] = ae(r - 1 / 3, e, i), t) : (t = t.match(m) || ne.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : ne.black
                    },
                    he = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
                for (h in ne) he += "|" + h + "\\b";
                he = RegExp(he + ")", "gi");
                var le = function (t, e, i, s) {
                        if (null == t) return function (t) {
                            return t
                        };
                        var r, n = e ? (t.match(he) || [""])[0] : "",
                            a = t.split(n).join("").match(g) || [],
                            o = t.substr(0, t.indexOf(a[0])),
                            h = ")" === t.charAt(t.length - 1) ? ")" : "",
                            l = -1 !== t.indexOf(" ") ? " " : ",",
                            _ = a.length,
                            u = _ > 0 ? a[0].replace(m, "") : "";
                        return _ ? r = e ? function (t) {
                            var e, p, c, f;
                            if ("number" == typeof t) t += u;
                            else if (s && D.test(t)) {
                                for (f = t.replace(D, "|").split("|"), c = 0; f.length > c; c++) f[c] = r(f[c]);
                                return f.join(",")
                            }
                            if (e = (t.match(he) || [n])[0], p = t.split(e).join("").match(g) || [], c = p.length, _ > c--)
                                for (; _ > ++c;) p[c] = i ? p[0 | (c - 1) / 2] : a[c];
                            return o + p.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "")
                        } : function (t) {
                            var e, n, p;
                            if ("number" == typeof t) t += u;
                            else if (s && D.test(t)) {
                                for (n = t.replace(D, "|").split("|"), p = 0; n.length > p; p++) n[p] = r(n[p]);
                                return n.join(",")
                            }
                            if (e = t.match(g) || [], p = e.length, _ > p--)
                                for (; _ > ++p;) e[p] = i ? e[0 | (p - 1) / 2] : a[p];
                            return o + e.join(l) + h
                        } : function (t) {
                            return t
                        }
                    },
                    _e = function (t) {
                        return t = t.split(","),
                            function (e, i, s, r, n, a, o) {
                                var h, l = (i + "").split(" ");
                                for (o = {}, h = 0; 4 > h; h++) o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0];
                                return r.parse(e, o, n, a)
                            }
                    },
                    ue = (X._setPluginRatio = function (t) {
                        this.plugin.setRatio(t);
                        for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, h = 1e-6; o;) e = a[o.v], o.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : h > e && e > -h && (e = 0), o.t[o.p] = e, o = o._next;
                        if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t)
                            for (o = n.firstMPT; o;) {
                                if (i = o.t, i.type) {
                                    if (1 === i.type) {
                                        for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++) r += i["xn" + s] + i["xs" + (s + 1)];
                                        i.e = r
                                    }
                                } else i.e = i.s + i.xs0;
                                o = o._next
                            }
                    }, function (t, e, i, s, r) {
                        this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s)
                    }),
                    pe = (X._parseToProxy = function (t, e, i, s, r, n) {
                        var a, o, h, l, _, u = s,
                            p = {},
                            c = {},
                            f = i._transform,
                            m = E;
                        for (i._transform = null, E = e, s = _ = i.parse(t, e, s, r), E = m, n && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); s && s !== u;) {
                            if (1 >= s.type && (o = s.p, c[o] = s.s + s.c, p[o] = s.s, n || (l = new ue(s, "s", o, l, s.r), s.c = 0), 1 === s.type))
                                for (a = s.l; --a > 0;) h = "xn" + a, o = s.p + "_" + h, c[o] = s.data[h], p[o] = s[h], n || (l = new ue(s, h, o, l, s.rxp[h]));
                            s = s._next
                        }
                        return {
                            proxy: p,
                            end: c,
                            firstMPT: l,
                            pt: _
                        }
                    }, X.CSSPropTween = function (t, e, s, r, a, o, h, l, _, u, p) {
                        this.t = t, this.p = e, this.s = s, this.c = r, this.n = h || e, t instanceof pe || n.push(this.n), this.r = l, this.type = o || 0, _ && (this.pr = _, i = !0), this.b = void 0 === u ? s : u, this.e = void 0 === p ? s + r : p, a && (this._next = a, a._prev = this)
                    }),
                    ce = a.parseComplex = function (t, e, i, s, r, n, a, o, h, _) {
                        i = i || n || "", a = new pe(t, e, 0, 0, a, _ ? 2 : 1, null, !1, o, i, s), s += "";
                        var u, p, c, f, g, v, y, T, w, x, P, S, k = i.split(", ").join(",").split(" "),
                            R = s.split(", ").join(",").split(" "),
                            A = k.length,
                            C = l !== !1;
                        for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (k = k.join(" ").replace(D, ", ").split(" "), R = R.join(" ").replace(D, ", ").split(" "), A = k.length), A !== R.length && (k = (n || "").split(" "), A = k.length), a.plugin = h, a.setRatio = _, u = 0; A > u; u++)
                            if (f = k[u], g = R[u], T = parseFloat(f), T || 0 === T) a.appendXtra("", T, ie(g, T), g.replace(d, ""), C && -1 !== g.indexOf("px"), !0);
                            else if (r && ("#" === f.charAt(0) || ne[f] || b.test(f))) S = "," === g.charAt(g.length - 1) ? ")," : ")", f = oe(f), g = oe(g), w = f.length + g.length > 6, w && !U && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[u]).join("transparent")) : (U || (w = !1), a.appendXtra(w ? "rgba(" : "rgb(", f[0], g[0] - f[0], ",", !0, !0).appendXtra("", f[1], g[1] - f[1], ",", !0).appendXtra("", f[2], g[2] - f[2], w ? "," : S, !0), w && (f = 4 > f.length ? 1 : f[3], a.appendXtra("", f, (4 > g.length ? 1 : g[3]) - f, S, !1)));
                        else if (v = f.match(m)) {
                            if (y = g.match(d), !y || y.length !== v.length) return a;
                            for (c = 0, p = 0; v.length > p; p++) P = v[p], x = f.indexOf(P, c), a.appendXtra(f.substr(c, x - c), Number(P), ie(y[p], P), "", C && "px" === f.substr(x + P.length, 2), 0 === p), c = x + P.length;
                            a["xs" + a.l] += f.substr(c)
                        } else a["xs" + a.l] += a.l ? " " + f : f; if (-1 !== s.indexOf("=") && a.data) {
                            for (S = a.xs0 + a.data.s, u = 1; a.l > u; u++) S += a["xs" + u] + a.data["xn" + u];
                            a.e = S + a["xs" + u]
                        }
                        return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                    },
                    fe = 9;
                for (h = pe.prototype, h.l = h.pr = 0; --fe > 0;) h["xn" + fe] = 0, h["xs" + fe] = "";
                h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function (t, e, i, s, r, n) {
                    var a = this,
                        o = a.l;
                    return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                        s: e + i
                    }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a)
                };
                var me = function (t, e) {
                        e = e || {}, this.p = e.prefix ? V(t) || t : t, o[t] = o[this.p] = this, this.format = e.formatter || le(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
                    },
                    de = X._registerComplexSpecialProp = function (t, e, i) {
                        "object" != typeof e && (e = {
                            parser: i
                        });
                        var s, r, n = t.split(","),
                            a = e.defaultValue;
                        for (i = i || [a], s = 0; n.length > s; s++) e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new me(n[s], e)
                    },
                    ge = function (t) {
                        if (!o[t]) {
                            var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                            de(t, {
                                parser: function (t, i, s, r, n, a, h) {
                                    var l = (window.GreenSockGlobals || window).com.greensock.plugins[e];
                                    return l ? (l._cssRegister(), o[s].parse(t, i, s, r, n, a, h)) : (j("Error: " + e + " js file not loaded."), n)
                                }
                            })
                        }
                    };
                h = me.prototype, h.parseComplex = function (t, e, i, s, r, n) {
                    var a, o, h, l, _, u, p = this.keyword;
                    if (this.multi && (D.test(i) || D.test(e) ? (o = e.replace(D, "|").split("|"), h = i.replace(D, "|").split("|")) : p && (o = [e], h = [i])), h) {
                        for (l = h.length > o.length ? h.length : o.length, a = 0; l > a; a++) e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, p && (_ = e.indexOf(p), u = i.indexOf(p), _ !== u && (i = -1 === u ? h : o, i[a] += " " + p));
                        e = o.join(", "), i = h.join(", ")
                    }
                    return ce(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n)
                }, h.parse = function (t, e, i, s, n, a) {
                    return this.parseComplex(t.style, this.format(G(t, this.p, r, !1, this.dflt)), this.format(e), n, a)
                }, a.registerSpecialProp = function (t, e, i) {
                    de(t, {
                        parser: function (t, s, r, n, a, o) {
                            var h = new pe(t, r, 0, 0, a, 2, r, !1, i);
                            return h.plugin = o, h.setRatio = e(t, s, n._tween, r), h
                        },
                        priority: i
                    })
                };
                var ve = "scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","),
                    ye = V("transform"),
                    Te = B + "transform",
                    we = V("transformOrigin"),
                    xe = null !== V("perspective"),
                    be = X.Transform = function () {
                        this.skewY = 0
                    },
                    Pe = X.getTransform = function (t, e, i, s) {
                        if (t._gsTransform && i && !s) return t._gsTransform;
                        var r, n, o, h, l, _, u, p, c, f, m, d, g, v = i ? t._gsTransform || new be : new be,
                            y = 0 > v.scaleX,
                            T = 2e-5,
                            w = 1e5,
                            x = 179.99,
                            b = x * M,
                            P = xe ? parseFloat(G(t, we, e, !1, "0 0 0").split(" ")[2]) || v.zOrigin || 0 : 0;
                        for (ye ? r = G(t, Te, e, !0) : t.currentStyle && (r = t.currentStyle.filter.match(C), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), v.x || 0, v.y || 0].join(",") : ""), n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], o = n.length; --o > -1;) h = Number(n[o]), n[o] = (l = h - (h |= 0)) ? (0 | l * w + (0 > l ? -.5 : .5)) / w + h : h;
                        if (16 === n.length) {
                            var S = n[8],
                                k = n[9],
                                R = n[10],
                                A = n[12],
                                O = n[13],
                                D = n[14];
                            if (v.zOrigin && (D = -v.zOrigin, A = S * D - n[12], O = k * D - n[13], D = R * D + v.zOrigin - n[14]), !i || s || null == v.rotationX) {
                                var E, N, F, L, X, z, U, Y = n[0],
                                    j = n[1],
                                    B = n[2],
                                    q = n[3],
                                    V = n[4],
                                    W = n[5],
                                    $ = n[6],
                                    Z = n[7],
                                    Q = n[11],
                                    H = Math.atan2($, R),
                                    K = -b > H || H > b;
                                v.rotationX = H * I, H && (L = Math.cos(-H), X = Math.sin(-H), E = V * L + S * X, N = W * L + k * X, F = $ * L + R * X, S = V * -X + S * L, k = W * -X + k * L, R = $ * -X + R * L, Q = Z * -X + Q * L, V = E, W = N, $ = F), H = Math.atan2(S, Y), v.rotationY = H * I, H && (z = -b > H || H > b, L = Math.cos(-H), X = Math.sin(-H), E = Y * L - S * X, N = j * L - k * X, F = B * L - R * X, k = j * X + k * L, R = B * X + R * L, Q = q * X + Q * L, Y = E, j = N, B = F), H = Math.atan2(j, W), v.rotation = H * I, H && (U = -b > H || H > b, L = Math.cos(-H), X = Math.sin(-H), Y = Y * L + V * X, N = j * L + W * X, W = j * -X + W * L, $ = B * -X + $ * L, j = N), U && K ? v.rotation = v.rotationX = 0 : U && z ? v.rotation = v.rotationY = 0 : z && K && (v.rotationY = v.rotationX = 0), v.scaleX = (0 | Math.sqrt(Y * Y + j * j) * w + .5) / w, v.scaleY = (0 | Math.sqrt(W * W + k * k) * w + .5) / w, v.scaleZ = (0 | Math.sqrt($ * $ + R * R) * w + .5) / w, v.skewX = 0, v.perspective = Q ? 1 / (0 > Q ? -Q : Q) : 0, v.x = A, v.y = O, v.z = D
                            }
                        } else if (!(xe && !s && n.length && v.x === n[4] && v.y === n[5] && (v.rotationX || v.rotationY) || void 0 !== v.x && "none" === G(t, "display", e))) {
                            var J = n.length >= 6,
                                te = J ? n[0] : 1,
                                ee = n[1] || 0,
                                ie = n[2] || 0,
                                se = J ? n[3] : 1;
                            v.x = n[4] || 0, v.y = n[5] || 0, _ = Math.sqrt(te * te + ee * ee), u = Math.sqrt(se * se + ie * ie), p = te || ee ? Math.atan2(ee, te) * I : v.rotation || 0, c = ie || se ? Math.atan2(ie, se) * I + p : v.skewX || 0, f = _ - Math.abs(v.scaleX || 0), m = u - Math.abs(v.scaleY || 0), Math.abs(c) > 90 && 270 > Math.abs(c) && (y ? (_ *= -1, c += 0 >= p ? 180 : -180, p += 0 >= p ? 180 : -180) : (u *= -1, c += 0 >= c ? 180 : -180)), d = (p - v.rotation) % 180, g = (c - v.skewX) % 180, (void 0 === v.skewX || f > T || -T > f || m > T || -T > m || d > -x && x > d && !1 | d * w || g > -x && x > g && !1 | g * w) && (v.scaleX = _, v.scaleY = u, v.rotation = p, v.skewX = c), xe && (v.rotationX = v.rotationY = v.z = 0, v.perspective = parseFloat(a.defaultTransformPerspective) || 0, v.scaleZ = 1)
                        }
                        v.zOrigin = P;
                        for (o in v) T > v[o] && v[o] > -T && (v[o] = 0);
                        return i && (t._gsTransform = v), v
                    },
                    Se = function (t) {
                        var e, i, s = this.data,
                            r = -s.rotation * M,
                            n = r + s.skewX * M,
                            a = 1e5,
                            o = (0 | Math.cos(r) * s.scaleX * a) / a,
                            h = (0 | Math.sin(r) * s.scaleX * a) / a,
                            l = (0 | Math.sin(n) * -s.scaleY * a) / a,
                            _ = (0 | Math.cos(n) * s.scaleY * a) / a,
                            u = this.t.style,
                            p = this.t.currentStyle;
                        if (p) {
                            i = h, h = -l, l = -i, e = p.filter, u.filter = "";
                            var c, m, d = this.t.offsetWidth,
                                g = this.t.offsetHeight,
                                v = "absolute" !== p.position,
                                w = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + h + ", M21=" + l + ", M22=" + _,
                                x = s.x,
                                b = s.y;
                            if (null != s.ox && (c = (s.oxp ? .01 * d * s.ox : s.ox) - d / 2, m = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, x += c - (c * o + m * h), b += m - (c * l + m * _)), v ? (c = d / 2, m = g / 2, w += ", Dx=" + (c - (c * o + m * h) + x) + ", Dy=" + (m - (c * l + m * _) + b) + ")") : w += ", sizingMethod='auto expand')", u.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(O, w) : w + " " + e, (0 === t || 1 === t) && 1 === o && 0 === h && 0 === l && 1 === _ && (v && -1 === w.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) {
                                var P, S, k, R = 8 > f ? 1 : -1;
                                for (c = s.ieOffsetX || 0, m = s.ieOffsetY || 0, s.ieOffsetX = Math.round((d - ((0 > o ? -o : o) * d + (0 > h ? -h : h) * g)) / 2 + x), s.ieOffsetY = Math.round((g - ((0 > _ ? -_ : _) * g + (0 > l ? -l : l) * d)) / 2 + b), fe = 0; 4 > fe; fe++) S = J[fe], P = p[S], i = -1 !== P.indexOf("px") ? parseFloat(P) : $(this.t, S, parseFloat(P), P.replace(y, "")) || 0, k = i !== s[S] ? 2 > fe ? -s.ieOffsetX : -s.ieOffsetY : 2 > fe ? c - s.ieOffsetX : m - s.ieOffsetY, u[S] = (s[S] = Math.round(i - k * (0 === fe || 2 === fe ? 1 : R))) + "px"
                            }
                        }
                    },
                    ke = X.set3DTransformRatio = function () {
                        var t, e, i, s, r, n, a, o, h, l, _, u, c, f, m, d, g, v, y, T, w, x, b, P = this.data,
                            S = this.t.style,
                            k = P.rotation * M,
                            R = P.scaleX,
                            A = P.scaleY,
                            C = P.scaleZ,
                            O = P.perspective;
                        if (p) {
                            var D = 1e-4;
                            D > R && R > -D && (R = C = 2e-5), D > A && A > -D && (A = C = 2e-5), !O || P.z || P.rotationX || P.rotationY || (O = 0)
                        }
                        if (k || P.skewX) v = Math.cos(k), y = Math.sin(k), t = v, r = y, P.skewX && (k -= P.skewX * M, v = Math.cos(k), y = Math.sin(k), "simple" === P.skewType && (T = Math.tan(P.skewX * M), T = Math.sqrt(1 + T * T), v *= T, y *= T)), e = -y, n = v;
                        else {
                            if (!(P.rotationY || P.rotationX || 1 !== C || O)) return void(S[ye] = "translate3d(" + P.x + "px," + P.y + "px," + P.z + "px)" + (1 !== R || 1 !== A ? " scale(" + R + "," + A + ")" : ""));
                            t = n = 1, e = r = 0
                        }
                        _ = 1, i = s = a = o = h = l = u = c = f = 0, m = O ? -1 / O : 0, d = P.zOrigin, g = 1e5, k = P.rotationY * M, k && (v = Math.cos(k), y = Math.sin(k), h = _ * -y, c = m * -y, i = t * y, a = r * y, _ *= v, m *= v, t *= v, r *= v), k = P.rotationX * M, k && (v = Math.cos(k), y = Math.sin(k), T = e * v + i * y, w = n * v + a * y, x = l * v + _ * y, b = f * v + m * y, i = e * -y + i * v, a = n * -y + a * v, _ = l * -y + _ * v, m = f * -y + m * v, e = T, n = w, l = x, f = b), 1 !== C && (i *= C, a *= C, _ *= C, m *= C), 1 !== A && (e *= A, n *= A, l *= A, f *= A), 1 !== R && (t *= R, r *= R, h *= R, c *= R), d && (u -= d, s = i * u, o = a * u, u = _ * u + d), s = (T = (s += P.x) - (s |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + s : s, o = (T = (o += P.y) - (o |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + o : o, u = (T = (u += P.z) - (u |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + u : u, S[ye] = "matrix3d(" + [(0 | t * g) / g, (0 | r * g) / g, (0 | h * g) / g, (0 | c * g) / g, (0 | e * g) / g, (0 | n * g) / g, (0 | l * g) / g, (0 | f * g) / g, (0 | i * g) / g, (0 | a * g) / g, (0 | _ * g) / g, (0 | m * g) / g, s, o, u, O ? 1 + -u / O : 1].join(",") + ")"
                    },
                    Re = X.set2DTransformRatio = function (t) {
                        var e, i, s, r, n, a = this.data,
                            o = this.t,
                            h = o.style;
                        return a.rotationX || a.rotationY || a.z || a.force3D ? (this.setRatio = ke, void ke.call(this, t)) : void(a.rotation || a.skewX ? (e = a.rotation * M, i = e - a.skewX * M, s = 1e5, r = a.scaleX * s, n = a.scaleY * s, h[ye] = "matrix(" + (0 | Math.cos(e) * r) / s + "," + (0 | Math.sin(e) * r) / s + "," + (0 | Math.sin(i) * -n) / s + "," + (0 | Math.cos(i) * n) / s + "," + a.x + "," + a.y + ")") : h[ye] = "matrix(" + a.scaleX + ",0,0," + a.scaleY + "," + a.x + "," + a.y + ")")
                    };
                de("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType", {
                    parser: function (t, e, i, s, n, o, h) {
                        if (s._transform) return n;
                        var l, _, u, p, c, f, m, d = s._transform = Pe(t, r, !0, h.parseTransform),
                            g = t.style,
                            v = 1e-6,
                            y = ve.length,
                            T = h,
                            w = {};
                        if ("string" == typeof T.transform && ye) u = g.cssText, g[ye] = T.transform, g.display = "block", l = Pe(t, null, !1), g.cssText = u;
                        else if ("object" == typeof T) {
                            if (l = {
                                scaleX: se(null != T.scaleX ? T.scaleX : T.scale, d.scaleX),
                                scaleY: se(null != T.scaleY ? T.scaleY : T.scale, d.scaleY),
                                scaleZ: se(T.scaleZ, d.scaleZ),
                                x: se(T.x, d.x),
                                y: se(T.y, d.y),
                                z: se(T.z, d.z),
                                perspective: se(T.transformPerspective, d.perspective)
                            }, m = T.directionalRotation, null != m)
                                if ("object" == typeof m)
                                    for (u in m) T[u] = m[u];
                                else T.rotation = m;
                            l.rotation = re("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : "rotationZ" in T ? T.rotationZ : d.rotation, d.rotation, "rotation", w), xe && (l.rotationX = re("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : d.rotationX || 0, d.rotationX, "rotationX", w), l.rotationY = re("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : d.rotationY || 0, d.rotationY, "rotationY", w)), l.skewX = null == T.skewX ? d.skewX : re(T.skewX, d.skewX), l.skewY = null == T.skewY ? d.skewY : re(T.skewY, d.skewY), (_ = l.skewY - d.skewY) && (l.skewX += _, l.rotation += _)
                        }
                        for (xe && null != T.force3D && (d.force3D = T.force3D, f = !0), d.skewType = T.skewType || d.skewType || a.defaultSkewType, c = d.force3D || d.z || d.rotationX || d.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, c || null == T.scale || (l.scaleZ = 1); --y > -1;) i = ve[y], p = l[i] - d[i], (p > v || -v > p || null != E[i]) && (f = !0, n = new pe(d, i, d[i], p, n), i in w && (n.e = w[i]), n.xs0 = 0, n.plugin = o, s._overwriteProps.push(n.n));
                        return p = T.transformOrigin, (p || xe && c && d.zOrigin) && (ye ? (f = !0, i = we, p = (p || G(t, i, r, !1, "50% 50%")) + "", n = new pe(g, i, 0, 0, n, -1, "transformOrigin"), n.b = g[i], n.plugin = o, xe ? (u = d.zOrigin, p = p.split(" "), d.zOrigin = (p.length > 2 && (0 === u || "0px" !== p[2]) ? parseFloat(p[2]) : u) || 0, n.xs0 = n.e = g[i] = p[0] + " " + (p[1] || "50%") + " 0px", n = new pe(d, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = d.zOrigin) : n.xs0 = n.e = g[i] = p) : ee(p + "", d)), f && (s._transformType = c || 3 === this._transformType ? 3 : 2), n
                    },
                    prefix: !0
                }), de("boxShadow", {
                    defaultValue: "0px 0px 0px 0px #999",
                    prefix: !0,
                    color: !0,
                    multi: !0,
                    keyword: "inset"
                }), de("borderRadius", {
                    defaultValue: "0px",
                    parser: function (t, e, i, n, a) {
                        e = this.format(e);
                        var o, h, l, _, u, p, c, f, m, d, g, v, y, T, w, x, b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                            P = t.style;
                        for (m = parseFloat(t.offsetWidth), d = parseFloat(t.offsetHeight), o = e.split(" "), h = 0; b.length > h; h++) this.p.indexOf("border") && (b[h] = V(b[h])), u = _ = G(t, b[h], r, !1, "0px"), -1 !== u.indexOf(" ") && (_ = u.split(" "), u = _[0], _ = _[1]), p = l = o[h], c = parseFloat(u), v = u.substr((c + "").length), y = "=" === p.charAt(1), y ? (f = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), f *= parseFloat(p), g = p.substr((f + "").length - (0 > f ? 1 : 0)) || "") : (f = parseFloat(p), g = p.substr((f + "").length)), "" === g && (g = s[i] || v), g !== v && (T = $(t, "borderLeft", c, v), w = $(t, "borderTop", c, v), "%" === g ? (u = 100 * (T / m) + "%", _ = 100 * (w / d) + "%") : "em" === g ? (x = $(t, "borderLeft", 1, "em"), u = T / x + "em", _ = w / x + "em") : (u = T + "px", _ = w + "px"), y && (p = parseFloat(u) + f + g, l = parseFloat(_) + f + g)), a = ce(P, b[h], u + " " + _, p + " " + l, !1, "0px", a);
                        return a
                    },
                    prefix: !0,
                    formatter: le("0px 0px 0px 0px", !1, !0)
                }), de("backgroundPosition", {
                    defaultValue: "0 0",
                    parser: function (t, e, i, s, n, a) {
                        var o, h, l, _, u, p, c = "background-position",
                            m = r || W(t, null),
                            d = this.format((m ? f ? m.getPropertyValue(c + "-x") + " " + m.getPropertyValue(c + "-y") : m.getPropertyValue(c) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                            g = this.format(e);
                        if (-1 !== d.indexOf("%") != (-1 !== g.indexOf("%")) && (p = G(t, "backgroundImage").replace(k, ""), p && "none" !== p)) {
                            for (o = d.split(" "), h = g.split(" "), L.setAttribute("src", p), l = 2; --l > -1;) d = o[l], _ = -1 !== d.indexOf("%"), _ !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - L.width : t.offsetHeight - L.height, o[l] = _ ? parseFloat(d) / 100 * u + "px" : 100 * (parseFloat(d) / u) + "%");
                            d = o.join(" ")
                        }
                        return this.parseComplex(t.style, d, g, n, a)
                    },
                    formatter: ee
                }), de("backgroundSize", {
                    defaultValue: "0 0",
                    formatter: ee
                }), de("perspective", {
                    defaultValue: "0px",
                    prefix: !0
                }), de("perspectiveOrigin", {
                    defaultValue: "50% 50%",
                    prefix: !0
                }), de("transformStyle", {
                    prefix: !0
                }), de("backfaceVisibility", {
                    prefix: !0
                }), de("userSelect", {
                    prefix: !0
                }), de("margin", {
                    parser: _e("marginTop,marginRight,marginBottom,marginLeft")
                }), de("padding", {
                    parser: _e("paddingTop,paddingRight,paddingBottom,paddingLeft")
                }), de("clip", {
                    defaultValue: "rect(0px,0px,0px,0px)",
                    parser: function (t, e, i, s, n, a) {
                        var o, h, l;
                        return 9 > f ? (h = t.currentStyle, l = 8 > f ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(G(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a)
                    }
                }), de("textShadow", {
                    defaultValue: "0px 0px 0px #999",
                    color: !0,
                    multi: !0
                }), de("autoRound,strictUnits", {
                    parser: function (t, e, i, s, r) {
                        return r
                    }
                }), de("border", {
                    defaultValue: "0px solid #000",
                    parser: function (t, e, i, s, n, a) {
                        return this.parseComplex(t.style, this.format(G(t, "borderTopWidth", r, !1, "0px") + " " + G(t, "borderTopStyle", r, !1, "solid") + " " + G(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a)
                    },
                    color: !0,
                    formatter: function (t) {
                        var e = t.split(" ");
                        return e[0] + " " + (e[1] || "solid") + " " + (t.match(he) || ["#000"])[0]
                    }
                }), de("borderWidth", {
                    parser: _e("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                }), de("float,cssFloat,styleFloat", {
                    parser: function (t, e, i, s, r) {
                        var n = t.style,
                            a = "cssFloat" in n ? "cssFloat" : "styleFloat";
                        return new pe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e)
                    }
                });
                var Ae = function (t) {
                    var e, i = this.t,
                        s = i.filter || G(this.data, "filter"),
                        r = 0 | this.s + this.c * t;
                    100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !G(this.data, "filter")) : (i.filter = s.replace(x, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("opacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(T, "opacity=" + r))
                };
                de("opacity,alpha,autoAlpha", {
                    defaultValue: "1",
                    parser: function (t, e, i, s, n, a) {
                        var o = parseFloat(G(t, "opacity", r, !1, "1")),
                            h = t.style,
                            l = "autoAlpha" === i;
                        return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), l && 1 === o && "hidden" === G(t, "visibility", r) && 0 !== e && (o = 0), U ? n = new pe(h, "opacity", o, e - o, n) : (n = new pe(h, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = l ? 1 : 0, h.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Ae), l && (n = new pe(h, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n
                    }
                });
                var Ce = function (t, e) {
                        e && (t.removeProperty ? t.removeProperty(e.replace(P, "-$1").toLowerCase()) : t.removeAttribute(e))
                    },
                    Oe = function (t) {
                        if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                            this.t.className = 0 === t ? this.b : this.e;
                            for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Ce(i, e.p), e = e._next;
                            1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                        } else this.t.className !== this.e && (this.t.className = this.e)
                    };
                de("className", {
                    parser: function (t, e, s, n, a, o, h) {
                        var l, _, u, p, c, f = t.className,
                            m = t.style.cssText;
                        if (a = n._classNamePT = new pe(t, s, 0, 0, a, 2), a.setRatio = Oe, a.pr = -11, i = !0, a.b = f, _ = Q(t, r), u = t._gsClassPT) {
                            for (p = {}, c = u.data; c;) p[c.p] = 1, c = c._next;
                            u.setRatio(1)
                        }
                        return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.className = a.e, l = H(t, _, Q(t), h, p), t.className = f, a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = n.parse(t, l.difs, a, o)), a
                    }
                });
                var De = function (t) {
                    if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                        var e, i, s, r, n = this.t.style,
                            a = o.transform.parse;
                        if ("all" === this.e) n.cssText = "", r = !0;
                        else
                            for (e = this.e.split(","), s = e.length; --s > -1;) i = e[s], o[i] && (o[i].parse === a ? r = !0 : i = "transformOrigin" === i ? we : o[i].p), Ce(n, i);
                        r && (Ce(n, ye), this.t._gsTransform && delete this.t._gsTransform)
                    }
                };
                for (de("clearProps", {
                    parser: function (t, e, s, r, n) {
                        return n = new pe(t, s, 0, 0, n, 2), n.setRatio = De, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n
                    }
                }), h = "bezier,throwProps,physicsProps,physics2D".split(","), fe = h.length; fe--;) ge(h[fe]);
                h = a.prototype, h._firstPT = null, h._onInitTween = function (t, e, o) {
                    if (!t.nodeType) return !1;
                    this._target = t, this._tween = o, this._vars = e, l = e.autoRound, i = !1, s = e.suffixMap || a.suffixMap, r = W(t, ""), n = this._overwriteProps;
                    var h, p, f, m, d, g, v, y, T, x = t.style;
                    if (_ && "" === x.zIndex && (h = G(t, "zIndex", r), ("auto" === h || "" === h) && (x.zIndex = 0)), "string" == typeof e && (m = x.cssText, h = Q(t, r), x.cssText = m + ";" + e, h = H(t, h, Q(t)).difs, !U && w.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, x.cssText = m), this._firstPT = p = this.parse(t, e, null), this._transformType) {
                        for (T = 3 === this._transformType, ye ? u && (_ = !0, "" === x.zIndex && (v = G(t, "zIndex", r), ("auto" === v || "" === v) && (x.zIndex = 0)), c && (x.WebkitBackfaceVisibility = this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : x.zoom = 1, f = p; f && f._next;) f = f._next;
                        y = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, f), y.setRatio = T && xe ? ke : ye ? Re : Se, y.data = this._transform || Pe(t, r, !0), n.pop()
                    }
                    if (i) {
                        for (; p;) {
                            for (g = p._next, f = m; f && f.pr > p.pr;) f = f._next;
                            (p._prev = f ? f._prev : d) ? p._prev._next = p: m = p, (p._next = f) ? f._prev = p : d = p, p = g
                        }
                        this._firstPT = m
                    }
                    return !0
                }, h.parse = function (t, e, i, n) {
                    var a, h, _, u, p, c, f, m, d, g, v = t.style;
                    for (a in e) c = e[a], h = o[a], h ? i = h.parse(t, c, a, this, i, n, e) : (p = G(t, a, r) + "", d = "string" == typeof c, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || d && b.test(c) ? (d || (c = oe(c), c = (c.length > 3 ? "rgba(" : "rgb(") + c.join(",") + ")"), i = ce(v, a, p, c, !0, "transparent", i, 0, n)) : !d || -1 === c.indexOf(" ") && -1 === c.indexOf(",") ? (_ = parseFloat(p), f = _ || 0 === _ ? p.substr((_ + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (_ = te(t, a, r), f = "px") : "left" === a || "top" === a ? (_ = Z(t, a, r), f = "px") : (_ = "opacity" !== a ? 0 : 1, f = "")), g = d && "=" === c.charAt(1), g ? (u = parseInt(c.charAt(0) + "1", 10), c = c.substr(2), u *= parseFloat(c), m = c.replace(y, "")) : (u = parseFloat(c), m = d ? c.substr((u + "").length) || "" : ""), "" === m && (m = a in s ? s[a] : f), c = u || 0 === u ? (g ? u + _ : u) + m : e[a], f !== m && "" !== m && (u || 0 === u) && (_ || 0 === _) && (_ = $(t, a, _, f), "%" === m ? (_ /= $(t, a, 100, "%") / 100, e.strictUnits !== !0 && (p = _ + "%")) : "em" === m ? _ /= $(t, a, 1, "em") : (u = $(t, a, u, m), m = "px"), g && (u || 0 === u) && (c = u + _ + m)), g && (u += _), !_ && 0 !== _ || !u && 0 !== u ? void 0 !== v[a] && (c || "NaN" != c + "" && null != c) ? (i = new pe(v, a, u || _ || 0, 0, i, -1, a, !1, 0, p, c), i.xs0 = "none" !== c || "display" !== a && -1 === a.indexOf("Style") ? c : p) : j("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, _, u - _, i, 0, a, l !== !1 && ("px" === m || "zIndex" === a), 0, p, c), i.xs0 = m)) : i = ce(v, a, p, c, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
                    return i
                }, h.setRatio = function (t) {
                    var e, i, s, r = this._firstPT,
                        n = 1e-6;
                    if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                        if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                            for (; r;) {
                                if (e = r.c * t + r.s, r.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : n > e && e > -n && (e = 0), r.type)
                                    if (1 === r.type)
                                        if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                        else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                else {
                                    for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++) i += r["xn" + s] + r["xs" + (s + 1)];
                                    r.t[r.p] = i
                                } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                                else r.t[r.p] = e + r.xs0;
                                r = r._next
                            } else
                                for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                        else
                            for (; r;) 2 !== r.type ? r.t[r.p] = r.e : r.setRatio(t), r = r._next
                }, h._enableTransforms = function (t) {
                    this._transformType = t || 3 === this._transformType ? 3 : 2, this._transform = this._transform || Pe(this._target, r, !0)
                }, h._linkCSSP = function (t, e, i, s) {
                    return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
                }, h._kill = function (e) {
                    var i, s, r, n = e;
                    if (e.autoAlpha || e.alpha) {
                        n = {};
                        for (s in e) n[s] = e[s];
                        n.opacity = 1, n.autoAlpha && (n.visibility = 1)
                    }
                    return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n)
                };
                var Me = function (t, e, i) {
                    var s, r, n, a;
                    if (t.slice)
                        for (r = t.length; --r > -1;) Me(t[r], e, i);
                    else
                        for (s = t.childNodes, r = s.length; --r > -1;) n = s[r], a = n.type, n.style && (e.push(Q(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || Me(n, e, i)
                };
                return a.cascadeTo = function (t, i, s) {
                    var r, n, a, o = e.to(t, i, s),
                        h = [o],
                        l = [],
                        _ = [],
                        u = [],
                        p = e._internals.reservedProps;
                    for (t = o._targets || o.target, Me(t, l, u), o.render(i, !0), Me(t, _), o.render(0, !0), o._enabled(!0), r = u.length; --r > -1;)
                        if (n = H(u[r], l[r], _[r]), n.firstMPT) {
                            n = n.difs;
                            for (a in s) p[a] && (n[a] = s[a]);
                            h.push(e.to(u[r], i, n))
                        }
                    return h
                }, t.activate([a]), a
            }, !0),
            function () {
                var t = window._gsDefine.plugin({
                        propName: "roundProps",
                        priority: -1,
                        API: 2,
                        init: function (t, e, i) {
                            return this._tween = i, !0
                        }
                    }),
                    e = t.prototype;
                e._onInitAllProps = function () {
                    for (var t, e, i, s = this._tween, r = s.vars.roundProps instanceof Array ? s.vars.roundProps : s.vars.roundProps.split(","), n = r.length, a = {}, o = s._propLookup.roundProps; --n > -1;) a[r[n]] = 1;
                    for (n = r.length; --n > -1;)
                        for (t = r[n], e = s._firstPT; e;) i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : s._firstPT === e && (s._firstPT = i), e._next = e._prev = null, s._propLookup[t] = o), e = i;
                    return !1
                }, e._add = function (t, e, i, s) {
                    this._addTween(t, e, i, i + s, e, !0), this._overwriteProps.push(e)
                }
            }(), window._gsDefine.plugin({
                propName: "attr",
                API: 2,
                version: "0.2.0",
                init: function (t, e) {
                    var i;
                    if ("function" != typeof t.setAttribute) return !1;
                    this._target = t, this._proxy = {};
                    for (i in e) this._addTween(this._proxy, i, parseFloat(t.getAttribute(i)), e[i], i) && this._overwriteProps.push(i);
                    return !0
                },
                set: function (t) {
                    this._super.setRatio.call(this, t);
                    for (var e, i = this._overwriteProps, s = i.length; --s > -1;) e = i[s], this._target.setAttribute(e, this._proxy[e] + "")
                }
            }), window._gsDefine.plugin({
                propName: "directionalRotation",
                API: 2,
                version: "0.2.0",
                init: function (t, e) {
                    "object" != typeof e && (e = {
                        rotation: e
                    }), this.finals = {};
                    var i, s, r, n, a, o, h = e.useRadians === !0 ? 2 * Math.PI : 360,
                        l = 1e-6;
                    for (i in e) "useRadians" !== i && (o = (e[i] + "").split("_"), s = o[0], r = parseFloat("function" != typeof t[i] ? t[i] : t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), n = this.finals[i] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, a = n - r, o.length && (s = o.join("_"), -1 !== s.indexOf("short") && (a %= h, a !== a % (h / 2) && (a = 0 > a ? a + h : a - h)), -1 !== s.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * h) % h - (0 | a / h) * h : -1 !== s.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * h) % h - (0 | a / h) * h)), (a > l || -l > a) && (this._addTween(t, i, r, r + a, i), this._overwriteProps.push(i)));
                    return !0
                },
                set: function (t) {
                    var e;
                    if (1 !== t) this._super.setRatio.call(this, t);
                    else
                        for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
                }
            })._autoCSS = !0, window._gsDefine("easing.Back", ["easing.Ease"], function (t) {
                var e, i, s, r = window.GreenSockGlobals || window,
                    n = r.com.greensock,
                    a = 2 * Math.PI,
                    o = Math.PI / 2,
                    h = n._class,
                    l = function (e, i) {
                        var s = h("easing." + e, function () {}, !0),
                            r = s.prototype = new t;
                        return r.constructor = s, r.getRatio = i, s
                    },
                    _ = t.register || function () {},
                    u = function (t, e, i, s) {
                        var r = h("easing." + t, {
                            easeOut: new e,
                            easeIn: new i,
                            easeInOut: new s
                        }, !0);
                        return _(r, t), r
                    },
                    p = function (t, e, i) {
                        this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                    },
                    c = function (e, i) {
                        var s = h("easing." + e, function (t) {
                                this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                            }, !0),
                            r = s.prototype = new t;
                        return r.constructor = s, r.getRatio = i, r.config = function (t) {
                            return new s(t)
                        }, s
                    },
                    f = u("Back", c("BackOut", function (t) {
                        return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                    }), c("BackIn", function (t) {
                        return t * t * ((this._p1 + 1) * t - this._p1)
                    }), c("BackInOut", function (t) {
                        return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                    })),
                    m = h("easing.SlowMo", function (t, e, i) {
                        e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
                    }, !0),
                    d = m.prototype = new t;
                return d.constructor = m, d.getRatio = function (t) {
                    var e = t + (.5 - t) * this._p;
                    return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
                }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) {
                    return new m(t, e, i)
                }, e = h("easing.SteppedEase", function (t) {
                    t = t || 1, this._p1 = 1 / t, this._p2 = t + 1
                }, !0), d = e.prototype = new t, d.constructor = e, d.getRatio = function (t) {
                    return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1
                }, d.config = e.config = function (t) {
                    return new e(t)
                }, i = h("easing.RoughEase", function (e) {
                    e = e || {};
                    for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), c = u, f = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --c > -1;) i = f ? Math.random() : 1 / u * c, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), f ? s += Math.random() * r - .5 * r : c % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = {
                        x: i,
                        y: s
                    };
                    for (l.sort(function (t, e) {
                        return t.x - e.x
                    }), o = new p(1, 1, null), c = u; --c > -1;) a = l[c], o = new p(a.x, a.y, o);
                    this._prev = new p(0, 0, 0 !== o.t ? o : o.next)
                }, !0), d = i.prototype = new t, d.constructor = i, d.getRatio = function (t) {
                    var e = this._prev;
                    if (t > e.t) {
                        for (; e.next && t >= e.t;) e = e.next;
                        e = e.prev
                    } else
                        for (; e.prev && e.t >= t;) e = e.prev;
                    return this._prev = e, e.v + (t - e.t) / e.gap * e.c
                }, d.config = function (t) {
                    return new i(t)
                }, i.ease = new i, u("Bounce", l("BounceOut", function (t) {
                    return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                }), l("BounceIn", function (t) {
                    return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
                }), l("BounceInOut", function (t) {
                    var e = .5 > t;
                    return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
                })), u("Circ", l("CircOut", function (t) {
                    return Math.sqrt(1 - (t -= 1) * t)
                }), l("CircIn", function (t) {
                    return -(Math.sqrt(1 - t * t) - 1)
                }), l("CircInOut", function (t) {
                    return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                })), s = function (e, i, s) {
                    var r = h("easing." + e, function (t, e) {
                            this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0)
                        }, !0),
                        n = r.prototype = new t;
                    return n.constructor = r, n.getRatio = i, n.config = function (t, e) {
                        return new r(t, e)
                    }, r
                }, u("Elastic", s("ElasticOut", function (t) {
                    return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1
                }, .3), s("ElasticIn", function (t) {
                    return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2))
                }, .3), s("ElasticInOut", function (t) {
                    return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1
                }, .45)), u("Expo", l("ExpoOut", function (t) {
                    return 1 - Math.pow(2, -10 * t)
                }), l("ExpoIn", function (t) {
                    return Math.pow(2, 10 * (t - 1)) - .001
                }), l("ExpoInOut", function (t) {
                    return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                })), u("Sine", l("SineOut", function (t) {
                    return Math.sin(t * o)
                }), l("SineIn", function (t) {
                    return -Math.cos(t * o) + 1
                }), l("SineInOut", function (t) {
                    return -.5 * (Math.cos(Math.PI * t) - 1)
                })), h("easing.EaseLookup", {
                    find: function (e) {
                        return t.map[e]
                    }
                }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), f
            }, !0)
    }),
    function (t) {
        "use strict";
        var e = t.GreenSockGlobals || t;
        if (!e.TweenLite) {
            var i, s, r, n, a, o = function (t) {
                    var i, s = t.split("."),
                        r = e;
                    for (i = 0; s.length > i; i++) r[s[i]] = r = r[s[i]] || {};
                    return r
                },
                h = o("com.greensock"),
                l = 1e-10,
                _ = [].slice,
                u = function () {},
                p = function () {
                    var t = Object.prototype.toString,
                        e = t.call([]);
                    return function (i) {
                        return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                    }
                }(),
                c = {},
                f = function (i, s, r, n) {
                    this.sc = c[i] ? c[i].sc : [], c[i] = this, this.gsClass = null, this.func = r;
                    var a = [];
                    this.check = function (h) {
                        for (var l, _, u, p, m = s.length, d = m; --m > -1;)(l = c[s[m]] || new f(s[m], [])).gsClass ? (a[m] = l.gsClass, d--) : h && l.sc.push(this);
                        if (0 === d && r)
                            for (_ = ("com.greensock." + i).split("."), u = _.pop(), p = o(_.join("."))[u] = this.gsClass = r.apply(r, a), n && (e[u] = p, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + i.split(".").join("/"), [], function () {
                                return p
                            }) : "undefined" != typeof module && module.exports && (module.exports = p)), m = 0; this.sc.length > m; m++) this.sc[m].check()
                    }, this.check(!0)
                },
                m = t._gsDefine = function (t, e, i, s) {
                    return new f(t, e, i, s)
                },
                d = h._class = function (t, e, i) {
                    return e = e || function () {}, m(t, [], function () {
                        return e
                    }, i), e
                };
            m.globals = e;
            var g = [0, 0, 1, 1],
                v = [],
                y = d("easing.Ease", function (t, e, i, s) {
                    this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? g.concat(e) : g
                }, !0),
                T = y.map = {},
                w = y.register = function (t, e, i, s) {
                    for (var r, n, a, o, l = e.split(","), _ = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;)
                        for (n = l[_], r = s ? d("easing." + n, null, !0) : h.easing[n] || {}, a = u.length; --a > -1;) o = u[a], T[n + "." + o] = T[o + n] = r[o] = t.getRatio ? t : t[o] || new t
                };
            for (r = y.prototype, r._calcEnd = !1, r.getRatio = function (t) {
                if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                var e = this._type,
                    i = this._power,
                    s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
                return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2
            }, i = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], s = i.length; --s > -1;) r = i[s] + ",Power" + s, w(new y(null, null, 1, s), r, "easeOut", !0), w(new y(null, null, 2, s), r, "easeIn" + (0 === s ? ",easeNone" : "")), w(new y(null, null, 3, s), r, "easeInOut");
            T.linear = h.easing.Linear.easeIn, T.swing = h.easing.Quad.easeInOut;
            var x = d("events.EventDispatcher", function (t) {
                this._listeners = {}, this._eventTarget = t || this
            });
            r = x.prototype, r.addEventListener = function (t, e, i, s, r) {
                r = r || 0;
                var o, h, l = this._listeners[t],
                    _ = 0;
                for (null == l && (this._listeners[t] = l = []), h = l.length; --h > -1;) o = l[h], o.c === e && o.s === i ? l.splice(h, 1) : 0 === _ && r > o.pr && (_ = h + 1);
                l.splice(_, 0, {
                    c: e,
                    s: i,
                    up: s,
                    pr: r
                }), this !== n || a || n.wake()
            }, r.removeEventListener = function (t, e) {
                var i, s = this._listeners[t];
                if (s)
                    for (i = s.length; --i > -1;)
                        if (s[i].c === e) return void s.splice(i, 1)
            }, r.dispatchEvent = function (t) {
                var e, i, s, r = this._listeners[t];
                if (r)
                    for (e = r.length, i = this._eventTarget; --e > -1;) s = r[e], s.up ? s.c.call(s.s || i, {
                        type: t,
                        target: i
                    }) : s.c.call(s.s || i)
            };
            var b = t.requestAnimationFrame,
                P = t.cancelAnimationFrame,
                S = Date.now || function () {
                    return (new Date).getTime()
                },
                k = S();
            for (i = ["ms", "moz", "webkit", "o"], s = i.length; --s > -1 && !b;) b = t[i[s] + "RequestAnimationFrame"], P = t[i[s] + "CancelAnimationFrame"] || t[i[s] + "CancelRequestAnimationFrame"];
            d("Ticker", function (t, e) {
                var i, s, r, o, h, l = this,
                    _ = S(),
                    p = e !== !1 && b,
                    c = function (t) {
                        k = S(), l.time = (k - _) / 1e3;
                        var e, n = l.time - h;
                        (!i || n > 0 || t === !0) && (l.frame++, h += n + (n >= o ? .004 : o - n), e = !0), t !== !0 && (r = s(c)), e && l.dispatchEvent("tick")
                    };
                x.call(l), l.time = l.frame = 0, l.tick = function () {
                    c(!0)
                }, l.sleep = function () {
                    null != r && (p && P ? P(r) : clearTimeout(r), s = u, r = null, l === n && (a = !1))
                }, l.wake = function () {
                    null !== r && l.sleep(), s = 0 === i ? u : p && b ? b : function (t) {
                        return setTimeout(t, 0 | 1e3 * (h - l.time) + 1)
                    }, l === n && (a = !0), c(2)
                }, l.fps = function (t) {
                    return arguments.length ? (i = t, o = 1 / (i || 60), h = this.time + o, void l.wake()) : i
                }, l.useRAF = function (t) {
                    return arguments.length ? (l.sleep(), p = t, void l.fps(i)) : p
                }, l.fps(t), setTimeout(function () {
                    p && (!r || 5 > l.frame) && l.useRAF(!1)
                }, 1500)
            }), r = h.Ticker.prototype = new h.events.EventDispatcher, r.constructor = h.Ticker;
            var R = d("core.Animation", function (t, e) {
                if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, U) {
                    a || n.wake();
                    var i = this.vars.useFrames ? z : U;
                    i.add(this, i._time), this.vars.paused && this.paused(!0)
                }
            });
            n = R.ticker = new h.Ticker, r = R.prototype, r._dirty = r._gc = r._initted = r._paused = !1, r._totalTime = r._time = 0, r._rawPrevTime = -1, r._next = r._last = r._onUpdate = r._timeline = r.timeline = null, r._paused = !1;
            var A = function () {
                a && S() - k > 2e3 && n.wake(), setTimeout(A, 2e3)
            };
            A(), r.play = function (t, e) {
                return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
            }, r.pause = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!0)
            }, r.resume = function (t, e) {
                return null != t && this.seek(t, e), this.paused(!1)
            }, r.seek = function (t, e) {
                return this.totalTime(Number(t), e !== !1)
            }, r.restart = function (t, e) {
                return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
            }, r.reverse = function (t, e) {
                return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
            }, r.render = function () {}, r.invalidate = function () {
                return this
            }, r.isActive = function () {
                var t, e = this._timeline,
                    i = this._startTime;
                return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && i + this.totalDuration() / this._timeScale > t
            }, r._enabled = function (t, e) {
                return a || n.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
            }, r._kill = function () {
                return this._enabled(!1, !1)
            }, r.kill = function (t, e) {
                return this._kill(t, e), this
            }, r._uncache = function (t) {
                for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                return this
            }, r._swapSelfInParams = function (t) {
                for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                return i
            }, r.eventCallback = function (t, e, i, s) {
                if ("on" === (t || "").substr(0, 2)) {
                    var r = this.vars;
                    if (1 === arguments.length) return r[t];
                    null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = p(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e)
                }
                return this
            }, r.delay = function (t) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
            }, r.duration = function (t) {
                return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, r.totalDuration = function (t) {
                return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
            }, r.time = function (t, e) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
            }, r.totalTime = function (t, e, i) {
                if (a || n.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var s = this._totalDuration,
                            r = this._timeline;
                        if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? s - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                            for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                    }
                    this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && this.render(t, e, !1)
                }
                return this
            }, r.progress = r.totalProgress = function (t, e) {
                return arguments.length ? this.totalTime(this.duration() * t, e) : this._time / this.duration()
            }, r.startTime = function (t) {
                return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
            }, r.timeScale = function (t) {
                if (!arguments.length) return this._timeScale;
                if (t = t || l, this._timeline && this._timeline.smoothChildTiming) {
                    var e = this._pauseTime,
                        i = e || 0 === e ? e : this._timeline.totalTime();
                    this._startTime = i - (i - this._startTime) * this._timeScale / t
                }
                return this._timeScale = t, this._uncache(!1)
            }, r.reversed = function (t) {
                return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, r.paused = function (t) {
                if (!arguments.length) return this._paused;
                if (t != this._paused && this._timeline) {
                    a || t || n.wake();
                    var e = this._timeline,
                        i = e.rawTime(),
                        s = i - this._pauseTime;
                    !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = this.isActive(), !t && 0 !== s && this._initted && this.duration() && this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0)
                }
                return this._gc && !t && this._enabled(!0, !1), this
            };
            var C = d("core.SimpleTimeline", function (t) {
                R.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            r = C.prototype = new R, r.constructor = C, r.kill()._gc = !1, r._first = r._last = null, r._sortChildren = !1, r.add = r.insert = function (t, e) {
                var i, s;
                if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren)
                    for (s = t._startTime; i && i._startTime > s;) i = i._prev;
                return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._timeline && this._uncache(!0), this
            }, r._remove = function (t, e) {
                return t.timeline === this && (e || t._enabled(!1, !0), t.timeline = null, t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), this._timeline && this._uncache(!0)), this
            }, r.render = function (t, e, i) {
                var s, r = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = t; r;) s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s
            }, r.rawTime = function () {
                return a || n.wake(), this._totalTime
            };
            var O = d("TweenLite", function (e, i, s) {
                    if (R.call(this, i, s), this.render = O.prototype.render, null == e) throw "Cannot tween a null target.";
                    this.target = e = "string" != typeof e ? e : O.selector(e) || e;
                    var r, n, a, o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                        h = this.vars.overwrite;
                    if (this._overwrite = h = null == h ? X[O.defaultOverwrite] : "number" == typeof h ? h >> 0 : X[h], (o || e instanceof Array || e.push && p(e)) && "number" != typeof e[0])
                        for (this._targets = a = _.call(e, 0), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++) n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(_.call(n, 0))) : (this._siblings[r] = Y(n, this, !1), 1 === h && this._siblings[r].length > 1 && j(n, this, null, 1, this._siblings[r])) : (n = a[r--] = O.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1);
                    else this._propLookup = {}, this._siblings = Y(e, this, !1), 1 === h && this._siblings.length > 1 && j(e, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && this.render(-this._delay, !1, !0)
                }, !0),
                D = function (e) {
                    return e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
                },
                M = function (t, e) {
                    var i, s = {};
                    for (i in t) L[i] || i in e && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!E[i] || E[i] && E[i]._autoCSS) || (s[i] = t[i], delete t[i]);
                    t.css = s
                };
            r = O.prototype = new R, r.constructor = O, r.kill()._gc = !1, r.ratio = 0, r._firstPT = r._targets = r._overwrittenProps = r._startAt = null, r._notifyPluginsOfEnabled = !1, O.version = "1.11.6", O.defaultEase = r._ease = new y(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = n, O.autoSleep = !0, O.selector = t.$ || t.jQuery || function (e) {
                return t.$ ? (O.selector = t.$, t.$(e)) : t.document ? t.document.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e
            };
            var I = O._internals = {
                    isArray: p,
                    isSelector: D
                },
                E = O._plugins = {},
                N = O._tweenLookup = {},
                F = 0,
                L = I.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1
                },
                X = {
                    none: 0,
                    all: 1,
                    auto: 2,
                    concurrent: 3,
                    allOnStart: 4,
                    preexisting: 5,
                    "true": 1,
                    "false": 0
                },
                z = R._rootFramesTimeline = new C,
                U = R._rootTimeline = new C;
            U._startTime = n.time, z._startTime = n.frame, U._active = z._active = !0, R._updateRoot = function () {
                if (U.render((n.time - U._startTime) * U._timeScale, !1, !1), z.render((n.frame - z._startTime) * z._timeScale, !1, !1), !(n.frame % 120)) {
                    var t, e, i;
                    for (i in N) {
                        for (e = N[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                        0 === e.length && delete N[i]
                    }
                    if (i = U._first, (!i || i._paused) && O.autoSleep && !z._first && 1 === n._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || n.sleep()
                    }
                }
            }, n.addEventListener("tick", R._updateRoot);
            var Y = function (t, e, i) {
                    var s, r, n = t._gsTweenID;
                    if (N[n || (t._gsTweenID = n = "t" + F++)] || (N[n] = {
                        target: t,
                        tweens: []
                    }), e && (s = N[n].tweens, s[r = s.length] = e, i))
                        for (; --r > -1;) s[r] === e && s.splice(r, 1);
                    return N[n].tweens
                },
                j = function (t, e, i, s, r) {
                    var n, a, o, h;
                    if (1 === s || s >= 4) {
                        for (h = r.length, n = 0; h > n; n++)
                            if ((o = r[n]) !== e) o._gc || o._enabled(!1, !1) && (a = !0);
                            else if (5 === s) break;
                        return a
                    }
                    var _, u = e._startTime + l,
                        p = [],
                        c = 0,
                        f = 0 === e._duration;
                    for (n = r.length; --n > -1;)(o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (_ = _ || B(e, 0, f), 0 === B(o, _, f) && (p[c++] = o)) : u >= o._startTime && o._startTime + o.totalDuration() / o._timeScale > u && ((f || !o._initted) && 2e-10 >= u - o._startTime || (p[c++] = o)));
                    for (n = c; --n > -1;) o = p[n], 2 === s && o._kill(i, t) && (a = !0), (2 !== s || !o._firstPT && o._initted) && o._enabled(!1, !1) && (a = !0);
                    return a
                },
                B = function (t, e, i) {
                    for (var s = t._timeline, r = s._timeScale, n = t._startTime; s._timeline;) {
                        if (n += s._startTime, r *= s._timeScale, s._paused) return -100;
                        s = s._timeline
                    }
                    return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * l > n - e ? l : (n += t.totalDuration() / t._timeScale / r) > e + l ? 0 : n - e - l
                };
            r._init = function () {
                var t, e, i, s, r = this.vars,
                    n = this._overwrittenProps,
                    a = this._duration,
                    o = r.immediateRender,
                    h = r.ease;
                if (r.startAt) {
                    if (this._startAt && this._startAt.render(-1, !0), r.startAt.overwrite = 0, r.startAt.immediateRender = !0, this._startAt = O.to(this.target, 0, r.startAt), o)
                        if (this._time > 0) this._startAt = null;
                        else if (0 !== a) return
                } else if (r.runBackwards && 0 !== a)
                    if (this._startAt) this._startAt.render(-1, !0), this._startAt = null;
                    else {
                        i = {};
                        for (s in r) L[s] && "autoCSS" !== s || (i[s] = r[s]);
                        if (i.overwrite = 0, i.data = "isFromStart", this._startAt = O.to(this.target, 0, i), r.immediateRender) {
                            if (0 === this._time) return
                        } else this._startAt.render(-1, !0)
                    }
                if (this._ease = h ? h instanceof y ? r.easeParams instanceof Array ? h.config.apply(h, r.easeParams) : h : "function" == typeof h ? new y(h, r.easeParams) : T[h] || O.defaultEase : O.defaultEase, this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                    for (t = this._targets.length; --t > -1;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], n ? n[t] : null) && (e = !0);
                else e = this._initProps(this.target, this._propLookup, this._siblings, n); if (e && O._onPluginEvent("_onInitAllProps", this), n && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards)
                    for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = r.onUpdate, this._initted = !0
            }, r._initProps = function (e, i, s, r) {
                var n, a, o, h, l, _;
                if (null == e) return !1;
                this.vars.css || e.style && e !== t && e.nodeType && E.css && this.vars.autoCSS !== !1 && M(this.vars, e);
                for (n in this.vars) {
                    if (_ = this.vars[n], L[n]) _ && (_ instanceof Array || _.push && p(_)) && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this));
                    else if (E[n] && (h = new E[n])._onInitTween(e, this.vars[n], this)) {
                        for (this._firstPT = l = {
                            _next: this._firstPT,
                            t: h,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: !0,
                            n: n,
                            pg: !0,
                            pr: h._priority
                        }, a = h._overwriteProps.length; --a > -1;) i[h._overwriteProps[a]] = this._firstPT;
                        (h._priority || h._onInitAllProps) && (o = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0)
                    } else this._firstPT = i[n] = l = {
                        _next: this._firstPT,
                        t: e,
                        p: n,
                        f: "function" == typeof e[n],
                        n: n,
                        pg: !1,
                        pr: 0
                    }, l.s = l.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), l.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - l.s || 0;
                    l && l._next && (l._next._prev = l)
                }
                return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && j(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : o
            }, r.render = function (t, e, i) {
                var s, r, n, a, o = this._time,
                    h = this._duration;
                if (t >= h) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete"), 0 === h && (a = this._rawPrevTime, this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > a || a === l) && a !== t && (i = !0, a > l && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || this._rawPrevTime === t ? t : l);
                else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && this._rawPrevTime > 0 && this._rawPrevTime !== l) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === h && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = a = !e || t || this._rawPrevTime === t ? t : l)) : this._initted || (i = !0);
                else if (this._totalTime = this._time = t, this._easeType) {
                    var _ = t / h,
                        u = this._easeType,
                        p = this._easePower;
                    (1 === u || 3 === u && _ >= .5) && (_ = 1 - _), 3 === u && (_ *= 2), 1 === p ? _ *= _ : 2 === p ? _ *= _ * _ : 3 === p ? _ *= _ * _ * _ : 4 === p && (_ *= _ * _ * _ * _), this.ratio = 1 === u ? 1 - _ : 2 === u ? _ : .5 > t / h ? _ / 2 : 1 - _ / 2
                } else this.ratio = this._ease.getRatio(t / h); if (this._time !== o || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        this._time && !s ? this.ratio = this._ease.getRatio(this._time / h) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === h) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || v))), n = this._firstPT; n;) n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next;
                    this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._time !== o || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || v)), r && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || v), 0 === h && this._rawPrevTime === l && a !== l && (this._rawPrevTime = 0)))
                }
            }, r._kill = function (t, e) {
                if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._enabled(!1, !1);
                e = "string" != typeof e ? e || this._targets || this.target : O.selector(e) || e;
                var i, s, r, n, a, o, h, l;
                if ((p(e) || D(e)) && "number" != typeof e[0])
                    for (i = e.length; --i > -1;) this._kill(t, e[i]) && (o = !0);
                else {
                    if (this._targets) {
                        for (i = this._targets.length; --i > -1;)
                            if (e === this._targets[i]) {
                                a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all";
                                break
                            }
                    } else {
                        if (e !== this.target) return !1;
                        a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                    } if (a) {
                        h = t || a, l = t !== s && "all" !== s && t !== a && ("object" != typeof t || !t._tempKill);
                        for (r in h)(n = a[r]) && (n.pg && n.t._kill(h) && (o = !0), n.pg && 0 !== n.t._overwriteProps.length || (n._prev ? n._prev._next = n._next : n === this._firstPT && (this._firstPT = n._next), n._next && (n._next._prev = n._prev), n._next = n._prev = null), delete a[r]), l && (s[r] = 1);
                        !this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return o
            }, r.invalidate = function () {
                return this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = !1, this._propLookup = this._targets ? {} : [], this
            }, r._enabled = function (t, e) {
                if (a || n.wake(), t && this._gc) {
                    var i, s = this._targets;
                    if (s)
                        for (i = s.length; --i > -1;) this._siblings[i] = Y(s[i], this, !0);
                    else this._siblings = Y(this.target, this, !0)
                }
                return R.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? O._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1
            }, O.to = function (t, e, i) {
                return new O(t, e, i)
            }, O.from = function (t, e, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new O(t, e, i)
            }, O.fromTo = function (t, e, i, s) {
                return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new O(t, e, s)
            }, O.delayedCall = function (t, e, i, s, r) {
                return new O(e, 0, {
                    delay: t,
                    onComplete: e,
                    onCompleteParams: i,
                    onCompleteScope: s,
                    onReverseComplete: e,
                    onReverseCompleteParams: i,
                    onReverseCompleteScope: s,
                    immediateRender: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, O.set = function (t, e) {
                return new O(t, 0, e)
            }, O.getTweensOf = function (t, e) {
                if (null == t) return [];
                t = "string" != typeof t ? t : O.selector(t) || t;
                var i, s, r, n;
                if ((p(t) || D(t)) && "number" != typeof t[0]) {
                    for (i = t.length, s = []; --i > -1;) s = s.concat(O.getTweensOf(t[i], e));
                    for (i = s.length; --i > -1;)
                        for (n = s[i], r = i; --r > -1;) n === s[r] && s.splice(i, 1)
                } else
                    for (s = Y(t).concat(), i = s.length; --i > -1;)(s[i]._gc || e && !s[i].isActive()) && s.splice(i, 1);
                return s
            }, O.killTweensOf = O.killDelayedCallsTo = function (t, e, i) {
                "object" == typeof e && (i = e, e = !1);
                for (var s = O.getTweensOf(t, e), r = s.length; --r > -1;) s[r]._kill(i, t)
            };
            var q = d("plugins.TweenPlugin", function (t, e) {
                this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = q.prototype
            }, !0);
            if (r = q.prototype, q.version = "1.10.1", q.API = 2, r._firstPT = null, r._addTween = function (t, e, i, s, r, n) {
                var a, o;
                return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = {
                    _next: this._firstPT,
                    t: t,
                    p: e,
                    s: i,
                    c: a,
                    f: "function" == typeof t[e],
                    n: r || e,
                    r: n
                }, o._next && (o._next._prev = o), o) : void 0
            }, r.setRatio = function (t) {
                for (var e, i = this._firstPT, s = 1e-6; i;) e = i.c * t + i.s, i.r ? e = 0 | e + (e > 0 ? .5 : -.5) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next
            }, r._kill = function (t) {
                var e, i = this._overwriteProps,
                    s = this._firstPT;
                if (null != t[this._propName]) this._overwriteProps = [];
                else
                    for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                for (; s;) null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next;
                return !1
            }, r._roundProps = function (t, e) {
                for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next
            }, O._onPluginEvent = function (t, e) {
                var i, s, r, n, a, o = e._firstPT;
                if ("_onInitAllProps" === t) {
                    for (; o;) {
                        for (a = o._next, s = r; s && s.pr > o.pr;) s = s._next;
                        (o._prev = s ? s._prev : n) ? o._prev._next = o: r = o, (o._next = s) ? s._prev = o : n = o, o = a
                    }
                    o = e._firstPT = r
                }
                for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
                return i
            }, q.activate = function (t) {
                for (var e = t.length; --e > -1;) t[e].API === q.API && (E[(new t[e])._propName] = t[e]);
                return !0
            }, m.plugin = function (t) {
                if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                var e, i = t.propName,
                    s = t.priority || 0,
                    r = t.overwriteProps,
                    n = {
                        init: "_onInitTween",
                        set: "setRatio",
                        kill: "_kill",
                        round: "_roundProps",
                        initAll: "_onInitAllProps"
                    },
                    a = d("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
                        q.call(this, i, s), this._overwriteProps = r || []
                    }, t.global === !0),
                    o = a.prototype = new q(i);
                o.constructor = a, a.API = t.API;
                for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]);
                return a.version = t.version, q.activate([a]), a
            }, i = t._gsQueue) {
                for (s = 0; i.length > s; s++) i[s]();
                for (r in c) c[r].func || t.console.log("GSAP encountered missing dependency: com.greensock." + r)
            }
            a = !1
        }
    }(window),
    /*
colpick Color Picker
Copyright 2013 Jose Vargas. Licensed under GPL license. Based on Stefan Petre's Color Picker www.eyecon.ro, dual licensed under the MIT and GPL licenses

For usage and examples: colpick.com/plugin
 */
    function ($) {
        var colpick = function () {
                var tpl = '<div class="colpick"><div class="colpick_color"><div class="colpick_color_overlay1"><div class="colpick_color_overlay2"><div class="colpick_selector_outer"></div></div></div></div><div class="colpick_hue"><div class="colpick_hue_arrs"><div class="colpick_hue_rarr"><span></span><span></span><span></span></div></div></div><div class="colpick_new_color"></div><div class="colpick_current_color"></div><div class="colpick_hex_field"><input type="text" maxlength="6" size="6" /></div><div class="colpick_rgb_r colpick_field"><input type="text" maxlength="3" size="3" /></div><div class="colpick_rgb_g colpick_field"><input type="text" maxlength="3" size="3" /></div><div class="colpick_rgb_b colpick_field"><input type="text" maxlength="3" size="3" /></div><div class="colpick_hsb_h colpick_field"><input type="text" maxlength="3" size="3" /></div><div class="colpick_hsb_s colpick_field"><input type="text" maxlength="3" size="3" /></div><div class="colpick_hsb_b colpick_field"><input type="text" maxlength="3" size="3" /></div></div>',
                    defaults = {
                        showEvent: "click",
                        onShow: function () {},
                        onBeforeShow: function () {},
                        onHide: function () {},
                        onChange: function () {},
                        onSubmit: function () {},
                        colorScheme: "light",
                        color: "3289c7",
                        livePreview: !0,
                        flat: !0,
                        layout: "full",
                        submit: 0,
                        submitText: "OK",
                        height: 258
                    },
                    fillRGBFields = function (hsb, cal) {
                        var rgb = hsbToRgb(hsb);
                        $(cal).data("colpick").fields.eq(1).val(rgb.r).end().eq(2).val(rgb.g).end().eq(3).val(rgb.b).end(), $(".picker__input__rgb_r").val(rgb.r), $(".picker__input__rgb_g").val(rgb.g), $(".picker__input__rgb_b").val(rgb.b)
                    },
                    fillHSBFields = function (hsb, cal) {
                        $(cal).data("colpick").fields.eq(4).val(Math.round(hsb.h)).end().eq(5).val(Math.round(hsb.s)).end().eq(6).val(Math.round(hsb.b)).end()
                    },
                    fillCMYKFields = function (hsb) {
                        var convert = new colorConvert,
                            rgb = hsbToRgb(hsb),
                            cmyk = convert.rgb(rgb.r, rgb.g, rgb.b).cmyk();
                        cmyk.forEach(function (color, i) {
                            color > 100 && (cmyk[i] = 100), $.isNumeric(color) || (cmyk[i] = 0)
                        }), $(".picker__input__cmyk_c").val(cmyk[0]), $(".picker__input__cmyk_m").val(cmyk[1]), $(".picker__input__cmyk_y").val(cmyk[2]), $(".picker__input__cmyk_k").val(cmyk[3])
                    },
                    fillHexFields = function (hsb, cal) {
                        $(cal).data("colpick").fields.eq(0).val(hsbToHex(hsb)), $(".picker__input__hex").val(hsbToHex(hsb))
                    },
                    setSelector = function (hsb, cal) {
                        $(cal).data("colpick").selector.css("backgroundColor", "#" + hsbToHex({
                            h: hsb.h,
                            s: 100,
                            b: 100
                        })), $(cal).data("colpick").selectorIndic.css({
                            left: parseInt($(cal).data("colpick").height * hsb.s / 100, 10),
                            top: parseInt($(cal).data("colpick").height * (100 - hsb.b) / 100, 10)
                        })
                    },
                    setHue = function (hsb, cal) {
                        $(cal).data("colpick").hue.css("top", parseInt($(cal).data("colpick").height - $(cal).data("colpick").height * hsb.h / 360, 10))
                    },
                    setCurrentColor = function (hsb, cal) {
                        $(cal).data("colpick").currentColor.css("backgroundColor", "#" + hsbToHex(hsb))
                    },
                    setNewColor = function (hsb, cal) {
                        $(cal).data("colpick").newColor.css("backgroundColor", "#" + hsbToHex(hsb))
                    },
                    change = function () {
                        var col, convert = new colorConvert,
                            cal = $(".colpick");
                        if (this.parentNode.parentNode.className.indexOf("_hex") > 0) cal.data("colpick").color = col = hexToHsb(fixHex(this.value)), fillRGBFields(col, cal.get(0)), fillHSBFields(col, cal.get(0)), fillCMYKFields(col, cal.get(0));
                        else if (this.parentNode.parentNode.className.indexOf("_rgb") > 0) cal.data("colpick").color = col = rgbToHsb(fixRGB({
                            r: parseInt($(".picker__input__rgb_r").val(), 10),
                            g: parseInt($(".picker__input__rgb_g").val(), 10),
                            b: parseInt($(".picker__input__rgb_b").val(), 10)
                        })), fillHexFields(col, cal.get(0)), fillHSBFields(col, cal.get(0)), fillCMYKFields(col, cal.get(0));
                        else if (this.parentNode.parentNode.className.indexOf("_cmyk") > 0) {
                            var convert = new colorConvert,
                                cmyk = [parseInt($(".picker__input__cmyk_c").val(), 10), parseInt($(".picker__input__cmyk_m").val(), 10), parseInt($(".picker__input__cmyk_y").val(), 10), parseInt($(".picker__input__cmyk_k").val(), 10)],
                                rgb = convert.cmyk(cmyk[0], cmyk[1], cmyk[2], cmyk[3]).rgb();
                            cal.data("colpick").color = col = rgbToHsb(fixRGB({
                                r: parseInt(rgb[0], 10),
                                g: parseInt(rgb[1], 10),
                                b: parseInt(rgb[2], 10)
                            })), fillRGBFields(col, cal.get(0)), fillHexFields(col, cal.get(0)), fillHSBFields(col, cal.get(0))
                        } else cal.data("colpick").color = col = fixHSB({
                            h: parseInt(cal.data("colpick").fields.eq(4).val(), 10),
                            s: parseInt(cal.data("colpick").fields.eq(5).val(), 10),
                            b: parseInt(cal.data("colpick").fields.eq(6).val(), 10)
                        }), fillRGBFields(col, cal.get(0)), fillHexFields(col, cal.get(0));
                        setSelector(col, cal.get(0)), setHue(col, cal.get(0)), setNewColor(col, cal.get(0)), cal.data("colpick").onChange.apply(cal.parent(), [col, hsbToHex(col), hsbToRgb(col), cal.data("colpick").el, 0])
                    },
                    downHue = function (ev) {
                        ev.preventDefault ? ev.preventDefault() : ev.returnValue = !1;
                        var current = {
                            cal: $(this).parent(),
                            y: $(this).offset().top
                        };
                        $(document).on("mouseup touchend", current, upHue), $(document).on("mousemove touchmove", current, moveHue);
                        var pageY = "touchstart" == ev.type ? ev.originalEvent.changedTouches[0].pageY : ev.pageY;
                        return change.apply(current.cal.data("colpick").fields.eq(4).val(parseInt(360 * (current.cal.data("colpick").height - (pageY - current.y)) / current.cal.data("colpick").height, 10)).get(0), [current.cal.data("colpick").livePreview]), !1
                    },
                    moveHue = function (ev) {
                        var pageY = "touchmove" == ev.type ? ev.originalEvent.changedTouches[0].pageY : ev.pageY;
                        return change.apply(ev.data.cal.data("colpick").fields.eq(4).val(parseInt(360 * (ev.data.cal.data("colpick").height - Math.max(0, Math.min(ev.data.cal.data("colpick").height, pageY - ev.data.y))) / ev.data.cal.data("colpick").height, 10)).get(0), [ev.data.preview]), fillCMYKFields(ev.data.cal.data("colpick").color, null), !1
                    },
                    upHue = function (ev) {
                        return fillRGBFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), fillHexFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), fillCMYKFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), $(document).off("mouseup touchend", upHue), $(document).off("mousemove touchmove", moveHue), !1
                    },
                    downSelector = function (ev) {
                        ev.preventDefault ? ev.preventDefault() : ev.returnValue = !1;
                        var current = {
                            cal: $(this).parent(),
                            pos: $(this).offset()
                        };
                        current.preview = current.cal.data("colpick").livePreview, $(document).on("mouseup touchend", current, upSelector), $(document).on("mousemove touchmove", current, moveSelector);
                        var pageY;
                        return "touchstart" == ev.type ? (pageX = ev.originalEvent.changedTouches[0].pageX, pageY = ev.originalEvent.changedTouches[0].pageY) : (pageX = ev.pageX, pageY = ev.pageY), change.apply(current.cal.data("colpick").fields.eq(6).val(parseInt(100 * (current.cal.data("colpick").height - (pageY - current.pos.top)) / current.cal.data("colpick").height, 10)).end().eq(5).val(parseInt(100 * (pageX - current.pos.left) / current.cal.data("colpick").height, 10)).get(0), [current.preview]), !1
                    },
                    moveSelector = function (ev) {
                        var pageY;
                        return "touchmove" == ev.type ? (pageX = ev.originalEvent.changedTouches[0].pageX, pageY = ev.originalEvent.changedTouches[0].pageY) : (pageX = ev.pageX, pageY = ev.pageY), change.apply(ev.data.cal.data("colpick").fields.eq(6).val(parseInt(100 * (ev.data.cal.data("colpick").height - Math.max(0, Math.min(ev.data.cal.data("colpick").height, pageY - ev.data.pos.top))) / ev.data.cal.data("colpick").height, 10)).end().eq(5).val(parseInt(100 * Math.max(0, Math.min(ev.data.cal.data("colpick").height, pageX - ev.data.pos.left)) / ev.data.cal.data("colpick").height, 10)).get(0), [ev.data.preview]), fillCMYKFields(ev.data.cal.data("colpick").color, null), !1
                    },
                    upSelector = function (ev) {
                        return fillRGBFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), fillHexFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), fillCMYKFields(ev.data.cal.data("colpick").color, ev.data.cal.get(0)), $(document).off("mouseup touchend", upSelector), $(document).off("mousemove touchmove", moveSelector), !1
                    },
                    show = function (ev) {
                        ev.stopPropagation();
                        var cal = $("#" + $(this).data("colpickId"));
                        cal.data("colpick").onBeforeShow.apply(this, [cal.get(0)]);
                        var pos = $(this).offset(),
                            top = pos.top + this.offsetHeight,
                            left = pos.left,
                            viewPort = getViewport(),
                            calW = cal.width();
                        left + calW > viewPort.l + viewPort.w && (left -= calW), cal.css({
                            left: left + "px",
                            top: top + "px"
                        }), 0 != cal.data("colpick").onShow.apply(this, [cal.get(0)]) && cal.show(), $("html").mousedown({
                            cal: cal
                        }, hide), cal.mousedown(function (ev) {
                            ev.stopPropagation()
                        })
                    },
                    hide = function (ev) {
                        0 != ev.data.cal.data("colpick").onHide.apply(this, [ev.data.cal.get(0)]) && ev.data.cal.hide(), $("html").off("mousedown", hide)
                    },
                    getViewport = function () {
                        var m = "CSS1Compat" == document.compatMode;
                        return {
                            l: window.pageXOffset || (m ? document.documentElement.scrollLeft : document.body.scrollLeft),
                            w: window.innerWidth || (m ? document.documentElement.clientWidth : document.body.clientWidth)
                        }
                    },
                    fixHSB = function (hsb) {
                        return {
                            h: Math.min(360, Math.max(0, hsb.h)),
                            s: Math.min(100, Math.max(0, hsb.s)),
                            b: Math.min(100, Math.max(0, hsb.b))
                        }
                    },
                    fixRGB = function (rgb) {
                        return {
                            r: Math.min(255, Math.max(0, rgb.r)),
                            g: Math.min(255, Math.max(0, rgb.g)),
                            b: Math.min(255, Math.max(0, rgb.b))
                        }
                    },
                    fixHex = function (hex) {
                        var len = 6 - hex.length;
                        if (len > 0) {
                            for (var o = [], i = 0; len > i; i++) o.push("0");
                            o.push(hex), hex = o.join("")
                        }
                        return hex
                    };
                return {
                    init: function (opt) {
                        if (opt = $.extend({}, defaults, opt || {}), "string" == typeof opt.color) opt.color = hexToHsb(opt.color);
                        else if (void 0 != opt.color.r && void 0 != opt.color.g && void 0 != opt.color.b) opt.color = rgbToHsb(opt.color);
                        else {
                            if (void 0 == opt.color.h || void 0 == opt.color.s || void 0 == opt.color.b) return this;
                            opt.color = fixHSB(opt.color)
                        }
                        return this.each(function () {
                            if (!$(this).data("colpickId")) {
                                var options = $.extend({}, opt);
                                options.origColor = opt.color;
                                var id = "collorpicker_" + parseInt(1e3 * Math.random());
                                $(this).data("colpickId", id);
                                var cal = $(tpl).attr("id", id);
                                cal.addClass("colpick_" + options.layout + (options.submit ? "" : " colpick_" + options.layout + "_ns")), "light" != options.colorScheme && cal.addClass("colpick_" + options.colorScheme), options.fields = cal.find("input").change(change).keyup(change), $(".picker__input__hex").change(change).keyup(change), $(".picker__input__rgb").change(change).keyup(change), $(".picker__input__cmyk").change(change).keyup(change), options.selector = cal.find("div.colpick_color").on("mousedown touchstart", downSelector), options.selectorIndic = options.selector.find("div.colpick_selector_outer"), options.el = this, options.hue = cal.find("div.colpick_hue_arrs"), huebar = options.hue.parent();
                                var UA = navigator.userAgent.toLowerCase(),
                                    isIE = "Microsoft Internet Explorer" === navigator.appName,
                                    IEver = isIE ? parseFloat(UA.match(/msie ([0-9]{1,}[\.0-9]{0,})/)[1]) : 0,
                                    ngIE = isIE && 10 > IEver,
                                    stops = ["#ff0000", "#ff0080", "#ff00ff", "#8000ff", "#0000ff", "#0080ff", "#00ffff", "#00ff80", "#00ff00", "#80ff00", "#ffff00", "#ff8000", "#ff0000"];
                                if (ngIE) {
                                    var i, div;
                                    for (i = 0; 11 >= i; i++) div = $("<div></div>").attr("style", "height:8.333333%; filter:progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=" + stops[i] + ", endColorstr=" + stops[i + 1] + '); -ms-filter: "progid:DXImageTransform.Microsoft.gradient(GradientType=0,startColorstr=' + stops[i] + ", endColorstr=" + stops[i + 1] + ')";'), huebar.append(div)
                                } else stopList = stops.join(","), huebar.attr("style", "background:-webkit-linear-gradient(top," + stopList + "); background: -o-linear-gradient(top," + stopList + "); background: -ms-linear-gradient(top," + stopList + "); background:-moz-linear-gradient(top," + stopList + "); -webkit-linear-gradient(top," + stopList + "); background:linear-gradient(to bottom," + stopList + "); ");
                                cal.find("div.colpick_hue").on("mousedown touchstart", downHue), options.newColor = cal.find("div.colpick_new_color"), options.currentColor = cal.find("div.colpick_current_color"), cal.data("colpick", options), fillRGBFields(options.color, cal.get(0)), fillHSBFields(options.color, cal.get(0)), fillHexFields(options.color, cal.get(0)), fillCMYKFields(options.color, cal.get(0)), setHue(options.color, cal.get(0)), setSelector(options.color, cal.get(0)), setCurrentColor(options.color, cal.get(0)), setNewColor(options.color, cal.get(0)), options.flat ? (cal.appendTo(this).show(), cal.css({
                                    position: "relative",
                                    display: "block"
                                })) : (cal.appendTo(document.body), $(this).on(options.showEvent, show), cal.css({
                                    position: "absolute"
                                }))
                            }
                        })
                    },
                    showPicker: function () {
                        return this.each(function () {
                            $(this).data("colpickId") && show.apply(this)
                        })
                    },
                    hidePicker: function () {
                        return this.each(function () {
                            $(this).data("colpickId") && $("#" + $(this).data("colpickId")).hide()
                        })
                    },
                    setColor: function (col, setCurrent) {
                        if (setCurrent = "undefined" == typeof setCurrent ? 1 : setCurrent, "string" == typeof col) col = hexToHsb(col);
                        else if (void 0 != col.r && void 0 != col.g && void 0 != col.b) col = rgbToHsb(col);
                        else {
                            if (void 0 == col.h || void 0 == col.s || void 0 == col.b) return this;
                            col = fixHSB(col)
                        }
                        return this.each(function () {
                            if ($(this).data("colpickId")) {
                                var cal = $("#" + $(this).data("colpickId"));
                                cal.data("colpick").color = col, cal.data("colpick").origColor = col, fillRGBFields(col, cal.get(0)), fillHSBFields(col, cal.get(0)), fillHexFields(col, cal.get(0)), fillCMYKFields(col, cal.get(0)), setHue(col, cal.get(0)), setSelector(col, cal.get(0)), setNewColor(col, cal.get(0)), cal.data("colpick").onChange.apply(cal.parent(), [col, hsbToHex(col), hsbToRgb(col), cal.data("colpick").el, 1]), setCurrent && setCurrentColor(col, cal.get(0))
                            }
                        })
                    }
                }
            }(),
            hexToRgb = function (hex) {
                var hex = parseInt(hex.indexOf("#") > -1 ? hex.substring(1) : hex, 16);
                return {
                    r: hex >> 16,
                    g: (65280 & hex) >> 8,
                    b: 255 & hex
                }
            },
            hexToHsb = function (hex) {
                return rgbToHsb(hexToRgb(hex))
            },
            rgbToHsb = function (rgb) {
                var hsb = {
                        h: 0,
                        s: 0,
                        b: 0
                    },
                    min = Math.min(rgb.r, rgb.g, rgb.b),
                    max = Math.max(rgb.r, rgb.g, rgb.b),
                    delta = max - min;
                return hsb.b = max, hsb.s = 0 != max ? 255 * delta / max : 0, hsb.h = 0 != hsb.s ? rgb.r == max ? (rgb.g - rgb.b) / delta : rgb.g == max ? 2 + (rgb.b - rgb.r) / delta : 4 + (rgb.r - rgb.g) / delta : -1, hsb.h *= 60, hsb.h < 0 && (hsb.h += 360), hsb.s *= 100 / 255, hsb.b *= 100 / 255, hsb
            },
            hsbToRgb = function (hsb) {
                var rgb = {},
                    h = hsb.h,
                    s = 255 * hsb.s / 100,
                    v = 255 * hsb.b / 100;
                if (0 == s) rgb.r = rgb.g = rgb.b = v;
                else {
                    var t1 = v,
                        t2 = (255 - s) * v / 255,
                        t3 = (t1 - t2) * (h % 60) / 60;
                    360 == h && (h = 0), 60 > h ? (rgb.r = t1, rgb.b = t2, rgb.g = t2 + t3) : 120 > h ? (rgb.g = t1, rgb.b = t2, rgb.r = t1 - t3) : 180 > h ? (rgb.g = t1, rgb.r = t2, rgb.b = t2 + t3) : 240 > h ? (rgb.b = t1, rgb.r = t2, rgb.g = t1 - t3) : 300 > h ? (rgb.b = t1, rgb.g = t2, rgb.r = t2 + t3) : 360 > h ? (rgb.r = t1, rgb.g = t2, rgb.b = t1 - t3) : (rgb.r = 0, rgb.g = 0, rgb.b = 0)
                }
                return {
                    r: Math.round(rgb.r),
                    g: Math.round(rgb.g),
                    b: Math.round(rgb.b)
                }
            },
            rgbToHex = function (rgb) {
                var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
                return $.each(hex, function (nr, val) {
                    1 == val.length && (hex[nr] = "0" + val)
                }), hex.join("")
            },
            hsbToHex = function (hsb) {
                return rgbToHex(hsbToRgb(hsb))
            };
        $.fn.extend({
            colpick: colpick.init,
            colpickHide: colpick.hidePicker,
            colpickShow: colpick.showPicker,
            colpickSetColor: colpick.setColor
        }), $.extend({
            colpick: {
                rgbToHex: rgbToHex,
                rgbToHsb: rgbToHsb,
                hsbToHex: hsbToHex,
                hsbToRgb: hsbToRgb,
                hexToHsb: hexToHsb,
                hexToRgb: hexToRgb
            }
        })
    }(jQuery),
    function (a) {
        "use strict";
        var b = function () {
            var h = function (x, q, t) {
                    q || (q = "rgba"), x = x.replace(/^\s*#|\s*$/g, ""), 3 === x.length && (x = x.replace(/(.)/g, "$1$1")), x = x.toLowerCase(), q = q.toLowerCase();
                    var s, z, A, B, C, y, u, l, w, k, v, o, m, p, D = {
                            aliceblue: "f0f8ff",
                            antiquewhite: "faebd7",
                            aqua: "00ffff",
                            aquamarine: "7fffd4",
                            azure: "f0ffff",
                            beige: "f5f5dc",
                            bisque: "ffe4c4",
                            black: "000000",
                            blanchedalmond: "ffebcd",
                            blue: "0000ff",
                            blueviolet: "8a2be2",
                            brown: "a52a2a",
                            burlywood: "deb887",
                            cadetblue: "5f9ea0",
                            chartreuse: "7fff00",
                            chocolate: "d2691e",
                            coral: "ff7f50",
                            cornflowerblue: "6495ed",
                            cornsilk: "fff8dc",
                            crimson: "dc143c",
                            cyan: "00ffff",
                            darkblue: "00008b",
                            darkcyan: "008b8b",
                            darkgoldenrod: "b8860b",
                            darkgray: "a9a9a9",
                            darkgreen: "006400",
                            darkkhaki: "bdb76b",
                            darkmagenta: "8b008b",
                            darkolivegreen: "556b2f",
                            darkorange: "ff8c00",
                            darkorchid: "9932cc",
                            darkred: "8b0000",
                            darksalmon: "e9967a",
                            darkseagreen: "8fbc8f",
                            darkslateblue: "483d8b",
                            darkslategray: "2f4f4f",
                            darkturquoise: "00ced1",
                            darkviolet: "9400d3",
                            deeppink: "ff1493",
                            deepskyblue: "00bfff",
                            dimgray: "696969",
                            dodgerblue: "1e90ff",
                            feldspar: "d19275",
                            firebrick: "b22222",
                            floralwhite: "fffaf0",
                            forestgreen: "228b22",
                            fuchsia: "ff00ff",
                            gainsboro: "dcdcdc",
                            ghostwhite: "f8f8ff",
                            gold: "ffd700",
                            goldenrod: "daa520",
                            gray: "808080",
                            green: "008000",
                            greenyellow: "adff2f",
                            honeydew: "f0fff0",
                            hotpink: "ff69b4",
                            indianred: "cd5c5c",
                            indigo: "4b0082",
                            ivory: "fffff0",
                            khaki: "f0e68c",
                            lavender: "e6e6fa",
                            lavenderblush: "fff0f5",
                            lawngreen: "7cfc00",
                            lemonchiffon: "fffacd",
                            lightblue: "add8e6",
                            lightcoral: "f08080",
                            lightcyan: "e0ffff",
                            lightgoldenrodyellow: "fafad2",
                            lightgrey: "d3d3d3",
                            lightgreen: "90ee90",
                            lightpink: "ffb6c1",
                            lightsalmon: "ffa07a",
                            lightseagreen: "20b2aa",
                            lightskyblue: "87cefa",
                            lightslateblue: "8470ff",
                            lightslategray: "778899",
                            lightsteelblue: "b0c4de",
                            lightyellow: "ffffe0",
                            lime: "00ff00",
                            limegreen: "32cd32",
                            linen: "faf0e6",
                            magenta: "ff00ff",
                            maroon: "800000",
                            mediumaquamarine: "66cdaa",
                            mediumblue: "0000cd",
                            mediumorchid: "ba55d3",
                            mediumpurple: "9370d8",
                            mediumseagreen: "3cb371",
                            mediumslateblue: "7b68ee",
                            mediumspringgreen: "00fa9a",
                            mediumturquoise: "48d1cc",
                            mediumvioletred: "c71585",
                            midnightblue: "191970",
                            mintcream: "f5fffa",
                            mistyrose: "ffe4e1",
                            moccasin: "ffe4b5",
                            navajowhite: "ffdead",
                            navy: "000080",
                            oldlace: "fdf5e6",
                            olive: "808000",
                            olivedrab: "6b8e23",
                            orange: "ffa500",
                            orangered: "ff4500",
                            orchid: "da70d6",
                            palegoldenrod: "eee8aa",
                            palegreen: "98fb98",
                            paleturquoise: "afeeee",
                            palevioletred: "d87093",
                            papayawhip: "ffefd5",
                            peachpuff: "ffdab9",
                            peru: "cd853f",
                            pink: "ffc0cb",
                            plum: "dda0dd",
                            powderblue: "b0e0e6",
                            purple: "800080",
                            red: "ff0000",
                            rosybrown: "bc8f8f",
                            royalblue: "4169e1",
                            saddlebrown: "8b4513",
                            salmon: "fa8072",
                            sandybrown: "f4a460",
                            seagreen: "2e8b57",
                            seashell: "fff5ee",
                            sienna: "a0522d",
                            silver: "c0c0c0",
                            skyblue: "87ceeb",
                            slateblue: "6a5acd",
                            slategray: "708090",
                            snow: "fffafa",
                            springgreen: "00ff7f",
                            steelblue: "4682b4",
                            tan: "d2b48c",
                            teal: "008080",
                            thistle: "d8bfd8",
                            tomato: "ff6347",
                            turquoise: "40e0d0",
                            violet: "ee82ee",
                            violetred: "d02090",
                            wheat: "f5deb3",
                            white: "ffffff",
                            whitesmoke: "f5f5f5",
                            yellow: "ffff00",
                            yellowgreen: "9acd32"
                        },
                        n = [{
                            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
                            example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
                            process: function (r) {
                                return [parseInt(r[1], 10), parseInt(r[2], 10), parseInt(r[3], 10), 1]
                            }
                        }, {
                            re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d+(?:\.\d+)?|\.\d+)\s*\)/,
                            example: ["rgba(123, 234, 45, 1)", "rgba(255,234,245, 0.5)"],
                            process: function (r) {
                                return [parseInt(r[1], 10), parseInt(r[2], 10), parseInt(r[3], 10), parseFloat(r[4])]
                            }
                        }, {
                            re: /^hsl\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%\)$/,
                            example: ["hsl(120, 100%, 25%)", "hsl(0, 100%, 50%)"],
                            process: function (E) {
                                E[4] = 1;
                                var r = i(E);
                                return [r.r, r.g, r.b, r.a]
                            }
                        }, {
                            re: /^hsla\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%,\s*(\d+(?:\.\d+)?|\.\d+)\s*\)/,
                            example: ["hsla(120, 100%, 25%, 1)", "hsla(0, 100%, 50%, 0.5)"],
                            process: function (E) {
                                var r = i(E);
                                return [r.r, r.g, r.b, r.a]
                            }
                        }, {
                            re: /^hsv\((\d{1,3}),\s*(\d{1,3})%,\s*(\d{1,3})%\)$/,
                            example: ["hsv(120, 100%, 25%)", "hsl(0, 100%, 50%)"],
                            process: function (E) {
                                var r = j(E);
                                return [r.r, r.g, r.b, 1]
                            }
                        }, {
                            re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                            example: ["#00ff00", "336699"],
                            process: function (r) {
                                return [parseInt(r[1], 16), parseInt(r[2], 16), parseInt(r[3], 16), 1]
                            }
                        }, {
                            re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                            example: ["#fb0", "f0f"],
                            process: function (r) {
                                return [parseInt(r[1] + r[1], 16), parseInt(r[2] + r[2], 16), parseInt(r[3] + r[3], 16), 1]
                            }
                        }];
                    for (C in D) x === C && (x = D[C]);
                    for (y = 0; y < n.length; y++) u = n[y].re, l = n[y].process, w = u.exec(x), w && (k = l(w), s = k[0], z = k[1], A = k[2], B = k[3]);
                    switch (s = 0 > s || isNaN(s) ? 0 : s > 255 ? 255 : s, z = 0 > z || isNaN(z) ? 0 : z > 255 ? 255 : z, A = 0 > A || isNaN(A) ? 0 : A > 255 ? 255 : A, B = 0 > B || isNaN(B) ? 0 : B > 1 ? 1 : B, q) {
                    case "rgba":
                        t && (B = (255 - (v = Math.min(s, z, A))) / 255, s = (0 || (s - v) / B).toFixed(0), z = (0 || (z - v) / B).toFixed(0), A = (0 || (A - v) / B).toFixed(0), B = B.toFixed(4)), p = "rgba(" + s + "," + z + "," + A + "," + B + ")";
                        break;
                    case "rgb":
                        p = "rgb(" + s + "," + z + "," + A + ")";
                        break;
                    case "hex":
                        p = "#" + s.toString(16) + z.toString(16) + A.toString(16);
                        break;
                    case "hsl":
                        o = e({
                            r: s,
                            g: z,
                            b: A
                        }), p = "hsl(" + o.h + "," + o.s + "%," + o.l + "%)";
                        break;
                    case "hsla":
                        o = e({
                            r: s,
                            g: z,
                            b: A,
                            a: B
                        }), p = "hsl(" + o.h + "," + o.s + "%," + o.l + "%," + o.a + ")";
                        break;
                    case "hsv":
                        m = g({
                            r: s,
                            g: z,
                            b: A
                        }), p = "hsv(" + m.h + "," + m.s + "%," + m.v + "%)"
                    }
                    return p
                },
                i = function (n) {
                    var m, o, l = {},
                        k = {
                            h: f(parseInt(n[1], 10) % 360, 360),
                            s: f(parseInt(n[2], 10) % 101, 100),
                            l: f(parseInt(n[3], 10) % 101, 100),
                            a: parseFloat(n[4])
                        };
                    return 0 === k.s ? l = {
                        r: k.l,
                        g: k.l,
                        b: k.l,
                        a: k.a
                    } : (m = k.l < .5 ? k.l * (1 + k.s) : k.l + k.s - k.l * k.s, o = 2 * k.l - m, l.r = parseInt((256 * d(o, m, k.h + 1 / 3)).toFixed(0), 10), l.g = parseInt((256 * d(o, m, k.h)).toFixed(0), 10), l.b = parseInt((256 * d(o, m, k.h - 1 / 3)).toFixed(0), 10), l.a = k.a), l
                },
                e = function (n) {
                    n.r = f(parseInt(n.r, 10) % 256, 256), n.g = f(parseInt(n.g, 10) % 256, 256), n.b = f(parseInt(n.b, 10) % 256, 256);
                    var o, k = Math.max(n.r, n.g, n.b),
                        m = Math.min(n.r, n.g, n.b),
                        l = [];
                    if (l.a = n.a, l.l = (k + m) / 2, k === m) l.h = 0, l.s = 0;
                    else {
                        switch (o = k - m, l.s = l.l > .5 ? o / (2 - k - m) : o / (k + m), k) {
                        case n.r:
                            l.h = (n.g - n.b) / o + (n.g < n.b ? 6 : 0);
                            break;
                        case n.g:
                            l.h = (n.b - n.r) / o + 2;
                            break;
                        case n.b:
                            l.h = (n.r - n.g) / o + 4
                        }
                        l.h /= 6
                    }
                    return l.h = parseInt((360 * l.h).toFixed(0), 10), l.s = parseInt((100 * l.s).toFixed(0), 10), l.l = parseInt((100 * l.l).toFixed(0), 10), l
                },
                j = function (s) {
                    var l = {},
                        k = {
                            h: f(parseInt(s[1], 10) % 360, 360),
                            s: f(parseInt(s[2], 10) % 101, 100),
                            v: f(parseInt(s[3], 10) % 101, 100)
                        },
                        n = Math.floor(6 * k.h),
                        r = 6 * k.h - n,
                        u = k.v * (1 - k.s),
                        o = k.v * (1 - r * k.s),
                        m = k.v * (1 - (1 - r) * k.s);
                    switch (n % 6) {
                    case 0:
                        l.r = k.v, l.g = m, l.b = u;
                        break;
                    case 1:
                        l.r = o, l.g = k.v, l.b = u;
                        break;
                    case 2:
                        l.r = u, l.g = k.v, l.b = m;
                        break;
                    case 3:
                        l.r = u, l.g = o, l.b = k.v;
                        break;
                    case 4:
                        l.r = m, l.g = u, l.b = k.v;
                        break;
                    case 5:
                        l.r = k.v, l.g = u, l.b = o
                    }
                    return l.r = parseInt(256 * l.r, 10), l.g = parseInt(256 * l.g, 10), l.b = parseInt(256 * l.b, 10), {
                        r: l.r,
                        g: l.g,
                        b: l.b
                    }
                },
                g = function (n) {
                    n.r = f(parseInt(n.r, 10) % 256, 256), n.g = f(parseInt(n.g, 10) % 256, 256), n.b = f(parseInt(n.b, 10) % 256, 256);
                    var k = Math.max(n.r, n.g, n.b),
                        m = Math.min(n.r, n.g, n.b),
                        o = k - m,
                        l = {
                            h: 0,
                            s: 0 === k ? 0 : o / k,
                            v: k
                        };
                    if (k !== m) {
                        switch (k) {
                        case n.r:
                            l.h = (n.g - n.b) / o + (n.g < n.b ? 6 : 0);
                            break;
                        case n.g:
                            l.h = (n.b - n.r) / o + 2;
                            break;
                        case n.b:
                            l.h = (n.r - n.g) / o + 4
                        }
                        l.h /= 6
                    }
                    return l.h = parseInt((360 * l.h).toFixed(0), 10), l.s = parseInt((100 * l.s).toFixed(0), 10), l.v = parseInt((100 * l.v).toFixed(0), 10), l
                },
                d = function (m, l, k) {
                    return 0 > k && (k += 1), k > 1 && (k -= 1), 1 / 6 > k ? m + 6 * (l - m) * k : .5 > k ? l : 2 / 3 > k ? m + (l - m) * (2 / 3 - k) * 6 : m
                },
                f = function (l, k) {
                    return l / k
                };
            return h
        }();
        a.color2color = b
    }(window),
    function () {
        function b() {
            return b
        }

        function c(b, d) {
            var e = c.resolve(b),
                f = c.modules[e];
            if (!f) throw new Error('failed to require "' + b + '" from ' + d);
            return f.exports || (f.exports = {}, f.call(f.exports, f, f.exports, c.relative(e), a)), f.exports
        }
        var a = this;
        c.modules = {}, c.resolve = function (a) {
            var b = a,
                d = a + ".js",
                e = a + "/index.js";
            return c.modules[d] && d || c.modules[e] && e || b
        }, c.register = function (a, b) {
            c.modules[a] = b
        }, c.relative = function (a) {
            return function (d) {
                if ("debug" == d) return b;
                if ("." != d.charAt(0)) return c(d);
                var e = a.split("/"),
                    f = d.split("/");
                e.pop();
                for (var g = 0; g < f.length; g++) {
                    var h = f[g];
                    ".." == h ? e.pop() : "." != h && e.push(h)
                }
                return c(e.join("/"), a)
            }
        }, c.register("index.js", function (a, b, c) {
            function l(a) {
                for (var b = 0; b < a.length; b++) a[b] = Math.round(a[b])
            }
            var e = c("./conversions"),
                f = function () {
                    return new k
                };
            for (var g in e) {
                f[g + "Raw"] = function (a) {
                    return function (b) {
                        return "number" == typeof b && (b = Array.prototype.slice.call(arguments)), e[a](b)
                    }
                }(g);
                var h = /(\w+)2(\w+)/.exec(g),
                    i = h[1],
                    j = h[2];
                f[i] = f[i] || {}, f[i][j] = f[g] = function (a) {
                    return function (b) {
                        "number" == typeof b && (b = Array.prototype.slice.call(arguments));
                        var c = e[a](b);
                        return "string" == typeof c || void 0 === c ? c : (l(c), c)
                    }
                }(g)
            }
            var k = function () {
                this.space = "rgb", this.convs = {
                    rgb: [0, 0, 0]
                }
            };
            k.prototype.routeSpace = function (a, b) {
                var c = b[0];
                return void 0 === c ? this.getValues(a) : ("number" == typeof c && (c = Array.prototype.slice.call(b)), this.setValues(a, c))
            }, k.prototype.setValues = function (a, b) {
                return this.space = a, this.convs = {}, this.convs[a] = b, this
            }, k.prototype.getValues = function (a) {
                var b = this.convs[a];
                if (b) l(b);
                else {
                    var c = this.space,
                        d = this.convs[c];
                    b = f[c][a](d), this.convs[a] = b
                }
                return b
            }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (a) {
                k.prototype[a] = function () {
                    return this.routeSpace(a, arguments)
                }
            }), a.exports = f
        }), c.register("conversions.js", function (a) {
            function e(a) {
                var h, i, j, b = a[0] / 255,
                    c = a[1] / 255,
                    d = a[2] / 255,
                    e = Math.min(b, c, d),
                    f = Math.max(b, c, d),
                    g = f - e;
                return f == e ? h = 0 : b == f ? h = (c - d) / g : c == f ? h = 2 + (d - b) / g : d == f && (h = 4 + (b - c) / g), h = Math.min(60 * h, 360), 0 > h && (h += 360), j = (e + f) / 2, i = f == e ? 0 : .5 >= j ? g / (f + e) : g / (2 - f - e), [h, 100 * i, 100 * j]
            }

            function f(a) {
                var h, i, j, b = a[0],
                    c = a[1],
                    d = a[2],
                    e = Math.min(b, c, d),
                    f = Math.max(b, c, d),
                    g = f - e;
                return i = 0 == f ? 0 : g / f * 1e3 / 10, f == e ? h = 0 : b == f ? h = (c - d) / g : c == f ? h = 2 + (d - b) / g : d == f && (h = 4 + (b - c) / g), h = Math.min(60 * h, 360), 0 > h && (h += 360), j = f / 255 * 1e3 / 10, [h, i, j]
            }

            function g(a) {
                var e, f, g, h, b = a[0] / 255,
                    c = a[1] / 255,
                    d = a[2] / 255;
                return h = Math.min(1 - b, 1 - c, 1 - d), e = (1 - b - h) / (1 - h), f = (1 - c - h) / (1 - h), g = (1 - d - h) / (1 - h), [100 * e, 100 * f, 100 * g, 100 * h]
            }

            function h(a) {
                return G[JSON.stringify(a)]
            }

            function i(a) {
                var b = a[0] / 255,
                    c = a[1] / 255,
                    d = a[2] / 255;
                b = b > .04045 ? Math.pow((b + .055) / 1.055, 2.4) : b / 12.92, c = c > .04045 ? Math.pow((c + .055) / 1.055, 2.4) : c / 12.92, d = d > .04045 ? Math.pow((d + .055) / 1.055, 2.4) : d / 12.92;
                var e = .4124 * b + .3576 * c + .1805 * d,
                    f = .2126 * b + .7152 * c + .0722 * d,
                    g = .0193 * b + .1192 * c + .9505 * d;
                return [100 * e, 100 * f, 100 * g]
            }

            function j(a) {
                var f, g, h, b = i(a),
                    c = b[0],
                    d = b[1],
                    e = b[2];
                return c /= 95.047, d /= 100, e /= 108.883, c = c > .008856 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, d = d > .008856 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, e = e > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, f = 116 * d - 16, g = 500 * (c - d), h = 200 * (d - e), [f, g, h]
            }

            function k(a) {
                var e, f, g, h, i, b = a[0] / 360,
                    c = a[1] / 100,
                    d = a[2] / 100;
                if (0 == c) return i = 255 * d, [i, i, i];
                f = .5 > d ? d * (1 + c) : d + c - d * c, e = 2 * d - f, h = [0, 0, 0];
                for (var j = 0; 3 > j; j++) g = b + 1 / 3 * -(j - 1), 0 > g && g++, g > 1 && g--, i = 1 > 6 * g ? e + 6 * (f - e) * g : 1 > 2 * g ? f : 2 > 3 * g ? e + (f - e) * (2 / 3 - g) * 6 : e, h[j] = 255 * i;
                return h
            }

            function l(a) {
                var e, f, b = a[0],
                    c = a[1] / 100,
                    d = a[2] / 100;
                return d *= 2, c *= 1 >= d ? d : 2 - d, f = (d + c) / 2, e = 2 * c / (d + c), [b, 100 * e, 100 * f]
            }

            function m(a) {
                return g(k(a))
            }

            function n(a) {
                return h(k(a))
            }

            function o(a) {
                var b = a[0] / 60,
                    c = a[1] / 100,
                    d = a[2] / 100,
                    e = Math.floor(b) % 6,
                    f = b - Math.floor(b),
                    g = 255 * d * (1 - c),
                    h = 255 * d * (1 - c * f),
                    i = 255 * d * (1 - c * (1 - f)),
                    d = 255 * d;
                switch (e) {
                case 0:
                    return [d, i, g];
                case 1:
                    return [h, d, g];
                case 2:
                    return [g, d, i];
                case 3:
                    return [g, h, d];
                case 4:
                    return [i, g, d];
                case 5:
                    return [d, g, h]
                }
            }

            function p(a) {
                var e, f, b = a[0],
                    c = a[1] / 100,
                    d = a[2] / 100;
                return f = (2 - c) * d, e = c * d, e /= 1 >= f ? f : 2 - f, f /= 2, [b, 100 * e, 100 * f]
            }

            function q(a) {
                return g(o(a))
            }

            function r(a) {
                return h(o(a))
            }

            function s(a) {
                var f, g, h, b = a[0] / 100,
                    c = a[1] / 100,
                    d = a[2] / 100,
                    e = a[3] / 100;
                return f = 1 - Math.min(1, b * (1 - e) + e), g = 1 - Math.min(1, c * (1 - e) + e), h = 1 - Math.min(1, d * (1 - e) + e), [255 * f, 255 * g, 255 * h]
            }

            function t(a) {
                return e(s(a))
            }

            function u(a) {
                return f(s(a))
            }

            function v(a) {
                return h(s(a))
            }

            function w(a) {
                var e, f, g, b = a[0] / 100,
                    c = a[1] / 100,
                    d = a[2] / 100;
                return e = 3.2406 * b + -1.5372 * c + d * -.4986, f = b * -.9689 + 1.8758 * c + .0415 * d, g = .0557 * b + c * -.204 + 1.057 * d, e = e > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, f = f > .0031308 ? 1.055 * Math.pow(f, 1 / 2.4) - .055 : f *= 12.92, g = g > .0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - .055 : g *= 12.92, e = 0 > e ? 0 : e, f = 0 > f ? 0 : f, g = 0 > g ? 0 : g, [255 * e, 255 * f, 255 * g]
            }

            function x(a) {
                var e, f, g, b = a[0],
                    c = a[1],
                    d = a[2];
                return b /= 95.047, c /= 100, d /= 108.883, b = b > .008856 ? Math.pow(b, 1 / 3) : 7.787 * b + 16 / 116, c = c > .008856 ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116, d = d > .008856 ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116, e = 116 * c - 16, f = 500 * (b - c), g = 200 * (c - d), [e, f, g]
            }

            function y(a) {
                var e, f, g, h, b = a[0],
                    c = a[1],
                    d = a[2];
                return 8 >= b ? (f = 100 * b / 903.3, h = 7.787 * (f / 100) + 16 / 116) : (f = 100 * Math.pow((b + 16) / 116, 3), h = Math.pow(f / 100, 1 / 3)), e = .008856 >= e / 95.047 ? e = 95.047 * (c / 500 + h - 16 / 116) / 7.787 : 95.047 * Math.pow(c / 500 + h, 3), g = .008859 >= g / 108.883 ? g = 108.883 * (h - d / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(h - d / 200, 3), [e, f, g]
            }

            function z(a) {
                return F[a]
            }

            function A(a) {
                return e(z(a))
            }

            function B(a) {
                return f(z(a))
            }

            function C(a) {
                return g(z(a))
            }

            function D(a) {
                return j(z(a))
            }

            function E(a) {
                return i(z(a))
            }
            a.exports = {
                rgb2hsl: e,
                rgb2hsv: f,
                rgb2cmyk: g,
                rgb2keyword: h,
                rgb2xyz: i,
                rgb2lab: j,
                hsl2rgb: k,
                hsl2hsv: l,
                hsl2cmyk: m,
                hsl2keyword: n,
                hsv2rgb: o,
                hsv2hsl: p,
                hsv2cmyk: q,
                hsv2keyword: r,
                cmyk2rgb: s,
                cmyk2hsl: t,
                cmyk2hsv: u,
                cmyk2keyword: v,
                keyword2rgb: z,
                keyword2hsl: A,
                keyword2hsv: B,
                keyword2cmyk: C,
                keyword2lab: D,
                keyword2xyz: E,
                xyz2rgb: w,
                xyz2lab: x,
                lab2xyz: y
            };
            var F = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                },
                G = {};
            for (var H in F) G[JSON.stringify(F[H])] = H
        }), colorConvert = c("index.js")
    }(), ! function (a, b) {
        "object" == typeof exports ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.Spinner = b()
    }(this, function () {
        "use strict";

        function a(a, b) {
            var c, d = document.createElement(a || "div");
            for (c in b) d[c] = b[c];
            return d
        }

        function b(a) {
            for (var b = 1, c = arguments.length; c > b; b++) a.appendChild(arguments[b]);
            return a
        }

        function c(a, b, c, d) {
            var e = ["opacity", b, ~~(100 * a), c, d].join("-"),
                f = .01 + c / d * 100,
                g = Math.max(1 - (1 - a) / b * (100 - f), a),
                h = j.substring(0, j.indexOf("Animation")).toLowerCase(),
                i = h && "-" + h + "-" || "";
            return l[e] || (m.insertRule("@" + i + "keyframes " + e + "{0%{opacity:" + g + "}" + f + "%{opacity:" + a + "}" + (f + .01) + "%{opacity:1}" + (f + b) % 100 + "%{opacity:" + a + "}100%{opacity:" + g + "}}", m.cssRules.length), l[e] = 1), e
        }

        function d(a, b) {
            var c, d, e = a.style;
            for (b = b.charAt(0).toUpperCase() + b.slice(1), d = 0; d < k.length; d++)
                if (c = k[d] + b, void 0 !== e[c]) return c;
            return void 0 !== e[b] ? b : void 0
        }

        function e(a, b) {
            for (var c in b) a.style[d(a, c) || c] = b[c];
            return a
        }

        function f(a) {
            for (var b = 1; b < arguments.length; b++) {
                var c = arguments[b];
                for (var d in c) void 0 === a[d] && (a[d] = c[d])
            }
            return a
        }

        function g(a, b) {
            return "string" == typeof a ? a : a[b % a.length]
        }

        function h(a) {
            this.opts = f(a || {}, h.defaults, n)
        }

        function i() {
            function c(b, c) {
                return a("<" + b + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', c)
            }
            m.addRule(".spin-vml", "behavior:url(#default#VML)"), h.prototype.lines = function (a, d) {
                function f() {
                    return e(c("group", {
                        coordsize: k + " " + k,
                        coordorigin: -j + " " + -j
                    }), {
                        width: k,
                        height: k
                    })
                }

                function h(a, h, i) {
                    b(m, b(e(f(), {
                        rotation: 360 / d.lines * a + "deg",
                        left: ~~h
                    }), b(e(c("roundrect", {
                        arcsize: d.corners
                    }), {
                        width: j,
                        height: d.width,
                        left: d.radius,
                        top: -d.width >> 1,
                        filter: i
                    }), c("fill", {
                        color: g(d.color, a),
                        opacity: d.opacity
                    }), c("stroke", {
                        opacity: 0
                    }))))
                }
                var i, j = d.length + d.width,
                    k = 2 * j,
                    l = 2 * -(d.width + d.length) + "px",
                    m = e(f(), {
                        position: "absolute",
                        top: l,
                        left: l
                    });
                if (d.shadow)
                    for (i = 1; i <= d.lines; i++) h(i, -2, "progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)");
                for (i = 1; i <= d.lines; i++) h(i);
                return b(a, m)
            }, h.prototype.opacity = function (a, b, c, d) {
                var e = a.firstChild;
                d = d.shadow && d.lines || 0, e && b + d < e.childNodes.length && (e = e.childNodes[b + d], e = e && e.firstChild, e = e && e.firstChild, e && (e.opacity = c))
            }
        }
        var j, k = ["webkit", "Moz", "ms", "O"],
            l = {},
            m = function () {
                var c = a("style", {
                    type: "text/css"
                });
                return b(document.getElementsByTagName("head")[0], c), c.sheet || c.styleSheet
            }(),
            n = {
                lines: 12,
                length: 7,
                width: 5,
                radius: 10,
                rotate: 0,
                corners: 1,
                color: "#000",
                direction: 1,
                speed: 1,
                trail: 100,
                opacity: .25,
                fps: 20,
                zIndex: 2e9,
                className: "spinner",
                top: "50%",
                left: "50%",
                position: "absolute"
            };
        h.defaults = {}, f(h.prototype, {
            spin: function (b) {
                this.stop();
                var c = this,
                    d = c.opts,
                    f = c.el = e(a(0, {
                        className: d.className
                    }), {
                        position: d.position,
                        width: 0,
                        zIndex: d.zIndex
                    });
                if (d.radius + d.length + d.width, e(f, {
                    left: d.left,
                    top: d.top
                }), b && b.insertBefore(f, b.firstChild || null), f.setAttribute("role", "progressbar"), c.lines(f, c.opts), !j) {
                    var g, h = 0,
                        i = (d.lines - 1) * (1 - d.direction) / 2,
                        k = d.fps,
                        l = k / d.speed,
                        m = (1 - d.opacity) / (l * d.trail / 100),
                        n = l / d.lines;
                    ! function o() {
                        h++;
                        for (var a = 0; a < d.lines; a++) g = Math.max(1 - (h + (d.lines - a) * n) % l * m, d.opacity), c.opacity(f, a * d.direction + i, g, d);
                        c.timeout = c.el && setTimeout(o, ~~(1e3 / k))
                    }()
                }
                return c
            },
            stop: function () {
                var a = this.el;
                return a && (clearTimeout(this.timeout), a.parentNode && a.parentNode.removeChild(a), this.el = void 0), this
            },
            lines: function (d, f) {
                function h(b, c) {
                    return e(a(), {
                        position: "absolute",
                        width: f.length + f.width + "px",
                        height: f.width + "px",
                        background: b,
                        boxShadow: c,
                        transformOrigin: "left",
                        transform: "rotate(" + ~~(360 / f.lines * k + f.rotate) + "deg) translate(" + f.radius + "px,0)",
                        borderRadius: (f.corners * f.width >> 1) + "px"
                    })
                }
                for (var i, k = 0, l = (f.lines - 1) * (1 - f.direction) / 2; k < f.lines; k++) i = e(a(), {
                    position: "absolute",
                    top: 1 + ~(f.width / 2) + "px",
                    transform: f.hwaccel ? "translate3d(0,0,0)" : "",
                    opacity: f.opacity,
                    animation: j && c(f.opacity, f.trail, l + k * f.direction, f.lines) + " " + 1 / f.speed + "s linear infinite"
                }), f.shadow && b(i, e(h("#000", "0 0 4px #000"), {
                    top: "2px"
                })), b(d, b(i, h(g(f.color, k), "0 0 1px rgba(0,0,0,.1)")));
                return d
            },
            opacity: function (a, b, c) {
                b < a.childNodes.length && (a.childNodes[b].style.opacity = c)
            }
        });
        var o = e(a("group"), {
            behavior: "url(#default#VML)"
        });
        return !d(o, "transform") && o.adj ? i() : j = d(o, "animation"), h
    }),
    function ($) {
        $.extend($, {
            placeholder: {
                browser_supported: function () {
                    return void 0 !== this._supported ? this._supported : this._supported = !!("placeholder" in $('<input type="text">')[0])
                },
                shim: function (opts) {
                    var config = {
                        color: "#999",
                        cls: "placeholder",
                        selector: "input[placeholder], textarea[placeholder]"
                    };
                    return $.extend(config, opts), !this.browser_supported() && $(config.selector)._placeholder_shim(config)
                }
            }
        }), $.extend($.fn, {
            _placeholder_shim: function (config) {
                function calcPositionCss(target) {
                    var op = $(target).offsetParent().offset(),
                        ot = $(target).offset();
                    return {
                        top: ot.top - op.top,
                        left: ot.left - op.left,
                        width: $(target).width()
                    }
                }

                function adjustToResizing(label) {
                    var $target = label.data("target");
                    "undefined" != typeof $target && (label.css(calcPositionCss($target)), $(window).one("resize", function () {
                        adjustToResizing(label)
                    }))
                }
                return this.each(function () {
                    var $this = $(this);
                    if ($this.is(":visible")) {
                        if ($this.data("placeholder")) {
                            var $ol = $this.data("placeholder");
                            return $ol.css(calcPositionCss($this)), !0
                        }
                        var possible_line_height = {};
                        $this.is("textarea") || "auto" == $this.css("height") || (possible_line_height = {
                            lineHeight: $this.css("height"),
                            whiteSpace: "nowrap"
                        });
                        var isBorderBox = "border-box" === $this.css("box-sizing"),
                            ol = $("<label />").text($this.attr("placeholder")).addClass(config.cls).css($.extend({
                                position: "absolute",
                                display: "inline",
                                "float": "none",
                                overflow: "hidden",
                                textAlign: "center",
                                color: config.color,
                                cursor: "text",
                                paddingTop: isBorderBox ? "0" : $this.css("padding-top"),
                                paddingRight: $this.css("padding-right"),
                                paddingBottom: isBorderBox ? "0" : $this.css("padding-bottom"),
                                paddingLeft: $this.css("padding-left"),
                                fontSize: $this.css("font-size"),
                                fontFamily: $this.css("font-family"),
                                fontStyle: $this.css("font-style"),
                                fontWeight: $this.css("font-weight"),
                                textTransform: $this.css("text-transform"),
                                backgroundColor: "transparent",
                                zIndex: 99
                            }, possible_line_height)).css(calcPositionCss(this)).attr("for", this.id).data("target", $this).click(function () {
                                $(this).data("target").is(":disabled") || $(this).data("target").focus()
                            }).insertBefore(this);
                        $this.data("placeholder", ol).keydown(function () {
                            ol.hide()
                        }).blur(function () {
                            ol[$this.val().length ? "hide" : "show"]()
                        }).triggerHandler("blur"), $(window).one("resize", function () {
                            adjustToResizing(ol)
                        })
                    }
                })
            }
        })
    }(jQuery), jQuery(document).add(window).bind("ready load", function () {
        jQuery.placeholder && jQuery.placeholder.shim()
    }), window.mobilecheck = function () {
        var check = !1;
        return function (a) {
            (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) && (check = !0)
        }(navigator.userAgent || navigator.vendor || window.opera), check
    };
var galleryControllers = angular.module("galleryControllers", []);
if (galleryControllers.controller("GalleryBaseController", ["$scope", "$http", "$timeout",
    function ($scope, $http, $timeout) {
        $scope.userData = $(".app").data(), $scope.overlay = "login", $scope.artwork = {
            name: "",
            image: ""
        }, $("#login__form").on("ajax:success", function (e, data) {
            window.location.href = data.location
        }).on("ajax:error", function () {
            $(".login").addClass("login--error--shake login--error"), $timeout(function () {
                $(".login").removeClass("login--error--shake")
            }, 1e3)
        }), $("#request__form").on("ajax:success", function () {
            $(".login").addClass("request-success")
        }).on("ajax:error", function () {
            $(".login").addClass("login--error"), $timeout(function () {
                $(".login").removeClass("login--error")
            }, 1e3)
        }), $("#forgot__form").on("ajax:success", function () {
            $(".login").addClass("forgot-success")
        }).on("ajax:error", function (e, xhr, status, error) {
            console.log("Error:", error)
        }), $("#accept-invitation").on("ajax:success", function (e, data) {
            window.location.href = data.location
        }).on("ajax:error", function (e, data) {
            var $container = $(".activation__content");
            $container.addClass("activation-error"), $.each(data.responseJSON.errors, function (key, value) {
                $(".activation_error").html(value)
            })
        }), $("#forgot-password__form").on("ajax:success", function (e, data) {
            window.location.href = data.location
        }).on("ajax:error", function (e, data) {
            var $container = $(".activation__content");
            $container.addClass("activation-error"), $.each(data.responseJSON.errors, function (key, value) {
                $(".activation_error").html(value)
            })
        }), $scope.closeIEMessage = function () {
            var date = new Date,
                today = date.getFullYear() + "" + date.getMonth() + date.getDay();
            localStorage.setItem("browserFailDate", today), $scope.warning = !1
        }, $scope.goToTool = function ($tool, $logged_in) {
            $logged_in ? window.location = "/" + $scope.userData.market + "/" + $scope.userData.locale + "/envisualizer/#/tool/" + $tool : ($("#user_tool").val($tool), $scope.showLogin())
        }, $scope.setArtworkLink = function (url) {
            return Modernizr.history ? url : ""
        }, $scope.showLogin = function () {
            $(".login").removeClass("hidden")
        }, $scope.hideLogin = function () {
            $(".login").addClass("hidden").removeClass("request-success"), $scope.setOverlay("login")
        }, $scope.activeOverlay = function ($slug) {
            return $scope.overlay === $slug
        }, $scope.setOverlay = function ($slug) {
            $scope.overlay = $slug
        }, ("#login" == window.location.hash || "#/login" == window.location.hash) && $scope.showLogin()
    }
]), galleryControllers.controller("SingleArtwork", ["$scope", "$routeParams", "$http",
    function ($scope, $routeParams, $http) {
        $scope.artworkId = $routeParams.artworkId, $scope.market = $routeParams.market, $scope.locale = $routeParams.locale, $scope.userId = $routeParams.userId, $scope.userData = $(".app").data(), $(".gallery__artwork--hidden").length || ga("send", "pageview", {
            page: location.pathname + location.search + location.hash
        }), $scope.openArtwork = function () {
            console.log("open")
        }, $scope.loadArtwork = function (artworkId, userId) {
            var url;
            url = userId ? "/" + $scope.market + "/" + $scope.locale + "/users/" + userId + "/artworks/" + $scope.artworkId + ".json" : "/" + $scope.market + "/" + $scope.locale + "/artworks/" + $scope.artworkId + ".json", $http.get(url).success(function (data) {
                $scope.artwork = data, $(".gallery__overlay").fadeIn(200)
            })
        }, $scope.report = function (artworkId) {
            var confirmReport = confirm("Are you sure you want to report this artwork?");
            if (confirmReport) {
                var url = "/" + $scope.userData.market + "/" + $scope.userData.locale + "/artworks/" + artworkId + "/report";
                $http.put(url).success(function () {
                    $(".gallery__overlay__info--report").hide()
                }).error(function (data) {
                    console.log("Error: " + data)
                })
            }
        }, $scope.delete = function (artwork) {
            var confirmDelete = confirm("Are you sure you want to delete this artwork?");
            if (confirmDelete) {
                var url = "/" + $scope.userData.market + "/" + $scope.userData.locale + "/users/" + artwork.user_id + "/artworks/" + artwork.id;
                $http.delete(url).success(function () {
                    $(".gallery__artwork--" + artwork.id).remove(), $(".gallery__overlay__close").trigger("click")
                }).error(function (data) {
                    console.log("Error: " + data)
                })
            }
        }, $scope.isKaleidoscope = function (tool) {
            return "kaleidoscope" === tool
        }, $scope.isSVG = function (tool) {
            return "pattern" === tool
        }, $scope.isOwner = function (artwork) {
            return artwork.user_id == $scope.userData.userid
        }, $scope.facebookShare = function () {
            ga("send", "event", "Sharing", "Facebook", document.location.href);
            var width = 626,
                height = 436,
                left = ($(window).width() - width) / 2,
                top = ($(window).height() - height) / 2,
                url = "https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(document.location.href),
                opts = "status=1,width=" + width + ",height=" + height + ",top=" + top + ",left=" + left;
            return window.open(url, "facebook-share-dialog", opts), !1
        }, $scope.twitterShare = function () {
            ga("send", "event", "Sharing", "Twitter", document.location.href);
            var width = 575,
                height = 400,
                left = ($(window).width() - width) / 2,
                top = ($(window).height() - height) / 2,
                url = "http://twitter.com/share?url=" + encodeURIComponent(document.location.href) + "&text=" + encodeURIComponent("Beautiful designs in seconds."),
                opts = "status=1,width=" + width + ",height=" + height + ",top=" + top + ",left=" + left;
            return window.open(url, "twitter", opts), !1
        }, $scope.pinterestShare = function (artworkImg) {
            ga("send", "event", "Sharing", "Pinterest", document.location.href);
            var width = 750,
                height = 320,
                left = ($(window).width() - width) / 2,
                top = ($(window).height() - height) / 2,
                url = "http://pinterest.com/pin/create/button/?url=" + encodeURIComponent(document.location.href) + "&amp;media=" + artworkImg + "&amp;description=" + encodeURIComponent("Beautiful designs in seconds."),
                opts = "status=1,width=" + width + ",height=" + height + ",top=" + top + ",left=" + left;
            return window.open(url, "pinterest", opts), !1
        }, $scope.downloadPNG = function (artwork) {
            window.open("/" + $scope.userData.market + "/" + $scope.userData.locale + "/users/" + artwork.user_id + "/artworks/" + artwork.id + "/export?type=png")
        }, $scope.downloadSVG = function (artwork) {
            window.open("/" + $scope.userData.market + "/" + $scope.userData.locale + "/users/" + artwork.user_id + "/artworks/" + artwork.id + "/export?type=svg")
        }, $scope.closeArtworkOverlay = function () {
            $(".gallery__overlay").fadeOut(200)
        }, $routeParams.artworkId ? $scope.loadArtwork($routeParams.artworkId, $routeParams.userId) : $(".gallery__overlay").fadeOut(200)
    }
]), angular.module("placeholderShim", []).directive("placeholder", ["$interpolate", "$timeout",
    function (a, b) {
        return jQuery.placeholder.browser_supported() ? {} : function (c, d) {
            function e() {
                j = b(function () {
                    d._placeholder_shim(f), i = d.data("placeholder"), j = null
                })
            }
            var f = {
                    color: "#888",
                    cls: "placeholder"
                },
                g = a(d.attr("placeholder")),
                h = null,
                i = null,
                j = null;
            d.is(":visible") && e(), c.$watch(function () {
                if (i || !d.is(":visible") || j || e(), i && d.get(0) !== document.activeElement && (d.val().length ? i.hide() : i.show()), i) {
                    var a = g(c);
                    a !== h && (h = a, i.text(h))
                }
            }), c.$on("$destroy", function () {
                j && (b.cancel(j), j = null)
            })
        }
    }
]), angular.module("ui.slider", []).value("uiSliderConfig", {}).directive("uiSlider", ["uiSliderConfig", "$timeout",
    function (uiSliderConfig, $timeout) {
        return uiSliderConfig = uiSliderConfig || {}, {
            require: "ngModel",
            compile: function () {
                return function (scope, elm, attrs, ngModel) {
                    function parseNumber(n, decimals) {
                        return decimals ? parseFloat(n) : parseInt(n)
                    }

                    function destroy() {
                        elm.slider("destroy")
                    }
                    var options = angular.extend(scope.$eval(attrs.uiSlider) || {}, uiSliderConfig),
                        prevRangeValues = {
                            min: null,
                            max: null
                        },
                        properties = ["min", "max", "step"],
                        useDecimals = angular.isUndefined(attrs.useDecimals) ? !1 : !0,
                        init = function () {
                            angular.isArray(ngModel.$viewValue) && options.range !== !0 && (console.warn("Change your range option of ui-slider. When assigning ngModel an array of values then the range option should be set to true."), options.range = !0), angular.forEach(properties, function (property) {
                                angular.isDefined(attrs[property]) && (options[property] = parseNumber(attrs[property], useDecimals))
                            }), elm.slider(options), init = angular.noop
                        };
                    angular.forEach(properties, function (property) {
                        attrs.$observe(property, function (newVal) {
                            newVal && (init(), elm.slider("option", property, parseNumber(newVal, useDecimals)))
                        })
                    }), attrs.$observe("disabled", function (newVal) {
                        init(), elm.slider("option", "disabled", !!newVal)
                    }), scope.$watch(attrs.uiSlider, function (newVal) {
                        init(), void 0 != newVal && elm.slider("option", newVal)
                    }, !0), $timeout(init, 0, !0), elm.bind("slide", function (event, ui) {
                        ngModel.$setViewValue(ui.values || ui.value), scope.$apply()
                    }), ngModel.$render = function () {
                        init();
                        var method = options.range === !0 ? "values" : "value";
                        !isNaN(ngModel.$viewValue) || ngModel.$viewValue instanceof Array || (ngModel.$viewValue = 0), options.range === !0 && (angular.isDefined(options.min) && options.min > ngModel.$viewValue[0] && (ngModel.$viewValue[0] = options.min), angular.isDefined(options.max) && options.max < ngModel.$viewValue[1] && (ngModel.$viewValue[1] = options.max), ngModel.$viewValue[0] >= ngModel.$viewValue[1] && (prevRangeValues.min >= ngModel.$viewValue[1] && (ngModel.$viewValue[0] = prevRangeValues.min), prevRangeValues.max <= ngModel.$viewValue[0] && (ngModel.$viewValue[1] = prevRangeValues.max)), prevRangeValues.min = ngModel.$viewValue[0], prevRangeValues.max = ngModel.$viewValue[1]), elm.slider(method, ngModel.$viewValue)
                    }, scope.$watch(attrs.ngModel, function () {
                        options.range === !0 && ngModel.$render()
                    }, !0), elm.bind("$destroy", destroy)
                }
            }
        }
    }
]), window.mobilecheck()) $(".browser-fail-mobile").show(), $(".browser-warning").remove();
else if (Modernizr.canvas)
    if (Modernizr.csstransitions) $(".browser-warning, .browser-fail, .browser-fail-mobile").remove();
    else {
        var date = new Date,
            today = date.getFullYear() + "" + date.getMonth() + date.getDay();
        localStorage.getItem("browserFailDate") !== today && ($(".browser-warning").show(), $(".browser-fail, .browser-fail-mobile").remove())
    } else $(".browser-fail").show(), $(".browser-warning, .browser-fail-mobile").remove();
$("a[target=_blank], a[target=_self]").on("click", function () {
        var url = $(this).attr("href");
        url.match(/http/i) && ga("send", "event", "Outbound Links", "click", url)
    }),
    function () {
        for (var lastTime = 0, vendors = ["webkit", "moz"], x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
        window.requestAnimationFrame || (window.requestAnimationFrame = function (callback) {
            var currTime = (new Date).getTime(),
                timeToCall = Math.max(0, 16 - (currTime - lastTime)),
                id = window.setTimeout(function () {
                    callback(currTime + timeToCall)
                }, timeToCall);
            return lastTime = currTime + timeToCall, id
        }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (id) {
            clearTimeout(id)
        })
    }();
var app = angular.module("galleryApp", ["ngRoute", "placeholderShim", "galleryControllers"]);
app.config(["$routeProvider", "$locationProvider", "$sceDelegateProvider",
    function ($routeProvider, $locationProvider, $sceDelegateProvider) {
        $(".app").data();
        Modernizr.history && $locationProvider.html5Mode(!0), $sceDelegateProvider.resourceUrlWhitelist(["self", "https://d2w3xqbnulbs3i.cloudfront.net/**"]), $routeProvider.when("/:market/:locale/artworks", {
            templateUrl: "/assets/artwork-d5445b1c643d2727ba40419add782e97.html",
            controller: "SingleArtwork"
        }).when("/:market/:locale/artworks/recent", {
            templateUrl: "/assets/artwork-d5445b1c643d2727ba40419add782e97.html",
            controller: "SingleArtwork"
        }).when("/:market/:locale/users/:userId/artworks", {
            templateUrl: "/assets/artwork-d5445b1c643d2727ba40419add782e97.html",
            controller: "SingleArtwork"
        }).when("/:market/:locale/artworks/:artworkId", {
            templateUrl: "/assets/artwork-d5445b1c643d2727ba40419add782e97.html",
            controller: "SingleArtwork"
        }).when("/:market/:locale/users/:userId/artworks/:artworkId", {
            templateUrl: "/assets/artwork-d5445b1c643d2727ba40419add782e97.html",
            controller: "SingleArtwork"
        })
    }
]);

